"name"	"package"	"summary"	"Description"	"Usage"	"Arguments"	"error"
"broom"	"broom"	"Convert Statistical Analysis Objects into Tidy Data Frames"	"<p>Convert statistical analysis objects from R into tidy data frames, so that they can more easily be combined, reshaped and otherwise processed with tools like dplyr, tidyr and ggplot2. The package provides three S3 generics: tidy, which summarizes a model's statistical findings such as coefficients of a regression; augment, which adds columns to the original data such as predictions, residuals and cluster assignments; and glance, which provides a one-row summary of model-level statistics. </p>"	NA	NA	FALSE
"aareg_tidiers"	"broom"	"Tidiers for aareg objects"	"<p>These tidy the coefficients of Aalen additive regression objects. </p>"	"<pre>## S3 method for class 'aareg' tidy(x, ...)<br />## S3 method for class 'aareg' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an 'aareg' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"acf_tidiers"	"broom"	"Tidying method for the acf function"	"<p>Tidy an 'acf' object, which is the output of <code>acf</code> and the related <code>pcf</code> and <code>ccf</code> functions. </p>"	"<pre>## S3 method for class 'acf' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>acf object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>(not used)</p> </td> </tr> </table> "	FALSE
"anova_tidiers"	"broom"	"Tidying methods for anova and AOV objects"	"<p>Tidies the result of an analysis of variance into an ANOVA table. Only a <code>tidy</code> method is provided, not an <code>augment</code> or <code>glance</code> method. </p>"	"<pre>## S3 method for class 'anova' tidy(x, ...)<br />## S3 method for class 'aov' tidy(x, ...)<br />## S3 method for class 'aovlist' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'anova', 'aov', or 'aovlist'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"Arima_tidiers"	"broom"	"Tidying methods for ARIMA modeling of time series"	"<p>These methods tidy the coefficients of ARIMA models of univariate time series. </p>"	"<pre>## S3 method for class 'Arima' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'Arima' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'Arima'</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"auc_tidiers"	"broom"	"Tidiers for objects from the AUC package"	"<p>Tidy 'roc' objects from the 'auc' package. This can be used to, for example, draw ROC curves in ggplot2. </p>"	"<pre>## S3 method for class 'roc' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an 'roc' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments, not used</p> </td> </tr> </table> "	FALSE
"augment"	"broom"	"Augment data according to a tidied model"	"<p>Given an R statistical model or other non-tidy object, add columns to the original dataset such as predictions, residuals and cluster assignments. </p>"	"<pre>augment(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>model or other R object to convert to data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed to methods</p> </td> </tr> </table> "	FALSE
"coxph_tidiers"	"broom"	"Tidiers for coxph object"	"<p>Tidy the coefficients of a Cox proportional hazards regression model, construct predictions, or summarize the entire model into a single row. </p>"	"<pre>## S3 method for class 'coxph' tidy(x, exponentiate = FALSE, conf.int = 0.95, ...)<br />## S3 method for class 'coxph' augment(x, data = stats::model.frame(x), newdata,<br />   type.predict = 'lp', type.residuals = 'martingale', ...)<br />## S3 method for class 'coxph' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>'coxph' object</p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to report the estimate and confidence intervals on an exponential scale</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>confidence level to be used for CI</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data for <code>augment</code></p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data on which to do predictions</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>type of predicted value (see <code>predict.coxph</code>)</p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>type of residuals (see <code>residuals.coxph</code>)</p> </td> </tr> </table> "	FALSE
"data.frame_tidiers"	"broom"	"Tidiers for data.frame objects"	"<p>These perform tidy summaries of data.frame objects. <code>tidy</code> produces summary statistics about each column, while <code>glance</code> simply reports the number of rows and columns. Note that <code>augment.data.frame</code> will throw an error. </p>"	"<pre>## S3 method for class 'data.frame' tidy(x, ...)<br />## S3 method for class 'data.frame' augment(x, data, ...)<br />## S3 method for class 'data.frame' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data.frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments: for <code>tidy</code>, these are passed on to <code>describe</code> from <code>psych</code> package</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>data, not used</p> </td> </tr> </table> "	FALSE
"felm_tidiers"	"broom"	"Tidying methods for models with multiple group fixed effects"	"<p>These methods tidy the coefficients of a linear model with multiple group fixed effects </p>"	"<pre>## S3 method for class 'felm' tidy(x, conf.int = FALSE, conf.level = 0.95, fe = FALSE,<br />   fe.error = fe, ...)<br />## S3 method for class 'felm' augment(x, data = NULL, ...)<br />## S3 method for class 'felm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>felm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>fe</code></td> <td> <p>whether to include estimates of fixed effects</p> </td> </tr> <tr valign='top'> <td><code>fe.error</code></td> <td> <p>whether to include standard error of fixed effects</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> </table> "	FALSE
"kmeans_tidiers"	"broom"	"Tidying methods for kmeans objects"	"<p>These methods summarize the results of k-means clustering into three tidy forms. <code>tidy</code> describes the center and size of each cluster, <code>augment</code> adds the cluster assignments to the original data, and <code>glance</code> summarizes the total within and between sum of squares of the clustering. </p>"	"<pre>## S3 method for class 'kmeans' tidy(x, col.names = paste0('x', 1:ncol(x$centers)), ...)<br />## S3 method for class 'kmeans' augment(x, data, ...)<br />## S3 method for class 'kmeans' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>kmeans object</p> </td> </tr> <tr valign='top'> <td><code>col.names</code></td> <td> <p>The names to call each dimension of the data in <code>tidy</code>. Defaults to <code>x1, x2...</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data (required for <code>augment</code>)</p> </td> </tr> </table> "	FALSE
"lm_tidiers"	"broom"	"Tidying methods for a linear model"	"<p>These methods tidy the coefficients of a linear model into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'lm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'summary.lm' tidy(x, ...)<br />## S3 method for class 'lm' augment(x, data = stats::model.frame(x), newdata, type.predict,<br />   type.residuals, ...)<br />## S3 method for class 'lm' glance(x, ...)<br />## S3 method for class 'summary.lm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>lm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to the extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, performs predictions on the new data</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>Type of prediction to compute for a GLM; passed on to <code>predict.glm</code></p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>Type of residuals to compute for a GLM; passed on to <code>residuals.glm</code></p> </td> </tr> </table> "	FALSE
"nlme_tidiers"	"broom"	"Tidying methods for mixed effects models"	"<p>These methods tidy the coefficients of mixed effects models of the <code>lme</code> class from functions  of the <code>nlme</code> package. </p>"	"<pre>## S3 method for class 'lme' tidy(x, effects = 'random', ...)<br />## S3 method for class 'lme' augment(x, data = x$data, newdata, ...)<br />## S3 method for class 'lme' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>lme</code>, such as those from <code>lme</code> or <code>nlme</code></p> </td> </tr> <tr valign='top'> <td><code>effects</code></td> <td> <p>Either 'random' (default) or 'fixed'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data to be used for prediction; optional</p> </td> </tr> </table> "	FALSE
"loess_tidiers"	"broom"	"Augmenting methods for loess models"	"<p>This method augments the original data with information on the fitted values and residuals, and optionally the  standard errors. </p>"	"<pre>## S3 method for class 'loess' augment(x, data = stats::model.frame(x), newdata, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'loess' object</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to the extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, performs predictions on the new data</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments</p> </td> </tr> </table> "	FALSE
"mclust_tidiers"	"broom"	"Tidying methods for Mclust objects"	"<p>These methods summarize the results of Mclust clustering into three tidy forms. <code>tidy</code> describes the size, mixing probability, mean and variabilty of each class, <code>augment</code> adds the class assignments and their probabilities to the original data, and <code>glance</code> summarizes the model parameters of the clustering. </p>"	"<pre>## S3 method for class 'Mclust' tidy(x, ...)<br />## S3 method for class 'Mclust' augment(x, data, ...)<br />## S3 method for class 'Mclust' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Mclust object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data (required for <code>augment</code>)</p> </td> </tr> </table> "	FALSE
"lme4_tidiers"	"broom"	"Tidying methods for mixed effects models"	"<p>These methods tidy the coefficients of mixed effects models, particularly responses of the <code>merMod</code> class </p>"	"<pre>## S3 method for class 'merMod' tidy(x, effects = c('ran_pars', 'fixed'), scales = NULL,<br />   ran_prefix = NULL, conf.int = FALSE, conf.level = 0.95,<br />   conf.method = 'Wald', ...)<br />## S3 method for class 'merMod' augment(x, data = stats::model.frame(x), newdata, ...)<br />## S3 method for class 'merMod' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>merMod</code>, such as those from <code>lmer</code>, <code>glmer</code>, or <code>nlmer</code></p> </td> </tr> <tr valign='top'> <td><code>effects</code></td> <td> <p>A character vector including one or more of 'fixed' (fixed-effect parameters), 'ran_pars' (variances and covariances or standard deviations and correlations of random effect terms) or 'ran_modes' (conditional modes/BLUPs/latent variable estimates)</p> </td> </tr> <tr valign='top'> <td><code>scales</code></td> <td> <p>scales on which to report the variables: for random effects, the choices are ‘'sdcor'’ (standard deviations and correlations: the default if <code>scales</code> is <code>NULL</code>) or ‘'vcov'’ (variances and covariances). <code>NA</code> means no transformation, appropriate e.g. for fixed effects; inverse-link transformations (exponentiation or logistic) are not yet implemented, but may be in the future.</p> </td> </tr> <tr valign='top'> <td><code>ran_prefix</code></td> <td> <p>a length-2 character vector specifying the strings to use as prefixes for self- (variance/standard deviation) and cross- (covariance/correlation) random effects terms</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>conf.method</code></td> <td> <p>method for computing confidence intervals (see <code>lme4::confint.merMod</code>)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data to be used for prediction; optional</p> </td> </tr> </table> "	FALSE
"rq_tidiers"	"broom"	"Tidying methods for quantile regression models"	"<p>These methods tidy the coefficients of a quantile regression model into a summary, augment the original data with information on the fitted values and residuals, and construct a glance of the model's statistics. </p>"	"<pre>## S3 method for class 'rq' tidy(x, se.type = 'rank', conf.int = TRUE, conf.level = 0.95,<br />   alpha = 1 - conf.level, ...)<br />## S3 method for class 'rqs' tidy(x, se.type = 'rank', conf.int = TRUE,<br />   conf.level = 0.95, alpha = 1 - conf.level, ...)<br />## S3 method for class 'nlrq' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'rq' glance(x, ...)<br />## S3 method for class 'nlrq' glance(x, ...)<br />## S3 method for class 'rq' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'rqs' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'nlrq' augment(x, data = NULL, newdata = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>model object returned by <code>rq</code> or <code>nlrq</code></p> </td> </tr> <tr valign='top'> <td><code>se.type</code></td> <td> <p>Type of standard errors to calculate; see <code>summary.rq</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>boolean; should confidence intervals be calculated, ignored if <code>se.type = 'rank'</code></p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for intervals</p> </td> </tr> <tr valign='top'> <td><code>alpha</code></td> <td> <p>confidence level when <code>se.type = 'rank'</code>; defaults to the same as <code>conf.level</code> although the specification is inverted</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, new data frame to use for predictions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>summary.rq</code></p> </td> </tr> </table> "	FALSE
"nls_tidiers"	"broom"	"Tidying methods for a nonlinear model"	"<p>These methods tidy the coefficients of a nonlinear model into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'nls' tidy(x, conf.int = FALSE, conf.level = 0.95, quick = FALSE,<br />   ...)<br />## S3 method for class 'nls' augment(x, data = NULL, newdata = NULL, ...)<br />## S3 method for class 'nls' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'nls'</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed from nls (may not be successful)</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data frame to use for predictions</p> </td> </tr> </table> "	FALSE
"plm_tidiers"	"broom"	"Tidiers for panel regression linear models"	"<p>Tidiers for panel regression linear models </p>"	"<pre>## S3 method for class 'plm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, ...)<br />## S3 method for class 'plm' augment(x, data = as.data.frame(stats::model.frame(x)), ...)<br />## S3 method for class 'plm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'plm' object representing a panel object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original dataset</p> </td> </tr> </table> "	FALSE
"poLCA_tidiers"	"broom"	"Tidiers for poLCA objects"	"<p>Tidiers for poLCA latent class regression models. Summarize the probabilities of each outcome for each variable within each class with <code>tidy</code>, add predictions to the data with <code>augment</code>, or find the log-likelihood/AIC/BIC with <code>glance</code>. </p>"	"<pre>## S3 method for class 'poLCA' tidy(x, ...)<br />## S3 method for class 'poLCA' augment(x, data, ...)<br />## S3 method for class 'poLCA' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A poLCA object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>For <code>augment</code>, the original dataset used to fit the latent class model. If not given, uses manifest variables in <code>x$y</code> and, if applicable, covariates in <code>x$x</code></p> </td> </tr> </table> "	FALSE
"prcomp_tidiers"	"broom"	"Tidying methods for principal components analysis via prcomp"	"<p>These tidiers operate on the results of a principal components analysis computed using <code>prcomp</code>. The <code>tidy</code> method returns a data frame with either the eigenvectors representing each row or each column. </p>"	"<pre>## S3 method for class 'prcomp' tidy(x, matrix = 'u', ...)<br />## S3 method for class 'prcomp' augment(x, data = NULL, newdata, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class <code>'prcomp'</code> resulting from a call to <code>prcomp</code></p> </td> </tr> <tr valign='top'> <td><code>matrix</code></td> <td> <p>character; Indicates which sets of eigenvectors are returned in tidy form. 'v', 'rotation', or 'variables' will return information about each variable, while 'u', 'x', or 'samples' (default) returns the loadings for each original row. 'd' or 'pcs' returns information about each principal component.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>the original data on which principal components analysis was performed. This cannot be recovered from <code>x</code>. If <code>newdata</code> is supplied, <code>data</code> is ignored. If both <code>data</code> and <code>newdata</code> are missing, only the fitted locations on the principal components are returned.</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>data frame; new observations for which locations on principal components are sought.</p> </td> </tr> </table> "	FALSE
"rowwise_df_tidiers"	"broom"	"Tidying methods for rowwise_dfs from dplyr, for tidying each row andrecombining the results"	"<p>These <code>tidy</code>, <code>augment</code> and <code>glance</code> methods are for performing tidying on each row of a rowwise data frame created by dplyr's <code>group_by</code> and <code>do</code> operations. They first group a rowwise data frame based on all columns that are not lists, then perform the tidying operation on the specified column. This greatly shortens a common idiom of extracting tidy/augment/glance outputs after a do statement. </p>"	"<pre>## S3 method for class 'rowwise_df' tidy(x, object, ...)<br />## S3 method for class 'rowwise_df' tidy_(x, object, ...)<br />## S3 method for class 'rowwise_df' augment(x, object, ...)<br />## S3 method for class 'rowwise_df' augment_(x, object, ...)<br />## S3 method for class 'rowwise_df' glance(x, object, ...)<br />## S3 method for class 'rowwise_df' glance_(x, object, ...)<br />## S3 method for class 'tbl_df' tidy(x, ...)<br />## S3 method for class 'tbl_df' augment(x, ...)<br />## S3 method for class 'tbl_df' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a rowwise_df</p> </td> </tr> <tr valign='top'> <td><code>object</code></td> <td> <p>the column name of the column containing the models to be tidied. For tidy, augment, and glance it should be the bare name; for _ methods it should be quoted.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass on to the respective tidying method</p> </td> </tr> </table> "	FALSE
"rq_tidiers"	"broom"	"Tidying methods for quantile regression models"	"<p>These methods tidy the coefficients of a quantile regression model into a summary, augment the original data with information on the fitted values and residuals, and construct a glance of the model's statistics. </p>"	"<pre>## S3 method for class 'rq' tidy(x, se.type = 'rank', conf.int = TRUE, conf.level = 0.95,<br />   alpha = 1 - conf.level, ...)<br />## S3 method for class 'rqs' tidy(x, se.type = 'rank', conf.int = TRUE,<br />   conf.level = 0.95, alpha = 1 - conf.level, ...)<br />## S3 method for class 'nlrq' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'rq' glance(x, ...)<br />## S3 method for class 'nlrq' glance(x, ...)<br />## S3 method for class 'rq' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'rqs' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'nlrq' augment(x, data = NULL, newdata = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>model object returned by <code>rq</code> or <code>nlrq</code></p> </td> </tr> <tr valign='top'> <td><code>se.type</code></td> <td> <p>Type of standard errors to calculate; see <code>summary.rq</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>boolean; should confidence intervals be calculated, ignored if <code>se.type = 'rank'</code></p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for intervals</p> </td> </tr> <tr valign='top'> <td><code>alpha</code></td> <td> <p>confidence level when <code>se.type = 'rank'</code>; defaults to the same as <code>conf.level</code> although the specification is inverted</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, new data frame to use for predictions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>summary.rq</code></p> </td> </tr> </table> "	FALSE
"rq_tidiers"	"broom"	"Tidying methods for quantile regression models"	"<p>These methods tidy the coefficients of a quantile regression model into a summary, augment the original data with information on the fitted values and residuals, and construct a glance of the model's statistics. </p>"	"<pre>## S3 method for class 'rq' tidy(x, se.type = 'rank', conf.int = TRUE, conf.level = 0.95,<br />   alpha = 1 - conf.level, ...)<br />## S3 method for class 'rqs' tidy(x, se.type = 'rank', conf.int = TRUE,<br />   conf.level = 0.95, alpha = 1 - conf.level, ...)<br />## S3 method for class 'nlrq' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'rq' glance(x, ...)<br />## S3 method for class 'nlrq' glance(x, ...)<br />## S3 method for class 'rq' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'rqs' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'nlrq' augment(x, data = NULL, newdata = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>model object returned by <code>rq</code> or <code>nlrq</code></p> </td> </tr> <tr valign='top'> <td><code>se.type</code></td> <td> <p>Type of standard errors to calculate; see <code>summary.rq</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>boolean; should confidence intervals be calculated, ignored if <code>se.type = 'rank'</code></p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for intervals</p> </td> </tr> <tr valign='top'> <td><code>alpha</code></td> <td> <p>confidence level when <code>se.type = 'rank'</code>; defaults to the same as <code>conf.level</code> although the specification is inverted</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, new data frame to use for predictions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>summary.rq</code></p> </td> </tr> </table> "	FALSE
"smooth.spline_tidiers"	"broom"	"tidying methods for smooth.spline objects"	"<p>This combines the original data given to smooth.spline with the fit and residuals </p>"	"<pre>## S3 method for class 'smooth.spline' augment(x, data = x$data, ...)<br />## S3 method for class 'smooth.spline' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a smooth.spline object</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>defaults to data used to fit model</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used in this method</p> </td> </tr> </table> "	FALSE
"survreg_tidiers"	"broom"	"Tidiers for a parametric regression survival model"	"<p>Tidies the coefficients of a parametric survival regression model, from the 'survreg' function, adds fitted values and residuals, or summarizes the model statistics. </p>"	"<pre>## S3 method for class 'survreg' tidy(x, conf.level = 0.95, ...)<br />## S3 method for class 'survreg' augment(x, data = stats::model.frame(x), newdata,<br />   type.predict = 'response', type.residuals = 'response', ...)<br />## S3 method for class 'survreg' glance(x, conf.level = 0.95, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'survreg' model</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data; if it is not provided, it is reconstructed as best as possible with <code>model.frame</code></p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>New data to use for prediction; optional</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>type of prediction, default 'response'</p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>type of residuals to calculate, default 'response'</p> </td> </tr> </table> "	FALSE
"rowwise_df_tidiers"	"broom"	"Tidying methods for rowwise_dfs from dplyr, for tidying each row andrecombining the results"	"<p>These <code>tidy</code>, <code>augment</code> and <code>glance</code> methods are for performing tidying on each row of a rowwise data frame created by dplyr's <code>group_by</code> and <code>do</code> operations. They first group a rowwise data frame based on all columns that are not lists, then perform the tidying operation on the specified column. This greatly shortens a common idiom of extracting tidy/augment/glance outputs after a do statement. </p>"	"<pre>## S3 method for class 'rowwise_df' tidy(x, object, ...)<br />## S3 method for class 'rowwise_df' tidy_(x, object, ...)<br />## S3 method for class 'rowwise_df' augment(x, object, ...)<br />## S3 method for class 'rowwise_df' augment_(x, object, ...)<br />## S3 method for class 'rowwise_df' glance(x, object, ...)<br />## S3 method for class 'rowwise_df' glance_(x, object, ...)<br />## S3 method for class 'tbl_df' tidy(x, ...)<br />## S3 method for class 'tbl_df' augment(x, ...)<br />## S3 method for class 'tbl_df' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a rowwise_df</p> </td> </tr> <tr valign='top'> <td><code>object</code></td> <td> <p>the column name of the column containing the models to be tidied. For tidy, augment, and glance it should be the bare name; for _ methods it should be quoted.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass on to the respective tidying method</p> </td> </tr> </table> "	FALSE
"rowwise_df_tidiers"	"broom"	"Tidying methods for rowwise_dfs from dplyr, for tidying each row andrecombining the results"	"<p>These <code>tidy</code>, <code>augment</code> and <code>glance</code> methods are for performing tidying on each row of a rowwise data frame created by dplyr's <code>group_by</code> and <code>do</code> operations. They first group a rowwise data frame based on all columns that are not lists, then perform the tidying operation on the specified column. This greatly shortens a common idiom of extracting tidy/augment/glance outputs after a do statement. </p>"	"<pre>## S3 method for class 'rowwise_df' tidy(x, object, ...)<br />## S3 method for class 'rowwise_df' tidy_(x, object, ...)<br />## S3 method for class 'rowwise_df' augment(x, object, ...)<br />## S3 method for class 'rowwise_df' augment_(x, object, ...)<br />## S3 method for class 'rowwise_df' glance(x, object, ...)<br />## S3 method for class 'rowwise_df' glance_(x, object, ...)<br />## S3 method for class 'tbl_df' tidy(x, ...)<br />## S3 method for class 'tbl_df' augment(x, ...)<br />## S3 method for class 'tbl_df' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a rowwise_df</p> </td> </tr> <tr valign='top'> <td><code>object</code></td> <td> <p>the column name of the column containing the models to be tidied. For tidy, augment, and glance it should be the bare name; for _ methods it should be quoted.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass on to the respective tidying method</p> </td> </tr> </table> "	FALSE
"augment_columns"	"broom"	"add fitted values, residuals, and other common outputs toan augment call"	"<p>Add fitted values, residuals, and other common outputs to the value returned from <code>augment</code>. </p>"	"<pre>augment_columns(x, data, newdata, type, type.predict = type,<br />   type.residuals = type, se.fit = TRUE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a model</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data onto which columns should be added</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data to predict on, optional</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>Type of prediction and residuals to compute</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>Type of prediction to compute; by default same as <code>type</code></p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>Type of residuals to compute; by default same as <code>type</code></p> </td> </tr> <tr valign='top'> <td><code>se.fit</code></td> <td> <p>Value to pass to predict's <code>se.fit</code>, or NULL for no value</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"biglm_tidiers"	"broom"	"Tidiers for biglm and bigglm object"	"<p>Tidiers for biglm object from the 'biglm' package, which contains a linear model object that is limited in memory usage. Generally the behavior is as similar to the <code>lm_tidiers</code> as is possible. Currently no <code>augment</code> is defined. </p>"	"<pre>## S3 method for class 'biglm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'biglm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'biglm' object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"binDesign_tidiers"	"broom"	"Tidy a binDesign object"	"<p>Tidy a binDesign object from the 'binGroup' package, which determines the sample size needed for a particular power. </p>"	"<pre>## S3 method for class 'binDesign' tidy(x, ...)<br />## S3 method for class 'binDesign' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'binDesign' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"binWidth_tidiers"	"broom"	"Tidy a binWidth object"	"<p>Tidy a binWidth object from the 'binGroup' package, which calculates the expected width of a confidence interval from a binomial test. </p>"	"<pre>## S3 method for class 'binWidth' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'binWidth' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"bootstrap"	"broom"	"Set up bootstrap replicates of a dplyr operation"	"<p>Set up bootstrap replicates of a dplyr operation </p>"	"<pre>bootstrap(df, m, by_group = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>df</code></td> <td> <p>a data frame</p> </td> </tr> <tr valign='top'> <td><code>m</code></td> <td> <p>number of bootstrap replicates to perform</p> </td> </tr> <tr valign='top'> <td><code>by_group</code></td> <td> <p>If <code>TRUE</code>, then bootstrap within each group if <code>df</code> is a grouped tbl.</p> </td> </tr> </table> "	FALSE
"boot_tidiers"	"broom"	"Tidying methods for bootstrap computations"	"<p>Tidying methods for 'boot' objects from the 'boot' package. </p>"	"<pre>## S3 method for class 'boot' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   conf.method = 'perc', ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p><code>boot</code> object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>conf.method</code></td> <td> <p>method for computing confidence intervals (see <code>boot.ci</code>)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"broom"	"broom"	"Convert Statistical Analysis Objects into Tidy Data Frames"	"<p>Convert statistical analysis objects from R into tidy data frames, so that they can more easily be combined, reshaped and otherwise processed with tools like dplyr, tidyr and ggplot2. The package provides three S3 generics: tidy, which summarizes a model's statistical findings such as coefficients of a regression; augment, which adds columns to the original data such as predictions, residuals and cluster assignments; and glance, which provides a one-row summary of model-level statistics. </p>"	NA	NA	FALSE
"btergm_tidiers"	"broom"	"Tidying method for a bootstrapped temporal exponential random graph model"	"<p>This method tidies the coefficients of a bootstrapped temporal exponential  random graph model estimated with the <span class='pkg'>xergm</span>. It simply returns the coefficients and their confidence intervals. </p>"	"<pre>## S3 method for class 'btergm' tidy(x, conf.level = 0.95, exponentiate = FALSE,<br />   quick = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a <code>btergm</code> object</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the bootstrapped interval</p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (currently not used)</p> </td> </tr> </table> "	FALSE
"cch_tidiers"	"broom"	"tidiers for case-cohort data"	"<p>Tidiers for case-cohort analyses: summarize each estimated coefficient, or test the overall model. </p>"	"<pre>## S3 method for class 'cch' tidy(x, conf.level = 0.95, ...)<br />## S3 method for class 'cch' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'cch' object</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"compact"	"broom"	"Remove NULL items in a vector or list"	"<p>Remove NULL items in a vector or list </p>"	"<pre>compact(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>a vector or list</p> </td> </tr></table>"	FALSE
"confint.geeglm"	"broom"	"Confidence interval for geeglm objects"	"<p>Generate confidence intervals for GEE analyses </p>"	"<pre>## S3 method for class 'geeglm' confint(object, parm, level = 0.95, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>object</code></td> <td> <p>The 'geeglm' object</p> </td> </tr> <tr valign='top'> <td><code>parm</code></td> <td> <p>The parameter to calculate the confidence interval for.  If not specified, the default is to calculate a confidence interval on all parameters (all variables in the model).</p> </td> </tr> <tr valign='top'> <td><code>level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional parameters</p> </td> </tr> </table> "	FALSE
"confint_tidy"	"broom"	"Calculate confidence interval as a tidy data frame"	"<p>Return a confidence interval as a tidy data frame. This directly wraps the <code>confint</code> function, but ensures it folllows broom conventions: column names of <code>conf.low</code> and <code>conf.high</code>, and no row names </p>"	"<pre>confint_tidy(x, conf.level = 0.95, func = stats::confint, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a model object for which <code>confint</code> can be calculated</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level</p> </td> </tr> <tr valign='top'> <td><code>func</code></td> <td> <p>Function to use for computing confint</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments passed on to <code>confint</code></p> </td> </tr> </table> "	FALSE
"coxph_tidiers"	"broom"	"Tidiers for coxph object"	"<p>Tidy the coefficients of a Cox proportional hazards regression model, construct predictions, or summarize the entire model into a single row. </p>"	"<pre>## S3 method for class 'coxph' tidy(x, exponentiate = FALSE, conf.int = 0.95, ...)<br />## S3 method for class 'coxph' augment(x, data = stats::model.frame(x), newdata,<br />   type.predict = 'lp', type.residuals = 'martingale', ...)<br />## S3 method for class 'coxph' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>'coxph' object</p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to report the estimate and confidence intervals on an exponential scale</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>confidence level to be used for CI</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data for <code>augment</code></p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data on which to do predictions</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>type of predicted value (see <code>predict.coxph</code>)</p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>type of residuals (see <code>residuals.coxph</code>)</p> </td> </tr> </table> "	FALSE
"cv.glmnet_tidiers"	"broom"	"Tidiers for glmnet cross-validation objects"	"<p>Tidying methods for cross-validation performed by <code>glmnet.cv</code>, summarizing the mean-squared-error across choices of the penalty parameter lambda. </p>"	"<pre>## S3 method for class 'cv.glmnet' tidy(x, ...)<br />## S3 method for class 'cv.glmnet' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'cv.glmnet' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"data.frame_tidiers"	"broom"	"Tidiers for data.frame objects"	"<p>These perform tidy summaries of data.frame objects. <code>tidy</code> produces summary statistics about each column, while <code>glance</code> simply reports the number of rows and columns. Note that <code>augment.data.frame</code> will throw an error. </p>"	"<pre>## S3 method for class 'data.frame' tidy(x, ...)<br />## S3 method for class 'data.frame' augment(x, data, ...)<br />## S3 method for class 'data.frame' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data.frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments: for <code>tidy</code>, these are passed on to <code>describe</code> from <code>psych</code> package</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>data, not used</p> </td> </tr> </table> "	FALSE
"ergm_tidiers"	"broom"	"Tidying methods for an exponential random graph model"	"<p>These methods tidy the coefficients of an exponential random graph model estimated with the <span class='pkg'>ergm</span> package into a summary, and construct a one-row glance of the model's statistics. The methods should work with any model that conforms to the <span class='pkg'>ergm</span> class, such as those produced from weighted networks by the <span class='pkg'>ergm.count</span> package. </p>"	"<pre>## S3 method for class 'ergm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'ergm' glance(x, deviance = FALSE, mcmc = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an <span class='pkg'>ergm</span> object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments passed to <code>summary.ergm</code></p> </td> </tr> <tr valign='top'> <td><code>deviance</code></td> <td> <p>whether to report null and residual deviance for the model, along with degrees of freedom; defaults to <code>FALSE</code></p> </td> </tr> <tr valign='top'> <td><code>mcmc</code></td> <td> <p>whether to report MCMC interval, burn-in and sample size used to estimate the model; defaults to <code>FALSE</code></p> </td> </tr> </table> "	FALSE
"felm_tidiers"	"broom"	"Tidying methods for models with multiple group fixed effects"	"<p>These methods tidy the coefficients of a linear model with multiple group fixed effects </p>"	"<pre>## S3 method for class 'felm' tidy(x, conf.int = FALSE, conf.level = 0.95, fe = FALSE,<br />   fe.error = fe, ...)<br />## S3 method for class 'felm' augment(x, data = NULL, ...)<br />## S3 method for class 'felm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>felm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>fe</code></td> <td> <p>whether to include estimates of fixed effects</p> </td> </tr> <tr valign='top'> <td><code>fe.error</code></td> <td> <p>whether to include standard error of fixed effects</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> </table> "	FALSE
"finish_glance"	"broom"	"Add logLik, AIC, BIC, and other common measurements to a glance ofa prediction"	"<p>A helper function for several functions in the glance generic. Methods such as logLik, AIC, and BIC are defined for many prediction objects, such as lm, glm, and nls. This is a helper function that adds them to a glance data.frame can be performed. If any of them cannot be computed, it fails quietly. </p>"	"<pre>finish_glance(ret, x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>ret</code></td> <td> <p>a one-row data frame (a partially complete glance)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>the prediction model</p> </td> </tr> </table> "	FALSE
"fitdistr_tidiers"	"broom"	"Tidying methods for fitdistr objects from the MASS package"	"<p>These methods tidies the parameter estimates resulting from an estimation of a univariate distribution's parameters. </p>"	"<pre>## S3 method for class 'fitdistr' tidy(x, ...)<br />## S3 method for class 'fitdistr' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'fitdistr'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"fix_data_frame"	"broom"	"Ensure an object is a data frame, with rownames moved into a column"	"<p>Ensure an object is a data frame, with rownames moved into a column </p>"	"<pre>fix_data_frame(x, newnames = NULL, newcol = 'term') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a data.frame or matrix</p> </td> </tr> <tr valign='top'> <td><code>newnames</code></td> <td> <p>new column names, not including the rownames</p> </td> </tr> <tr valign='top'> <td><code>newcol</code></td> <td> <p>the name of the new rownames column</p> </td> </tr> </table> "	FALSE
"gamlss_tidiers"	"broom"	"Tidying methods for gamlss objects"	"<p>Tidying methods for 'gamlss' objects from the gamlss package. </p>"	"<pre>## S3 method for class 'gamlss' tidy(x, quick = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'gamlss' object</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>Whether to perform a fast version, and return only the coefficients</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"gam_tidiers"	"broom"	"Tidying methods for a generalized additive model (gam)"	"<p>These methods tidy the coefficients of a 'gam' object (generalized additive model) into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'gam' tidy(x, ...)<br />## S3 method for class 'gam' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>gam object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"geeglm_tidiers"	"broom"	"Tidying methods for generalized estimating equations models"	"<p>These methods tidy the coefficients of generalized estimating equations models of the <code>geeglm</code> class from functions of the <code>geepack</code> package. </p>"	"<pre>## S3 method for class 'geeglm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>geeglm</code>, such as from <code>geeglm</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for log distributions)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments to be passed to other methods.  Currently not used.</p> </td> </tr> </table> "	FALSE
"glance"	"broom"	"Construct a single row summary \"glance\" of a model, fit, or otherobject"	"<p>glance methods always return either a one-row data frame, or NULL </p>"	"<pre>glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>model or other R object to convert to single-row data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed to methods</p> </td> </tr> </table>"	FALSE
"aareg_tidiers"	"broom"	"Tidiers for aareg objects"	"<p>These tidy the coefficients of Aalen additive regression objects. </p>"	"<pre>## S3 method for class 'aareg' tidy(x, ...)<br />## S3 method for class 'aareg' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an 'aareg' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"Arima_tidiers"	"broom"	"Tidying methods for ARIMA modeling of time series"	"<p>These methods tidy the coefficients of ARIMA models of univariate time series. </p>"	"<pre>## S3 method for class 'Arima' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'Arima' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'Arima'</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"biglm_tidiers"	"broom"	"Tidiers for biglm and bigglm object"	"<p>Tidiers for biglm object from the 'biglm' package, which contains a linear model object that is limited in memory usage. Generally the behavior is as similar to the <code>lm_tidiers</code> as is possible. Currently no <code>augment</code> is defined. </p>"	"<pre>## S3 method for class 'biglm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'biglm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'biglm' object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"binDesign_tidiers"	"broom"	"Tidy a binDesign object"	"<p>Tidy a binDesign object from the 'binGroup' package, which determines the sample size needed for a particular power. </p>"	"<pre>## S3 method for class 'binDesign' tidy(x, ...)<br />## S3 method for class 'binDesign' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'binDesign' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"cch_tidiers"	"broom"	"tidiers for case-cohort data"	"<p>Tidiers for case-cohort analyses: summarize each estimated coefficient, or test the overall model. </p>"	"<pre>## S3 method for class 'cch' tidy(x, conf.level = 0.95, ...)<br />## S3 method for class 'cch' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'cch' object</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"coxph_tidiers"	"broom"	"Tidiers for coxph object"	"<p>Tidy the coefficients of a Cox proportional hazards regression model, construct predictions, or summarize the entire model into a single row. </p>"	"<pre>## S3 method for class 'coxph' tidy(x, exponentiate = FALSE, conf.int = 0.95, ...)<br />## S3 method for class 'coxph' augment(x, data = stats::model.frame(x), newdata,<br />   type.predict = 'lp', type.residuals = 'martingale', ...)<br />## S3 method for class 'coxph' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>'coxph' object</p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to report the estimate and confidence intervals on an exponential scale</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>confidence level to be used for CI</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data for <code>augment</code></p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data on which to do predictions</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>type of predicted value (see <code>predict.coxph</code>)</p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>type of residuals (see <code>residuals.coxph</code>)</p> </td> </tr> </table> "	FALSE
"cv.glmnet_tidiers"	"broom"	"Tidiers for glmnet cross-validation objects"	"<p>Tidying methods for cross-validation performed by <code>glmnet.cv</code>, summarizing the mean-squared-error across choices of the penalty parameter lambda. </p>"	"<pre>## S3 method for class 'cv.glmnet' tidy(x, ...)<br />## S3 method for class 'cv.glmnet' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'cv.glmnet' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"data.frame_tidiers"	"broom"	"Tidiers for data.frame objects"	"<p>These perform tidy summaries of data.frame objects. <code>tidy</code> produces summary statistics about each column, while <code>glance</code> simply reports the number of rows and columns. Note that <code>augment.data.frame</code> will throw an error. </p>"	"<pre>## S3 method for class 'data.frame' tidy(x, ...)<br />## S3 method for class 'data.frame' augment(x, data, ...)<br />## S3 method for class 'data.frame' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data.frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments: for <code>tidy</code>, these are passed on to <code>describe</code> from <code>psych</code> package</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>data, not used</p> </td> </tr> </table> "	FALSE
"ergm_tidiers"	"broom"	"Tidying methods for an exponential random graph model"	"<p>These methods tidy the coefficients of an exponential random graph model estimated with the <span class='pkg'>ergm</span> package into a summary, and construct a one-row glance of the model's statistics. The methods should work with any model that conforms to the <span class='pkg'>ergm</span> class, such as those produced from weighted networks by the <span class='pkg'>ergm.count</span> package. </p>"	"<pre>## S3 method for class 'ergm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'ergm' glance(x, deviance = FALSE, mcmc = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an <span class='pkg'>ergm</span> object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments passed to <code>summary.ergm</code></p> </td> </tr> <tr valign='top'> <td><code>deviance</code></td> <td> <p>whether to report null and residual deviance for the model, along with degrees of freedom; defaults to <code>FALSE</code></p> </td> </tr> <tr valign='top'> <td><code>mcmc</code></td> <td> <p>whether to report MCMC interval, burn-in and sample size used to estimate the model; defaults to <code>FALSE</code></p> </td> </tr> </table> "	FALSE
"felm_tidiers"	"broom"	"Tidying methods for models with multiple group fixed effects"	"<p>These methods tidy the coefficients of a linear model with multiple group fixed effects </p>"	"<pre>## S3 method for class 'felm' tidy(x, conf.int = FALSE, conf.level = 0.95, fe = FALSE,<br />   fe.error = fe, ...)<br />## S3 method for class 'felm' augment(x, data = NULL, ...)<br />## S3 method for class 'felm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>felm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>fe</code></td> <td> <p>whether to include estimates of fixed effects</p> </td> </tr> <tr valign='top'> <td><code>fe.error</code></td> <td> <p>whether to include standard error of fixed effects</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> </table> "	FALSE
"fitdistr_tidiers"	"broom"	"Tidying methods for fitdistr objects from the MASS package"	"<p>These methods tidies the parameter estimates resulting from an estimation of a univariate distribution's parameters. </p>"	"<pre>## S3 method for class 'fitdistr' tidy(x, ...)<br />## S3 method for class 'fitdistr' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'fitdistr'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"gam_tidiers"	"broom"	"Tidying methods for a generalized additive model (gam)"	"<p>These methods tidy the coefficients of a 'gam' object (generalized additive model) into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'gam' tidy(x, ...)<br />## S3 method for class 'gam' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>gam object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"glm_tidiers"	"broom"	"Tidying methods for a glm object"	"<p>Tidy a <code>glm</code> object. The <code>tidy</code> and <code>augment</code> methods are handled by lm_tidiers. </p>"	"<pre>## S3 method for class 'glm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>glm object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"glmnet_tidiers"	"broom"	"Tidiers for LASSO or elasticnet regularized fits"	"<p>Tidying methods for regularized fits produced by <code>glmnet</code>, summarizing the estimates across values of the penalty parameter lambda. </p>"	"<pre>## S3 method for class 'glmnet' tidy(x, ...)<br />## S3 method for class 'glmnet' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'glmnet' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"gmm_tidiers"	"broom"	"Tidying methods for generalized method of moments \"gmm\" objects"	"<p>These methods tidy the coefficients of 'gmm' objects from the gmm package, or glance at the model-wide statistics (especially the J-test). </p>"	"<pre>## S3 method for class 'gmm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'gmm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>gmm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns (and confidence interval if requested, which may be slower)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"htest_tidiers"	"broom"	"Tidying methods for an htest object"	"<p>Tidies hypothesis test objects, such as those from <code>cor.test</code>, <code>t.test</code>, and <code>wilcox.test</code>, into a one-row data frame. </p>"	"<pre>## S3 method for class 'htest' tidy(x, ...)<br />## S3 method for class 'htest' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>'htest'</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"kmeans_tidiers"	"broom"	"Tidying methods for kmeans objects"	"<p>These methods summarize the results of k-means clustering into three tidy forms. <code>tidy</code> describes the center and size of each cluster, <code>augment</code> adds the cluster assignments to the original data, and <code>glance</code> summarizes the total within and between sum of squares of the clustering. </p>"	"<pre>## S3 method for class 'kmeans' tidy(x, col.names = paste0('x', 1:ncol(x$centers)), ...)<br />## S3 method for class 'kmeans' augment(x, data, ...)<br />## S3 method for class 'kmeans' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>kmeans object</p> </td> </tr> <tr valign='top'> <td><code>col.names</code></td> <td> <p>The names to call each dimension of the data in <code>tidy</code>. Defaults to <code>x1, x2...</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data (required for <code>augment</code>)</p> </td> </tr> </table> "	FALSE
"list_tidiers"	"broom"	"Tidiers for return values from functions that aren't S3 objects"	"<p>This method handles the return values of functions that return lists rather than S3 objects, such as <code>optim</code>, <code>svd</code>, or <code>interp</code>, and therefore cannot be handled by S3 dispatch. </p>"	"<pre>## S3 method for class 'list' tidy(x, ...)<br />## S3 method for class 'list' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>list object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, passed to the tidying function</p> </td> </tr> </table> "	FALSE
"lm_tidiers"	"broom"	"Tidying methods for a linear model"	"<p>These methods tidy the coefficients of a linear model into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'lm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'summary.lm' tidy(x, ...)<br />## S3 method for class 'lm' augment(x, data = stats::model.frame(x), newdata, type.predict,<br />   type.residuals, ...)<br />## S3 method for class 'lm' glance(x, ...)<br />## S3 method for class 'summary.lm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>lm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to the extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, performs predictions on the new data</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>Type of prediction to compute for a GLM; passed on to <code>predict.glm</code></p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>Type of residuals to compute for a GLM; passed on to <code>residuals.glm</code></p> </td> </tr> </table> "	FALSE
"nlme_tidiers"	"broom"	"Tidying methods for mixed effects models"	"<p>These methods tidy the coefficients of mixed effects models of the <code>lme</code> class from functions  of the <code>nlme</code> package. </p>"	"<pre>## S3 method for class 'lme' tidy(x, effects = 'random', ...)<br />## S3 method for class 'lme' augment(x, data = x$data, newdata, ...)<br />## S3 method for class 'lme' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>lme</code>, such as those from <code>lme</code> or <code>nlme</code></p> </td> </tr> <tr valign='top'> <td><code>effects</code></td> <td> <p>Either 'random' (default) or 'fixed'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data to be used for prediction; optional</p> </td> </tr> </table> "	FALSE
"lmodel2_tidiers"	"broom"	"Tidiers for linear model II objects from the lmodel2 package"	"<p>Tidy or glance an lmodel2 object. An lmodel2 represents model II simple linear regression, where both variables in the regression equation are random. </p>"	"<pre>## S3 method for class 'lmodel2' tidy(x, ...)<br />## S3 method for class 'lmodel2' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>lmodel2 object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table> "	FALSE
"matrix_tidiers"	"broom"	"Tidiers for matrix objects"	"<p>These perform tidying operations on matrix objects. <code>tidy</code> turns the matrix into a data.frame while bringing rownames, if they exist, in as a column called <code>.rownames</code> (since results of tidying operations never contain rownames). <code>glance</code> simply reports the number of rows and columns. Note that no augment method exists for matrices. </p>"	"<pre>## S3 method for class 'matrix' tidy(x, ...)<br />## S3 method for class 'matrix' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A matrix</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"mclust_tidiers"	"broom"	"Tidying methods for Mclust objects"	"<p>These methods summarize the results of Mclust clustering into three tidy forms. <code>tidy</code> describes the size, mixing probability, mean and variabilty of each class, <code>augment</code> adds the class assignments and their probabilities to the original data, and <code>glance</code> summarizes the model parameters of the clustering. </p>"	"<pre>## S3 method for class 'Mclust' tidy(x, ...)<br />## S3 method for class 'Mclust' augment(x, data, ...)<br />## S3 method for class 'Mclust' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Mclust object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data (required for <code>augment</code>)</p> </td> </tr> </table> "	FALSE
"lme4_tidiers"	"broom"	"Tidying methods for mixed effects models"	"<p>These methods tidy the coefficients of mixed effects models, particularly responses of the <code>merMod</code> class </p>"	"<pre>## S3 method for class 'merMod' tidy(x, effects = c('ran_pars', 'fixed'), scales = NULL,<br />   ran_prefix = NULL, conf.int = FALSE, conf.level = 0.95,<br />   conf.method = 'Wald', ...)<br />## S3 method for class 'merMod' augment(x, data = stats::model.frame(x), newdata, ...)<br />## S3 method for class 'merMod' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>merMod</code>, such as those from <code>lmer</code>, <code>glmer</code>, or <code>nlmer</code></p> </td> </tr> <tr valign='top'> <td><code>effects</code></td> <td> <p>A character vector including one or more of 'fixed' (fixed-effect parameters), 'ran_pars' (variances and covariances or standard deviations and correlations of random effect terms) or 'ran_modes' (conditional modes/BLUPs/latent variable estimates)</p> </td> </tr> <tr valign='top'> <td><code>scales</code></td> <td> <p>scales on which to report the variables: for random effects, the choices are ‘'sdcor'’ (standard deviations and correlations: the default if <code>scales</code> is <code>NULL</code>) or ‘'vcov'’ (variances and covariances). <code>NA</code> means no transformation, appropriate e.g. for fixed effects; inverse-link transformations (exponentiation or logistic) are not yet implemented, but may be in the future.</p> </td> </tr> <tr valign='top'> <td><code>ran_prefix</code></td> <td> <p>a length-2 character vector specifying the strings to use as prefixes for self- (variance/standard deviation) and cross- (covariance/correlation) random effects terms</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>conf.method</code></td> <td> <p>method for computing confidence intervals (see <code>lme4::confint.merMod</code>)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data to be used for prediction; optional</p> </td> </tr> </table> "	FALSE
"multinom_tidiers"	"broom"	"Tidying methods for multinomial logistic regression models"	"<p>These methods tidy the coefficients of multinomial logistic regression  models generated by <code>multinom</code> of the <code>nnet</code> package. </p>"	"<pre>## S3 method for class 'multinom' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = TRUE, ...)<br />## S3 method for class 'multinom' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A model object of class <code>multinom</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for multinomial logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"rq_tidiers"	"broom"	"Tidying methods for quantile regression models"	"<p>These methods tidy the coefficients of a quantile regression model into a summary, augment the original data with information on the fitted values and residuals, and construct a glance of the model's statistics. </p>"	"<pre>## S3 method for class 'rq' tidy(x, se.type = 'rank', conf.int = TRUE, conf.level = 0.95,<br />   alpha = 1 - conf.level, ...)<br />## S3 method for class 'rqs' tidy(x, se.type = 'rank', conf.int = TRUE,<br />   conf.level = 0.95, alpha = 1 - conf.level, ...)<br />## S3 method for class 'nlrq' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'rq' glance(x, ...)<br />## S3 method for class 'nlrq' glance(x, ...)<br />## S3 method for class 'rq' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'rqs' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'nlrq' augment(x, data = NULL, newdata = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>model object returned by <code>rq</code> or <code>nlrq</code></p> </td> </tr> <tr valign='top'> <td><code>se.type</code></td> <td> <p>Type of standard errors to calculate; see <code>summary.rq</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>boolean; should confidence intervals be calculated, ignored if <code>se.type = 'rank'</code></p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for intervals</p> </td> </tr> <tr valign='top'> <td><code>alpha</code></td> <td> <p>confidence level when <code>se.type = 'rank'</code>; defaults to the same as <code>conf.level</code> although the specification is inverted</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, new data frame to use for predictions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>summary.rq</code></p> </td> </tr> </table> "	FALSE
"nls_tidiers"	"broom"	"Tidying methods for a nonlinear model"	"<p>These methods tidy the coefficients of a nonlinear model into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'nls' tidy(x, conf.int = FALSE, conf.level = 0.95, quick = FALSE,<br />   ...)<br />## S3 method for class 'nls' augment(x, data = NULL, newdata = NULL, ...)<br />## S3 method for class 'nls' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'nls'</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed from nls (may not be successful)</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data frame to use for predictions</p> </td> </tr> </table> "	FALSE
"plm_tidiers"	"broom"	"Tidiers for panel regression linear models"	"<p>Tidiers for panel regression linear models </p>"	"<pre>## S3 method for class 'plm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, ...)<br />## S3 method for class 'plm' augment(x, data = as.data.frame(stats::model.frame(x)), ...)<br />## S3 method for class 'plm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'plm' object representing a panel object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original dataset</p> </td> </tr> </table> "	FALSE
"poLCA_tidiers"	"broom"	"Tidiers for poLCA objects"	"<p>Tidiers for poLCA latent class regression models. Summarize the probabilities of each outcome for each variable within each class with <code>tidy</code>, add predictions to the data with <code>augment</code>, or find the log-likelihood/AIC/BIC with <code>glance</code>. </p>"	"<pre>## S3 method for class 'poLCA' tidy(x, ...)<br />## S3 method for class 'poLCA' augment(x, data, ...)<br />## S3 method for class 'poLCA' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A poLCA object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>For <code>augment</code>, the original dataset used to fit the latent class model. If not given, uses manifest variables in <code>x$y</code> and, if applicable, covariates in <code>x$x</code></p> </td> </tr> </table> "	FALSE
"pyears_tidiers"	"broom"	"Tidy person-year summaries"	"<p>These tidy the output of <code>pyears</code>, a calculation of the person-years of follow-up time contributed by a cohort of subject. Since the output of <code>pyears$data</code> is already tidy (if the <code>data.frame = TRUE</code> argument is given), this does only a little work and should rarely be necessary. </p>"	"<pre>## S3 method for class 'pyears' tidy(x, ...)<br />## S3 method for class 'pyears' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'pyears' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"ridgelm_tidiers"	"broom"	"Tidying methods for ridgelm objects from the MASS package"	"<p>These methods tidies the coefficients of a ridge regression model chosen at each value of lambda into a data frame, or constructs a one-row glance of the model's choices of lambda (the ridge constant) </p>"	"<pre>## S3 method for class 'ridgelm' tidy(x, ...)<br />## S3 method for class 'ridgelm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'ridgelm'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"rlm_tidiers"	"broom"	"Tidying methods for an rlm (robust linear model) object"	"<p>This method provides a glance of an 'rlm' object. The <code>tidy</code> and <code>augment</code> methods are handled by lm_tidiers. </p>"	"<pre>## S3 method for class 'rlm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>rlm object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"rowwise_df_tidiers"	"broom"	"Tidying methods for rowwise_dfs from dplyr, for tidying each row andrecombining the results"	"<p>These <code>tidy</code>, <code>augment</code> and <code>glance</code> methods are for performing tidying on each row of a rowwise data frame created by dplyr's <code>group_by</code> and <code>do</code> operations. They first group a rowwise data frame based on all columns that are not lists, then perform the tidying operation on the specified column. This greatly shortens a common idiom of extracting tidy/augment/glance outputs after a do statement. </p>"	"<pre>## S3 method for class 'rowwise_df' tidy(x, object, ...)<br />## S3 method for class 'rowwise_df' tidy_(x, object, ...)<br />## S3 method for class 'rowwise_df' augment(x, object, ...)<br />## S3 method for class 'rowwise_df' augment_(x, object, ...)<br />## S3 method for class 'rowwise_df' glance(x, object, ...)<br />## S3 method for class 'rowwise_df' glance_(x, object, ...)<br />## S3 method for class 'tbl_df' tidy(x, ...)<br />## S3 method for class 'tbl_df' augment(x, ...)<br />## S3 method for class 'tbl_df' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a rowwise_df</p> </td> </tr> <tr valign='top'> <td><code>object</code></td> <td> <p>the column name of the column containing the models to be tidied. For tidy, augment, and glance it should be the bare name; for _ methods it should be quoted.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass on to the respective tidying method</p> </td> </tr> </table> "	FALSE
"rq_tidiers"	"broom"	"Tidying methods for quantile regression models"	"<p>These methods tidy the coefficients of a quantile regression model into a summary, augment the original data with information on the fitted values and residuals, and construct a glance of the model's statistics. </p>"	"<pre>## S3 method for class 'rq' tidy(x, se.type = 'rank', conf.int = TRUE, conf.level = 0.95,<br />   alpha = 1 - conf.level, ...)<br />## S3 method for class 'rqs' tidy(x, se.type = 'rank', conf.int = TRUE,<br />   conf.level = 0.95, alpha = 1 - conf.level, ...)<br />## S3 method for class 'nlrq' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'rq' glance(x, ...)<br />## S3 method for class 'nlrq' glance(x, ...)<br />## S3 method for class 'rq' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'rqs' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'nlrq' augment(x, data = NULL, newdata = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>model object returned by <code>rq</code> or <code>nlrq</code></p> </td> </tr> <tr valign='top'> <td><code>se.type</code></td> <td> <p>Type of standard errors to calculate; see <code>summary.rq</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>boolean; should confidence intervals be calculated, ignored if <code>se.type = 'rank'</code></p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for intervals</p> </td> </tr> <tr valign='top'> <td><code>alpha</code></td> <td> <p>confidence level when <code>se.type = 'rank'</code>; defaults to the same as <code>conf.level</code> although the specification is inverted</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, new data frame to use for predictions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>summary.rq</code></p> </td> </tr> </table> "	FALSE
"smooth.spline_tidiers"	"broom"	"tidying methods for smooth.spline objects"	"<p>This combines the original data given to smooth.spline with the fit and residuals </p>"	"<pre>## S3 method for class 'smooth.spline' augment(x, data = x$data, ...)<br />## S3 method for class 'smooth.spline' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a smooth.spline object</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>defaults to data used to fit model</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used in this method</p> </td> </tr> </table> "	FALSE
"rstanarm_tidiers"	"broom"	"Tidying methods for an rstanarm model"	"<p>These methods tidy the estimates from <code>stanreg-objects</code> (fitted model objects from the <span class='pkg'>rstanarm</span> package) into a summary. </p>"	"<pre>## S3 method for class 'stanreg' tidy(x, parameters = c('non-varying', 'varying',<br />   'hierarchical'), intervals = FALSE, prob = 0.9, ...)<br />## S3 method for class 'stanreg' glance(x, looic = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Fitted model object from the <span class='pkg'>rstanarm</span> package. See  <code>stanreg-objects</code>.</p> </td> </tr> <tr valign='top'> <td><code>parameters</code></td> <td> <p>One of <code>'non-varying'</code>, <code>'varying'</code>, or  <code>'hierarchical'</code> (can be abbreviated). See the Value section for  details.</p> </td> </tr> <tr valign='top'> <td><code>intervals</code></td> <td> <p>If <code>TRUE</code> columns for the lower and upper bounds of the <code>100*prob</code>% posterior uncertainty intervals are included. See  <code>posterior_interval</code> for details.</p> </td> </tr> <tr valign='top'> <td><code>prob</code></td> <td> <p>See <code>posterior_interval</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>For <code>glance</code>, if <code>looic=TRUE</code>, optional arguments to <code>loo.stanreg</code>.</p> </td> </tr> <tr valign='top'> <td><code>looic</code></td> <td> <p>Should the LOO Information Criterion be included? See  <code>loo.stanreg</code> for details. Note: for models fit to very large data this can be a slow computation.</p> </td> </tr> </table> "	FALSE
"lm_tidiers"	"broom"	"Tidying methods for a linear model"	"<p>These methods tidy the coefficients of a linear model into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'lm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'summary.lm' tidy(x, ...)<br />## S3 method for class 'lm' augment(x, data = stats::model.frame(x), newdata, type.predict,<br />   type.residuals, ...)<br />## S3 method for class 'lm' glance(x, ...)<br />## S3 method for class 'summary.lm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>lm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to the extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, performs predictions on the new data</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>Type of prediction to compute for a GLM; passed on to <code>predict.glm</code></p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>Type of residuals to compute for a GLM; passed on to <code>residuals.glm</code></p> </td> </tr> </table> "	FALSE
"summary_tidiers"	"broom"	"Tidiers for summaryDefault objects"	"<p>Tidy a summary of a vector. </p>"	"<pre>## S3 method for class 'summaryDefault' tidy(x, ...)<br />## S3 method for class 'summaryDefault' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>summaryDefault object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"sexpfit_tidiers"	"broom"	"Tidy an expected survival curve"	"<p>This constructs a summary across time points or overall of an expected survival curve. Note that this contains less information than most survfit objects. </p>"	"<pre>## S3 method for class 'survexp' tidy(x, ...)<br />## S3 method for class 'survexp' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>'survexp' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"survfit_tidiers"	"broom"	"tidy survival curve fits"	"<p>Construct tidied data frames showing survival curves over time. </p>"	"<pre>## S3 method for class 'survfit' tidy(x, ...)<br />## S3 method for class 'survfit' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>'survfit' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"survreg_tidiers"	"broom"	"Tidiers for a parametric regression survival model"	"<p>Tidies the coefficients of a parametric survival regression model, from the 'survreg' function, adds fitted values and residuals, or summarizes the model statistics. </p>"	"<pre>## S3 method for class 'survreg' tidy(x, conf.level = 0.95, ...)<br />## S3 method for class 'survreg' augment(x, data = stats::model.frame(x), newdata,<br />   type.predict = 'response', type.residuals = 'response', ...)<br />## S3 method for class 'survreg' glance(x, conf.level = 0.95, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'survreg' model</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data; if it is not provided, it is reconstructed as best as possible with <code>model.frame</code></p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>New data to use for prediction; optional</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>type of prediction, default 'response'</p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>type of residuals to calculate, default 'response'</p> </td> </tr> </table> "	FALSE
"rowwise_df_tidiers"	"broom"	"Tidying methods for rowwise_dfs from dplyr, for tidying each row andrecombining the results"	"<p>These <code>tidy</code>, <code>augment</code> and <code>glance</code> methods are for performing tidying on each row of a rowwise data frame created by dplyr's <code>group_by</code> and <code>do</code> operations. They first group a rowwise data frame based on all columns that are not lists, then perform the tidying operation on the specified column. This greatly shortens a common idiom of extracting tidy/augment/glance outputs after a do statement. </p>"	"<pre>## S3 method for class 'rowwise_df' tidy(x, object, ...)<br />## S3 method for class 'rowwise_df' tidy_(x, object, ...)<br />## S3 method for class 'rowwise_df' augment(x, object, ...)<br />## S3 method for class 'rowwise_df' augment_(x, object, ...)<br />## S3 method for class 'rowwise_df' glance(x, object, ...)<br />## S3 method for class 'rowwise_df' glance_(x, object, ...)<br />## S3 method for class 'tbl_df' tidy(x, ...)<br />## S3 method for class 'tbl_df' augment(x, ...)<br />## S3 method for class 'tbl_df' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a rowwise_df</p> </td> </tr> <tr valign='top'> <td><code>object</code></td> <td> <p>the column name of the column containing the models to be tidied. For tidy, augment, and glance it should be the bare name; for _ methods it should be quoted.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass on to the respective tidying method</p> </td> </tr> </table> "	FALSE
"rowwise_df_tidiers"	"broom"	"Tidying methods for rowwise_dfs from dplyr, for tidying each row andrecombining the results"	"<p>These <code>tidy</code>, <code>augment</code> and <code>glance</code> methods are for performing tidying on each row of a rowwise data frame created by dplyr's <code>group_by</code> and <code>do</code> operations. They first group a rowwise data frame based on all columns that are not lists, then perform the tidying operation on the specified column. This greatly shortens a common idiom of extracting tidy/augment/glance outputs after a do statement. </p>"	"<pre>## S3 method for class 'rowwise_df' tidy(x, object, ...)<br />## S3 method for class 'rowwise_df' tidy_(x, object, ...)<br />## S3 method for class 'rowwise_df' augment(x, object, ...)<br />## S3 method for class 'rowwise_df' augment_(x, object, ...)<br />## S3 method for class 'rowwise_df' glance(x, object, ...)<br />## S3 method for class 'rowwise_df' glance_(x, object, ...)<br />## S3 method for class 'tbl_df' tidy(x, ...)<br />## S3 method for class 'tbl_df' augment(x, ...)<br />## S3 method for class 'tbl_df' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a rowwise_df</p> </td> </tr> <tr valign='top'> <td><code>object</code></td> <td> <p>the column name of the column containing the models to be tidied. For tidy, augment, and glance it should be the bare name; for _ methods it should be quoted.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass on to the respective tidying method</p> </td> </tr> </table> "	FALSE
"optim_tidiers"	"broom"	"Tidiers for lists returned from optim"	"<p>Tidies objects returned by the <code>optim</code> function for general-purpose minimization and maximization. </p>"	"<pre>tidy_optim(x, ...)<br />glance_optim(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>list returned from <code>optim</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments</p> </td> </tr> </table> "	FALSE
"orcutt_tidiers"	"broom"	"Tidiers for Cochrane Orcutt object"	"<p>Tidies a Cochrane Orcutt object, which estimates autocorrelation and beta coefficients. This function is not exported and would not typically be called directly: it is dispatched by <code>tidy.list</code> and <code>glance.list</code>. </p>"	"<pre>tidy_orcutt(x, ...)<br />glance_orcutt(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list returned by <code>cochrane.orcutt</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments passed on to <code>tidy.summary.lm</code></p> </td> </tr> </table> "	FALSE
"glmnet_tidiers"	"broom"	"Tidiers for LASSO or elasticnet regularized fits"	"<p>Tidying methods for regularized fits produced by <code>glmnet</code>, summarizing the estimates across values of the penalty parameter lambda. </p>"	"<pre>## S3 method for class 'glmnet' tidy(x, ...)<br />## S3 method for class 'glmnet' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'glmnet' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"glm_tidiers"	"broom"	"Tidying methods for a glm object"	"<p>Tidy a <code>glm</code> object. The <code>tidy</code> and <code>augment</code> methods are handled by lm_tidiers. </p>"	"<pre>## S3 method for class 'glm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>glm object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"gmm_tidiers"	"broom"	"Tidying methods for generalized method of moments \"gmm\" objects"	"<p>These methods tidy the coefficients of 'gmm' objects from the gmm package, or glance at the model-wide statistics (especially the J-test). </p>"	"<pre>## S3 method for class 'gmm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'gmm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>gmm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns (and confidence interval if requested, which may be slower)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"htest_tidiers"	"broom"	"Tidying methods for an htest object"	"<p>Tidies hypothesis test objects, such as those from <code>cor.test</code>, <code>t.test</code>, and <code>wilcox.test</code>, into a one-row data frame. </p>"	"<pre>## S3 method for class 'htest' tidy(x, ...)<br />## S3 method for class 'htest' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>'htest'</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"inflate"	"broom"	"Expand a dataset to include all factorial combinations of one or morevariables"	"<p>Expand a dataset to include all factorial combinations of one or more variables </p>"	"<pre>inflate(.data, ..., stringsAsFactors = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments</p> </td> </tr> <tr valign='top'> <td><code>stringsAsFactors</code></td> <td> <p>logical specifying if character vectors are converted to factors.</p> </td> </tr> </table> "	FALSE
"insert_NAs"	"broom"	"insert a row of NAs into a data frame wherever another data frame has NAs"	"<p>insert a row of NAs into a data frame wherever another data frame has NAs </p>"	"<pre>insert_NAs(x, original) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>data frame that has one row for each non-NA row in original</p> </td> </tr> <tr valign='top'> <td><code>original</code></td> <td> <p>data frame with NAs</p> </td> </tr> </table>"	FALSE
"kappa_tidiers"	"broom"	"Tidy a kappa object from a Cohen's kappa calculation"	"<p>Tidy a 'kappa' object, from the <code>cohen.kappa</code> function in the psych package. This represents the agreement of two raters when using nominal scores. </p>"	"<pre>## S3 method for class 'kappa' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'kappa'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"kde_tidiers"	"broom"	"Tidy a kernel density estimate object from the ks package"	"<p>Tidy a kernel density estimate object, into a table with one row for each point in the estimated grid, and one column for each dimension (along with an <code>estimate</code> column with the estimated density). </p>"	"<pre>## S3 method for class 'kde' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'ks' object from the kde package</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table> "	FALSE
"kmeans_tidiers"	"broom"	"Tidying methods for kmeans objects"	"<p>These methods summarize the results of k-means clustering into three tidy forms. <code>tidy</code> describes the center and size of each cluster, <code>augment</code> adds the cluster assignments to the original data, and <code>glance</code> summarizes the total within and between sum of squares of the clustering. </p>"	"<pre>## S3 method for class 'kmeans' tidy(x, col.names = paste0('x', 1:ncol(x$centers)), ...)<br />## S3 method for class 'kmeans' augment(x, data, ...)<br />## S3 method for class 'kmeans' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>kmeans object</p> </td> </tr> <tr valign='top'> <td><code>col.names</code></td> <td> <p>The names to call each dimension of the data in <code>tidy</code>. Defaults to <code>x1, x2...</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data (required for <code>augment</code>)</p> </td> </tr> </table> "	FALSE
"list_tidiers"	"broom"	"Tidiers for return values from functions that aren't S3 objects"	"<p>This method handles the return values of functions that return lists rather than S3 objects, such as <code>optim</code>, <code>svd</code>, or <code>interp</code>, and therefore cannot be handled by S3 dispatch. </p>"	"<pre>## S3 method for class 'list' tidy(x, ...)<br />## S3 method for class 'list' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>list object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, passed to the tidying function</p> </td> </tr> </table> "	FALSE
"lme4_tidiers"	"broom"	"Tidying methods for mixed effects models"	"<p>These methods tidy the coefficients of mixed effects models, particularly responses of the <code>merMod</code> class </p>"	"<pre>## S3 method for class 'merMod' tidy(x, effects = c('ran_pars', 'fixed'), scales = NULL,<br />   ran_prefix = NULL, conf.int = FALSE, conf.level = 0.95,<br />   conf.method = 'Wald', ...)<br />## S3 method for class 'merMod' augment(x, data = stats::model.frame(x), newdata, ...)<br />## S3 method for class 'merMod' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>merMod</code>, such as those from <code>lmer</code>, <code>glmer</code>, or <code>nlmer</code></p> </td> </tr> <tr valign='top'> <td><code>effects</code></td> <td> <p>A character vector including one or more of 'fixed' (fixed-effect parameters), 'ran_pars' (variances and covariances or standard deviations and correlations of random effect terms) or 'ran_modes' (conditional modes/BLUPs/latent variable estimates)</p> </td> </tr> <tr valign='top'> <td><code>scales</code></td> <td> <p>scales on which to report the variables: for random effects, the choices are ‘'sdcor'’ (standard deviations and correlations: the default if <code>scales</code> is <code>NULL</code>) or ‘'vcov'’ (variances and covariances). <code>NA</code> means no transformation, appropriate e.g. for fixed effects; inverse-link transformations (exponentiation or logistic) are not yet implemented, but may be in the future.</p> </td> </tr> <tr valign='top'> <td><code>ran_prefix</code></td> <td> <p>a length-2 character vector specifying the strings to use as prefixes for self- (variance/standard deviation) and cross- (covariance/correlation) random effects terms</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>conf.method</code></td> <td> <p>method for computing confidence intervals (see <code>lme4::confint.merMod</code>)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data to be used for prediction; optional</p> </td> </tr> </table> "	FALSE
"lmodel2_tidiers"	"broom"	"Tidiers for linear model II objects from the lmodel2 package"	"<p>Tidy or glance an lmodel2 object. An lmodel2 represents model II simple linear regression, where both variables in the regression equation are random. </p>"	"<pre>## S3 method for class 'lmodel2' tidy(x, ...)<br />## S3 method for class 'lmodel2' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>lmodel2 object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table> "	FALSE
"lm_tidiers"	"broom"	"Tidying methods for a linear model"	"<p>These methods tidy the coefficients of a linear model into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'lm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'summary.lm' tidy(x, ...)<br />## S3 method for class 'lm' augment(x, data = stats::model.frame(x), newdata, type.predict,<br />   type.residuals, ...)<br />## S3 method for class 'lm' glance(x, ...)<br />## S3 method for class 'summary.lm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>lm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to the extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, performs predictions on the new data</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>Type of prediction to compute for a GLM; passed on to <code>predict.glm</code></p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>Type of residuals to compute for a GLM; passed on to <code>residuals.glm</code></p> </td> </tr> </table> "	FALSE
"loess_tidiers"	"broom"	"Augmenting methods for loess models"	"<p>This method augments the original data with information on the fitted values and residuals, and optionally the  standard errors. </p>"	"<pre>## S3 method for class 'loess' augment(x, data = stats::model.frame(x), newdata, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'loess' object</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to the extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, performs predictions on the new data</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments</p> </td> </tr> </table> "	FALSE
"matrix_tidiers"	"broom"	"Tidiers for matrix objects"	"<p>These perform tidying operations on matrix objects. <code>tidy</code> turns the matrix into a data.frame while bringing rownames, if they exist, in as a column called <code>.rownames</code> (since results of tidying operations never contain rownames). <code>glance</code> simply reports the number of rows and columns. Note that no augment method exists for matrices. </p>"	"<pre>## S3 method for class 'matrix' tidy(x, ...)<br />## S3 method for class 'matrix' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A matrix</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"mclust_tidiers"	"broom"	"Tidying methods for Mclust objects"	"<p>These methods summarize the results of Mclust clustering into three tidy forms. <code>tidy</code> describes the size, mixing probability, mean and variabilty of each class, <code>augment</code> adds the class assignments and their probabilities to the original data, and <code>glance</code> summarizes the model parameters of the clustering. </p>"	"<pre>## S3 method for class 'Mclust' tidy(x, ...)<br />## S3 method for class 'Mclust' augment(x, data, ...)<br />## S3 method for class 'Mclust' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Mclust object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data (required for <code>augment</code>)</p> </td> </tr> </table> "	FALSE
"mcmc_tidiers"	"broom"	"Tidying methods for MCMC (Stan, JAGS, etc.) fits"	"<p>Tidying methods for MCMC (Stan, JAGS, etc.) fits </p>"	"<pre>tidyMCMC(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', droppars = 'lp__',<br />   rhat = FALSE, ess = FALSE, ...)<br />## S3 method for class 'rjags' tidy(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', ...)<br />## S3 method for class 'stanfit' tidy(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', droppars = 'lp__',<br />   rhat = FALSE, ess = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class ‘'stanfit'’</p> </td> </tr> <tr valign='top'> <td><code>pars</code></td> <td> <p>(character) specification of which parameters to include</p> </td> </tr> <tr valign='top'> <td><code>estimate.method</code></td> <td> <p>method for computing point estimate ('mean' or median')</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>(logical) include confidence interval?</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>probability level for CI</p> </td> </tr> <tr valign='top'> <td><code>conf.method</code></td> <td> <p>method for computing confidence intervals ('quantile' or 'HPDinterval')</p> </td> </tr> <tr valign='top'> <td><code>droppars</code></td> <td> <p>Parameters not to include in the output (such as log-probability information)</p> </td> </tr> <tr valign='top'> <td><code>rhat, ess</code></td> <td> <p>(logical) include Rhat and/or effective sample size estimates?</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>unused</p> </td> </tr> </table> "	FALSE
"mle2_tidiers"	"broom"	"Tidy mle2 maximum likelihood objects"	"<p>Tidy mle2 objects from the bbmle package. </p>"	"<pre>## S3 method for class 'mle2' tidy(x, conf.int = FALSE, conf.level = 0.95, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An 'mle2' object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>Whether to add <code>conf.low</code> and <code>conf.high</code> columns</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>Confidence level to use for interval</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table> "	FALSE
"multcomp_tidiers"	"broom"	"tidying methods for objects produced by multcomp"	"<p>These methods originated in ggplot2, as 'fortify.' In broom, they were renamed 'tidy' because they summarize terms and tests, rather than adding columns to a dataset. </p>"	"<pre>## S3 method for class 'glht' tidy(x, ...)<br />## S3 method for class 'confint.glht' tidy(x, ...)<br />## S3 method for class 'summary.glht' tidy(x, ...)<br />## S3 method for class 'cld' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class <code>glht</code>, <code>confint.glht</code>, <code>summary.glht</code> or <code>cld</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"multinom_tidiers"	"broom"	"Tidying methods for multinomial logistic regression models"	"<p>These methods tidy the coefficients of multinomial logistic regression  models generated by <code>multinom</code> of the <code>nnet</code> package. </p>"	"<pre>## S3 method for class 'multinom' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = TRUE, ...)<br />## S3 method for class 'multinom' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A model object of class <code>multinom</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for multinomial logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"nlme_tidiers"	"broom"	"Tidying methods for mixed effects models"	"<p>These methods tidy the coefficients of mixed effects models of the <code>lme</code> class from functions  of the <code>nlme</code> package. </p>"	"<pre>## S3 method for class 'lme' tidy(x, effects = 'random', ...)<br />## S3 method for class 'lme' augment(x, data = x$data, newdata, ...)<br />## S3 method for class 'lme' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>lme</code>, such as those from <code>lme</code> or <code>nlme</code></p> </td> </tr> <tr valign='top'> <td><code>effects</code></td> <td> <p>Either 'random' (default) or 'fixed'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data to be used for prediction; optional</p> </td> </tr> </table> "	FALSE
"nls_tidiers"	"broom"	"Tidying methods for a nonlinear model"	"<p>These methods tidy the coefficients of a nonlinear model into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'nls' tidy(x, conf.int = FALSE, conf.level = 0.95, quick = FALSE,<br />   ...)<br />## S3 method for class 'nls' augment(x, data = NULL, newdata = NULL, ...)<br />## S3 method for class 'nls' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'nls'</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed from nls (may not be successful)</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data frame to use for predictions</p> </td> </tr> </table> "	FALSE
"optim_tidiers"	"broom"	"Tidiers for lists returned from optim"	"<p>Tidies objects returned by the <code>optim</code> function for general-purpose minimization and maximization. </p>"	"<pre>tidy_optim(x, ...)<br />glance_optim(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>list returned from <code>optim</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments</p> </td> </tr> </table> "	FALSE
"orcutt_tidiers"	"broom"	"Tidiers for Cochrane Orcutt object"	"<p>Tidies a Cochrane Orcutt object, which estimates autocorrelation and beta coefficients. This function is not exported and would not typically be called directly: it is dispatched by <code>tidy.list</code> and <code>glance.list</code>. </p>"	"<pre>tidy_orcutt(x, ...)<br />glance_orcutt(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list returned by <code>cochrane.orcutt</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments passed on to <code>tidy.summary.lm</code></p> </td> </tr> </table> "	FALSE
"plm_tidiers"	"broom"	"Tidiers for panel regression linear models"	"<p>Tidiers for panel regression linear models </p>"	"<pre>## S3 method for class 'plm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, ...)<br />## S3 method for class 'plm' augment(x, data = as.data.frame(stats::model.frame(x)), ...)<br />## S3 method for class 'plm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'plm' object representing a panel object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original dataset</p> </td> </tr> </table> "	FALSE
"poLCA_tidiers"	"broom"	"Tidiers for poLCA objects"	"<p>Tidiers for poLCA latent class regression models. Summarize the probabilities of each outcome for each variable within each class with <code>tidy</code>, add predictions to the data with <code>augment</code>, or find the log-likelihood/AIC/BIC with <code>glance</code>. </p>"	"<pre>## S3 method for class 'poLCA' tidy(x, ...)<br />## S3 method for class 'poLCA' augment(x, data, ...)<br />## S3 method for class 'poLCA' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A poLCA object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>For <code>augment</code>, the original dataset used to fit the latent class model. If not given, uses manifest variables in <code>x$y</code> and, if applicable, covariates in <code>x$x</code></p> </td> </tr> </table> "	FALSE
"prcomp_tidiers"	"broom"	"Tidying methods for principal components analysis via prcomp"	"<p>These tidiers operate on the results of a principal components analysis computed using <code>prcomp</code>. The <code>tidy</code> method returns a data frame with either the eigenvectors representing each row or each column. </p>"	"<pre>## S3 method for class 'prcomp' tidy(x, matrix = 'u', ...)<br />## S3 method for class 'prcomp' augment(x, data = NULL, newdata, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class <code>'prcomp'</code> resulting from a call to <code>prcomp</code></p> </td> </tr> <tr valign='top'> <td><code>matrix</code></td> <td> <p>character; Indicates which sets of eigenvectors are returned in tidy form. 'v', 'rotation', or 'variables' will return information about each variable, while 'u', 'x', or 'samples' (default) returns the loadings for each original row. 'd' or 'pcs' returns information about each principal component.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>the original data on which principal components analysis was performed. This cannot be recovered from <code>x</code>. If <code>newdata</code> is supplied, <code>data</code> is ignored. If both <code>data</code> and <code>newdata</code> are missing, only the fitted locations on the principal components are returned.</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>data frame; new observations for which locations on principal components are sought.</p> </td> </tr> </table> "	FALSE
"process_ergm"	"broom"	"helper function to process a tidied ergm object"	"<p>Optionally exponentiates the coefficients, and optionally adds a confidence interval, to a tidied ergm object. </p>"	"<pre>process_ergm(ret, x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>ret</code></td> <td> <p>data frame with a tidied version of a coefficient matrix</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an 'ergm' object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> </table>"	FALSE
"process_geeglm"	"broom"	"helper function to process a tidied geeglm object"	"<p>Adds a confidence interval, and possibly exponentiates, a tidied object. </p>"	"<pre>process_geeglm(ret, x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>ret</code></td> <td> <p>data frame with a tidied version of a coefficient matrix</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'geeglm' object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for log distributions)</p> </td> </tr> </table>"	FALSE
"process_lm"	"broom"	"helper function to process a tidied lm object"	"<p>Adds a confidence interval, and possibly exponentiates, a tidied object. Useful for operations shared between lm and biglm. </p>"	"<pre>process_lm(ret, x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>ret</code></td> <td> <p>data frame with a tidied version of a coefficient matrix</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an 'lm', 'glm', 'biglm', or 'bigglm' object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> </table>"	FALSE
"process_rq"	"broom"	"Helper function for tidy.rq and tidy.rqs"	"<p>See documentation for <code>summary.rq</code> for complete description of the options for <code>se.type</code>, <code>conf.int</code>, etc. </p>"	"<pre>process_rq(rq_obj, se.type = 'rank', conf.int = TRUE, conf.level = 0.95,<br />   ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>rq_obj</code></td> <td> <p>an object returned by <code>summary.rq</code> or <code>summary.rqs</code></p> </td> </tr> <tr valign='top'> <td><code>se.type</code></td> <td> <p>type of standard errors used in <code>summary.rq</code> or <code>summary.rqs</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for confidence interval</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>currently unused</p> </td> </tr> </table>"	FALSE
"pyears_tidiers"	"broom"	"Tidy person-year summaries"	"<p>These tidy the output of <code>pyears</code>, a calculation of the person-years of follow-up time contributed by a cohort of subject. Since the output of <code>pyears$data</code> is already tidy (if the <code>data.frame = TRUE</code> argument is given), this does only a little work and should rarely be necessary. </p>"	"<pre>## S3 method for class 'pyears' tidy(x, ...)<br />## S3 method for class 'pyears' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'pyears' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"rcorr_tidiers"	"broom"	"Tidying methods for rcorr objects"	"<p>Tidies a correlation matrix from the <code>rcorr</code> function in the 'Hmisc' package, including correlation estimates, p-values, and the number of observations in each pairwise correlation. Note that it returns these in 'long', or 'melted', format, with one row for each pair of columns being compared. </p>"	"<pre>## S3 method for class 'rcorr' tidy(x, diagonal = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'rcorr'</p> </td> </tr> <tr valign='top'> <td><code>diagonal</code></td> <td> <p>Whether to include diagonal elements (where <code>estimate</code> is 1 and <code>p.value</code> is NA), default FALSE</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"ridgelm_tidiers"	"broom"	"Tidying methods for ridgelm objects from the MASS package"	"<p>These methods tidies the coefficients of a ridge regression model chosen at each value of lambda into a data frame, or constructs a one-row glance of the model's choices of lambda (the ridge constant) </p>"	"<pre>## S3 method for class 'ridgelm' tidy(x, ...)<br />## S3 method for class 'ridgelm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'ridgelm'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"rlm_tidiers"	"broom"	"Tidying methods for an rlm (robust linear model) object"	"<p>This method provides a glance of an 'rlm' object. The <code>tidy</code> and <code>augment</code> methods are handled by lm_tidiers. </p>"	"<pre>## S3 method for class 'rlm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>rlm object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"rowwise_df_tidiers"	"broom"	"Tidying methods for rowwise_dfs from dplyr, for tidying each row andrecombining the results"	"<p>These <code>tidy</code>, <code>augment</code> and <code>glance</code> methods are for performing tidying on each row of a rowwise data frame created by dplyr's <code>group_by</code> and <code>do</code> operations. They first group a rowwise data frame based on all columns that are not lists, then perform the tidying operation on the specified column. This greatly shortens a common idiom of extracting tidy/augment/glance outputs after a do statement. </p>"	"<pre>## S3 method for class 'rowwise_df' tidy(x, object, ...)<br />## S3 method for class 'rowwise_df' tidy_(x, object, ...)<br />## S3 method for class 'rowwise_df' augment(x, object, ...)<br />## S3 method for class 'rowwise_df' augment_(x, object, ...)<br />## S3 method for class 'rowwise_df' glance(x, object, ...)<br />## S3 method for class 'rowwise_df' glance_(x, object, ...)<br />## S3 method for class 'tbl_df' tidy(x, ...)<br />## S3 method for class 'tbl_df' augment(x, ...)<br />## S3 method for class 'tbl_df' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a rowwise_df</p> </td> </tr> <tr valign='top'> <td><code>object</code></td> <td> <p>the column name of the column containing the models to be tidied. For tidy, augment, and glance it should be the bare name; for _ methods it should be quoted.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass on to the respective tidying method</p> </td> </tr> </table> "	FALSE
"rq_tidiers"	"broom"	"Tidying methods for quantile regression models"	"<p>These methods tidy the coefficients of a quantile regression model into a summary, augment the original data with information on the fitted values and residuals, and construct a glance of the model's statistics. </p>"	"<pre>## S3 method for class 'rq' tidy(x, se.type = 'rank', conf.int = TRUE, conf.level = 0.95,<br />   alpha = 1 - conf.level, ...)<br />## S3 method for class 'rqs' tidy(x, se.type = 'rank', conf.int = TRUE,<br />   conf.level = 0.95, alpha = 1 - conf.level, ...)<br />## S3 method for class 'nlrq' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'rq' glance(x, ...)<br />## S3 method for class 'nlrq' glance(x, ...)<br />## S3 method for class 'rq' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'rqs' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'nlrq' augment(x, data = NULL, newdata = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>model object returned by <code>rq</code> or <code>nlrq</code></p> </td> </tr> <tr valign='top'> <td><code>se.type</code></td> <td> <p>Type of standard errors to calculate; see <code>summary.rq</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>boolean; should confidence intervals be calculated, ignored if <code>se.type = 'rank'</code></p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for intervals</p> </td> </tr> <tr valign='top'> <td><code>alpha</code></td> <td> <p>confidence level when <code>se.type = 'rank'</code>; defaults to the same as <code>conf.level</code> although the specification is inverted</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, new data frame to use for predictions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>summary.rq</code></p> </td> </tr> </table> "	FALSE
"rstanarm_tidiers"	"broom"	"Tidying methods for an rstanarm model"	"<p>These methods tidy the estimates from <code>stanreg-objects</code> (fitted model objects from the <span class='pkg'>rstanarm</span> package) into a summary. </p>"	"<pre>## S3 method for class 'stanreg' tidy(x, parameters = c('non-varying', 'varying',<br />   'hierarchical'), intervals = FALSE, prob = 0.9, ...)<br />## S3 method for class 'stanreg' glance(x, looic = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Fitted model object from the <span class='pkg'>rstanarm</span> package. See  <code>stanreg-objects</code>.</p> </td> </tr> <tr valign='top'> <td><code>parameters</code></td> <td> <p>One of <code>'non-varying'</code>, <code>'varying'</code>, or  <code>'hierarchical'</code> (can be abbreviated). See the Value section for  details.</p> </td> </tr> <tr valign='top'> <td><code>intervals</code></td> <td> <p>If <code>TRUE</code> columns for the lower and upper bounds of the <code>100*prob</code>% posterior uncertainty intervals are included. See  <code>posterior_interval</code> for details.</p> </td> </tr> <tr valign='top'> <td><code>prob</code></td> <td> <p>See <code>posterior_interval</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>For <code>glance</code>, if <code>looic=TRUE</code>, optional arguments to <code>loo.stanreg</code>.</p> </td> </tr> <tr valign='top'> <td><code>looic</code></td> <td> <p>Should the LOO Information Criterion be included? See  <code>loo.stanreg</code> for details. Note: for models fit to very large data this can be a slow computation.</p> </td> </tr> </table> "	FALSE
"sexpfit_tidiers"	"broom"	"Tidy an expected survival curve"	"<p>This constructs a summary across time points or overall of an expected survival curve. Note that this contains less information than most survfit objects. </p>"	"<pre>## S3 method for class 'survexp' tidy(x, ...)<br />## S3 method for class 'survexp' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>'survexp' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"smooth.spline_tidiers"	"broom"	"tidying methods for smooth.spline objects"	"<p>This combines the original data given to smooth.spline with the fit and residuals </p>"	"<pre>## S3 method for class 'smooth.spline' augment(x, data = x$data, ...)<br />## S3 method for class 'smooth.spline' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a smooth.spline object</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>defaults to data used to fit model</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used in this method</p> </td> </tr> </table> "	FALSE
"sparse_tidiers"	"broom"	"Tidy a sparseMatrix object from the Matrix package"	"<p>Tidy a sparseMatrix object from the Matrix package into a three-column data frame, row, column, and value (with zeros missing). If there are row names or column names, use those, otherwise use indices </p>"	"<pre>## S3 method for class 'dgTMatrix' tidy(x, ...)<br />## S3 method for class 'dgCMatrix' tidy(x, ...)<br />## S3 method for class 'sparseMatrix' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A Matrix object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table>"	FALSE
"sp_tidiers"	"broom"	"tidying methods for classes from the sp package."	"<p>Tidy classes from the sp package to allow them to be plotted using ggplot2. To figure out the correct variable name for region, inspect <code>as.data.frame(x)</code>. </p>"	"<pre>## S3 method for class 'SpatialPolygonsDataFrame' tidy(x, region = NULL, ...)<br />## S3 method for class 'SpatialPolygons' tidy(x, ...)<br />## S3 method for class 'Polygons' tidy(x, ...)<br />## S3 method for class 'Polygon' tidy(x, ...)<br />## S3 method for class 'SpatialLinesDataFrame' tidy(x, ...)<br />## S3 method for class 'Lines' tidy(x, ...)<br />## S3 method for class 'Line' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p><code>SpatialPolygonsDataFrame</code> to convert into a dataframe.</p> </td> </tr> <tr valign='top'> <td><code>region</code></td> <td> <p>name of variable used to split up regions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used by this method</p> </td> </tr> </table> "	FALSE
"summary_tidiers"	"broom"	"Tidiers for summaryDefault objects"	"<p>Tidy a summary of a vector. </p>"	"<pre>## S3 method for class 'summaryDefault' tidy(x, ...)<br />## S3 method for class 'summaryDefault' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>summaryDefault object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"survfit_tidiers"	"broom"	"tidy survival curve fits"	"<p>Construct tidied data frames showing survival curves over time. </p>"	"<pre>## S3 method for class 'survfit' tidy(x, ...)<br />## S3 method for class 'survfit' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>'survfit' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"survreg_tidiers"	"broom"	"Tidiers for a parametric regression survival model"	"<p>Tidies the coefficients of a parametric survival regression model, from the 'survreg' function, adds fitted values and residuals, or summarizes the model statistics. </p>"	"<pre>## S3 method for class 'survreg' tidy(x, conf.level = 0.95, ...)<br />## S3 method for class 'survreg' augment(x, data = stats::model.frame(x), newdata,<br />   type.predict = 'response', type.residuals = 'response', ...)<br />## S3 method for class 'survreg' glance(x, conf.level = 0.95, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'survreg' model</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data; if it is not provided, it is reconstructed as best as possible with <code>model.frame</code></p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>New data to use for prediction; optional</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>type of prediction, default 'response'</p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>type of residuals to calculate, default 'response'</p> </td> </tr> </table> "	FALSE
"svd_tidiers"	"broom"	"Tidying methods for singular value decomposition"	"<p>These methods tidy the U, D, and V matrices returned by the <code>svd</code> function into a tidy format. Because <code>svd</code> returns a list without a class, this function has to be called by <code>tidy.list</code> when it recognizes a list as an SVD object. </p>"	"<pre>tidy_svd(x, matrix = 'u', ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>list containing d, u, v components, returned from <code>svd</code></p> </td> </tr> <tr valign='top'> <td><code>matrix</code></td> <td> <p>which of the u, d or v matrix to tidy</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"tidy"	"broom"	"Tidy the result of a test into a summary data.frame"	"<p>The output of tidy is always a data.frame with disposable row names. It is therefore suited for further manipulation by packages like dplyr, reshape2, ggplot2 and ggvis. </p>"	"<pre>tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object to be converted into a tidy data.frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments</p> </td> </tr> </table> "	FALSE
"aareg_tidiers"	"broom"	"Tidiers for aareg objects"	"<p>These tidy the coefficients of Aalen additive regression objects. </p>"	"<pre>## S3 method for class 'aareg' tidy(x, ...)<br />## S3 method for class 'aareg' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an 'aareg' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"acf_tidiers"	"broom"	"Tidying method for the acf function"	"<p>Tidy an 'acf' object, which is the output of <code>acf</code> and the related <code>pcf</code> and <code>ccf</code> functions. </p>"	"<pre>## S3 method for class 'acf' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>acf object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>(not used)</p> </td> </tr> </table> "	FALSE
"anova_tidiers"	"broom"	"Tidying methods for anova and AOV objects"	"<p>Tidies the result of an analysis of variance into an ANOVA table. Only a <code>tidy</code> method is provided, not an <code>augment</code> or <code>glance</code> method. </p>"	"<pre>## S3 method for class 'anova' tidy(x, ...)<br />## S3 method for class 'aov' tidy(x, ...)<br />## S3 method for class 'aovlist' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'anova', 'aov', or 'aovlist'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"anova_tidiers"	"broom"	"Tidying methods for anova and AOV objects"	"<p>Tidies the result of an analysis of variance into an ANOVA table. Only a <code>tidy</code> method is provided, not an <code>augment</code> or <code>glance</code> method. </p>"	"<pre>## S3 method for class 'anova' tidy(x, ...)<br />## S3 method for class 'aov' tidy(x, ...)<br />## S3 method for class 'aovlist' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'anova', 'aov', or 'aovlist'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"anova_tidiers"	"broom"	"Tidying methods for anova and AOV objects"	"<p>Tidies the result of an analysis of variance into an ANOVA table. Only a <code>tidy</code> method is provided, not an <code>augment</code> or <code>glance</code> method. </p>"	"<pre>## S3 method for class 'anova' tidy(x, ...)<br />## S3 method for class 'aov' tidy(x, ...)<br />## S3 method for class 'aovlist' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'anova', 'aov', or 'aovlist'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"Arima_tidiers"	"broom"	"Tidying methods for ARIMA modeling of time series"	"<p>These methods tidy the coefficients of ARIMA models of univariate time series. </p>"	"<pre>## S3 method for class 'Arima' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'Arima' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'Arima'</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"biglm_tidiers"	"broom"	"Tidiers for biglm and bigglm object"	"<p>Tidiers for biglm object from the 'biglm' package, which contains a linear model object that is limited in memory usage. Generally the behavior is as similar to the <code>lm_tidiers</code> as is possible. Currently no <code>augment</code> is defined. </p>"	"<pre>## S3 method for class 'biglm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'biglm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'biglm' object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"binDesign_tidiers"	"broom"	"Tidy a binDesign object"	"<p>Tidy a binDesign object from the 'binGroup' package, which determines the sample size needed for a particular power. </p>"	"<pre>## S3 method for class 'binDesign' tidy(x, ...)<br />## S3 method for class 'binDesign' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'binDesign' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"binWidth_tidiers"	"broom"	"Tidy a binWidth object"	"<p>Tidy a binWidth object from the 'binGroup' package, which calculates the expected width of a confidence interval from a binomial test. </p>"	"<pre>## S3 method for class 'binWidth' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'binWidth' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"boot_tidiers"	"broom"	"Tidying methods for bootstrap computations"	"<p>Tidying methods for 'boot' objects from the 'boot' package. </p>"	"<pre>## S3 method for class 'boot' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   conf.method = 'perc', ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p><code>boot</code> object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>conf.method</code></td> <td> <p>method for computing confidence intervals (see <code>boot.ci</code>)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"btergm_tidiers"	"broom"	"Tidying method for a bootstrapped temporal exponential random graph model"	"<p>This method tidies the coefficients of a bootstrapped temporal exponential  random graph model estimated with the <span class='pkg'>xergm</span>. It simply returns the coefficients and their confidence intervals. </p>"	"<pre>## S3 method for class 'btergm' tidy(x, conf.level = 0.95, exponentiate = FALSE,<br />   quick = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a <code>btergm</code> object</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the bootstrapped interval</p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (currently not used)</p> </td> </tr> </table> "	FALSE
"cch_tidiers"	"broom"	"tidiers for case-cohort data"	"<p>Tidiers for case-cohort analyses: summarize each estimated coefficient, or test the overall model. </p>"	"<pre>## S3 method for class 'cch' tidy(x, conf.level = 0.95, ...)<br />## S3 method for class 'cch' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'cch' object</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"vector_tidiers"	"broom"	"Tidy atomic vectors"	"<p>Turn atomic vectors into data frames, where the names of the vector (if they exist) are a column and the values of the vector are a column. </p>"	"<pre>## S3 method for class 'numeric' tidy(x, ...)<br />## S3 method for class 'character' tidy(x, ...)<br />## S3 method for class 'logical' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'numeric', 'integer', 'character', or 'logical'. Most likely a named vector</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"multcomp_tidiers"	"broom"	"tidying methods for objects produced by multcomp"	"<p>These methods originated in ggplot2, as 'fortify.' In broom, they were renamed 'tidy' because they summarize terms and tests, rather than adding columns to a dataset. </p>"	"<pre>## S3 method for class 'glht' tidy(x, ...)<br />## S3 method for class 'confint.glht' tidy(x, ...)<br />## S3 method for class 'summary.glht' tidy(x, ...)<br />## S3 method for class 'cld' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class <code>glht</code>, <code>confint.glht</code>, <code>summary.glht</code> or <code>cld</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"tidy.coeftest"	"broom"	"Tidying methods for coeftest objects"	"<p>This tidies the result of a coefficient test, from the <code>coeftest</code> function in the <code>lmtest</code> package. </p>"	"<pre>## S3 method for class 'coeftest' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>coeftest object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"multcomp_tidiers"	"broom"	"tidying methods for objects produced by multcomp"	"<p>These methods originated in ggplot2, as 'fortify.' In broom, they were renamed 'tidy' because they summarize terms and tests, rather than adding columns to a dataset. </p>"	"<pre>## S3 method for class 'glht' tidy(x, ...)<br />## S3 method for class 'confint.glht' tidy(x, ...)<br />## S3 method for class 'summary.glht' tidy(x, ...)<br />## S3 method for class 'cld' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class <code>glht</code>, <code>confint.glht</code>, <code>summary.glht</code> or <code>cld</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"coxph_tidiers"	"broom"	"Tidiers for coxph object"	"<p>Tidy the coefficients of a Cox proportional hazards regression model, construct predictions, or summarize the entire model into a single row. </p>"	"<pre>## S3 method for class 'coxph' tidy(x, exponentiate = FALSE, conf.int = 0.95, ...)<br />## S3 method for class 'coxph' augment(x, data = stats::model.frame(x), newdata,<br />   type.predict = 'lp', type.residuals = 'martingale', ...)<br />## S3 method for class 'coxph' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>'coxph' object</p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to report the estimate and confidence intervals on an exponential scale</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>confidence level to be used for CI</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data for <code>augment</code></p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data on which to do predictions</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>type of predicted value (see <code>predict.coxph</code>)</p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>type of residuals (see <code>residuals.coxph</code>)</p> </td> </tr> </table> "	FALSE
"cv.glmnet_tidiers"	"broom"	"Tidiers for glmnet cross-validation objects"	"<p>Tidying methods for cross-validation performed by <code>glmnet.cv</code>, summarizing the mean-squared-error across choices of the penalty parameter lambda. </p>"	"<pre>## S3 method for class 'cv.glmnet' tidy(x, ...)<br />## S3 method for class 'cv.glmnet' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'cv.glmnet' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"data.frame_tidiers"	"broom"	"Tidiers for data.frame objects"	"<p>These perform tidy summaries of data.frame objects. <code>tidy</code> produces summary statistics about each column, while <code>glance</code> simply reports the number of rows and columns. Note that <code>augment.data.frame</code> will throw an error. </p>"	"<pre>## S3 method for class 'data.frame' tidy(x, ...)<br />## S3 method for class 'data.frame' augment(x, data, ...)<br />## S3 method for class 'data.frame' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data.frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments: for <code>tidy</code>, these are passed on to <code>describe</code> from <code>psych</code> package</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>data, not used</p> </td> </tr> </table> "	FALSE
"tidy.default"	"broom"	"Default tidying method"	"<p>By default, tidy uses <code>as.data.frame</code> to convert its output. This is  dangerous, as it may fail with an uninformative error message. Generally tidy is intended to be used on structured model objects such as lm or htest for which a specific S3 object exists. </p>"	"<pre>## Default S3 method: tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object to be tidied</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"tidy.density"	"broom"	"tidy a density objet"	"<p>Given a 'density' object, returns a tidy data frame with two columns: points x where the density is estimated, points y for the estimate </p>"	"<pre>## S3 method for class 'density' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class 'density'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"sparse_tidiers"	"broom"	"Tidy a sparseMatrix object from the Matrix package"	"<p>Tidy a sparseMatrix object from the Matrix package into a three-column data frame, row, column, and value (with zeros missing). If there are row names or column names, use those, otherwise use indices </p>"	"<pre>## S3 method for class 'dgTMatrix' tidy(x, ...)<br />## S3 method for class 'dgCMatrix' tidy(x, ...)<br />## S3 method for class 'sparseMatrix' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A Matrix object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table>"	FALSE
"sparse_tidiers"	"broom"	"Tidy a sparseMatrix object from the Matrix package"	"<p>Tidy a sparseMatrix object from the Matrix package into a three-column data frame, row, column, and value (with zeros missing). If there are row names or column names, use those, otherwise use indices </p>"	"<pre>## S3 method for class 'dgTMatrix' tidy(x, ...)<br />## S3 method for class 'dgCMatrix' tidy(x, ...)<br />## S3 method for class 'sparseMatrix' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A Matrix object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table>"	FALSE
"tidy.dist"	"broom"	"Tidy a distance matrix"	"<p>Tidy a distance matrix, such as that computed by the dist function, into a one-row-per-pair table. If the distance matrix does not include an upper triangle and/or diagonal, this will not either. </p>"	"<pre>## S3 method for class 'dist' tidy(x, diag = attr(x, 'Diag'), upper = attr(x, 'Upper'),<br />   ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'dist' object</p> </td> </tr> <tr valign='top'> <td><code>diag</code></td> <td> <p>Whether to include the diagonal of the distance matrix. Defaults to whether the distance matrix includes it</p> </td> </tr> <tr valign='top'> <td><code>upper</code></td> <td> <p>Whether to include the upper right triangle of the distance matrix. Defaults to whether the distance matrix includes it</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table> "	FALSE
"ergm_tidiers"	"broom"	"Tidying methods for an exponential random graph model"	"<p>These methods tidy the coefficients of an exponential random graph model estimated with the <span class='pkg'>ergm</span> package into a summary, and construct a one-row glance of the model's statistics. The methods should work with any model that conforms to the <span class='pkg'>ergm</span> class, such as those produced from weighted networks by the <span class='pkg'>ergm.count</span> package. </p>"	"<pre>## S3 method for class 'ergm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'ergm' glance(x, deviance = FALSE, mcmc = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an <span class='pkg'>ergm</span> object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments passed to <code>summary.ergm</code></p> </td> </tr> <tr valign='top'> <td><code>deviance</code></td> <td> <p>whether to report null and residual deviance for the model, along with degrees of freedom; defaults to <code>FALSE</code></p> </td> </tr> <tr valign='top'> <td><code>mcmc</code></td> <td> <p>whether to report MCMC interval, burn-in and sample size used to estimate the model; defaults to <code>FALSE</code></p> </td> </tr> </table> "	FALSE
"felm_tidiers"	"broom"	"Tidying methods for models with multiple group fixed effects"	"<p>These methods tidy the coefficients of a linear model with multiple group fixed effects </p>"	"<pre>## S3 method for class 'felm' tidy(x, conf.int = FALSE, conf.level = 0.95, fe = FALSE,<br />   fe.error = fe, ...)<br />## S3 method for class 'felm' augment(x, data = NULL, ...)<br />## S3 method for class 'felm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>felm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>fe</code></td> <td> <p>whether to include estimates of fixed effects</p> </td> </tr> <tr valign='top'> <td><code>fe.error</code></td> <td> <p>whether to include standard error of fixed effects</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> </table> "	FALSE
"fitdistr_tidiers"	"broom"	"Tidying methods for fitdistr objects from the MASS package"	"<p>These methods tidies the parameter estimates resulting from an estimation of a univariate distribution's parameters. </p>"	"<pre>## S3 method for class 'fitdistr' tidy(x, ...)<br />## S3 method for class 'fitdistr' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'fitdistr'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"tidy.ftable"	"broom"	"tidy an ftable object"	"<p>An ftable contains a 'flat' contingency table. This melts it into a data.frame with one column for each variable, then a <code>Freq</code> column. It directly uses the <code>stats:::as.data.frame.ftable</code> function </p>"	"<pre>## S3 method for class 'ftable' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'ftable'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"gam_tidiers"	"broom"	"Tidying methods for a generalized additive model (gam)"	"<p>These methods tidy the coefficients of a 'gam' object (generalized additive model) into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'gam' tidy(x, ...)<br />## S3 method for class 'gam' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>gam object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"gamlss_tidiers"	"broom"	"Tidying methods for gamlss objects"	"<p>Tidying methods for 'gamlss' objects from the gamlss package. </p>"	"<pre>## S3 method for class 'gamlss' tidy(x, quick = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'gamlss' object</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>Whether to perform a fast version, and return only the coefficients</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"geeglm_tidiers"	"broom"	"Tidying methods for generalized estimating equations models"	"<p>These methods tidy the coefficients of generalized estimating equations models of the <code>geeglm</code> class from functions of the <code>geepack</code> package. </p>"	"<pre>## S3 method for class 'geeglm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>geeglm</code>, such as from <code>geeglm</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for log distributions)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments to be passed to other methods.  Currently not used.</p> </td> </tr> </table> "	FALSE
"multcomp_tidiers"	"broom"	"tidying methods for objects produced by multcomp"	"<p>These methods originated in ggplot2, as 'fortify.' In broom, they were renamed 'tidy' because they summarize terms and tests, rather than adding columns to a dataset. </p>"	"<pre>## S3 method for class 'glht' tidy(x, ...)<br />## S3 method for class 'confint.glht' tidy(x, ...)<br />## S3 method for class 'summary.glht' tidy(x, ...)<br />## S3 method for class 'cld' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class <code>glht</code>, <code>confint.glht</code>, <code>summary.glht</code> or <code>cld</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"glmnet_tidiers"	"broom"	"Tidiers for LASSO or elasticnet regularized fits"	"<p>Tidying methods for regularized fits produced by <code>glmnet</code>, summarizing the estimates across values of the penalty parameter lambda. </p>"	"<pre>## S3 method for class 'glmnet' tidy(x, ...)<br />## S3 method for class 'glmnet' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'glmnet' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"gmm_tidiers"	"broom"	"Tidying methods for generalized method of moments \"gmm\" objects"	"<p>These methods tidy the coefficients of 'gmm' objects from the gmm package, or glance at the model-wide statistics (especially the J-test). </p>"	"<pre>## S3 method for class 'gmm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'gmm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>gmm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns (and confidence interval if requested, which may be slower)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"htest_tidiers"	"broom"	"Tidying methods for an htest object"	"<p>Tidies hypothesis test objects, such as those from <code>cor.test</code>, <code>t.test</code>, and <code>wilcox.test</code>, into a one-row data frame. </p>"	"<pre>## S3 method for class 'htest' tidy(x, ...)<br />## S3 method for class 'htest' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>'htest'</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"kappa_tidiers"	"broom"	"Tidy a kappa object from a Cohen's kappa calculation"	"<p>Tidy a 'kappa' object, from the <code>cohen.kappa</code> function in the psych package. This represents the agreement of two raters when using nominal scores. </p>"	"<pre>## S3 method for class 'kappa' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'kappa'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"kde_tidiers"	"broom"	"Tidy a kernel density estimate object from the ks package"	"<p>Tidy a kernel density estimate object, into a table with one row for each point in the estimated grid, and one column for each dimension (along with an <code>estimate</code> column with the estimated density). </p>"	"<pre>## S3 method for class 'kde' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A 'ks' object from the kde package</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table> "	FALSE
"kmeans_tidiers"	"broom"	"Tidying methods for kmeans objects"	"<p>These methods summarize the results of k-means clustering into three tidy forms. <code>tidy</code> describes the center and size of each cluster, <code>augment</code> adds the cluster assignments to the original data, and <code>glance</code> summarizes the total within and between sum of squares of the clustering. </p>"	"<pre>## S3 method for class 'kmeans' tidy(x, col.names = paste0('x', 1:ncol(x$centers)), ...)<br />## S3 method for class 'kmeans' augment(x, data, ...)<br />## S3 method for class 'kmeans' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>kmeans object</p> </td> </tr> <tr valign='top'> <td><code>col.names</code></td> <td> <p>The names to call each dimension of the data in <code>tidy</code>. Defaults to <code>x1, x2...</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data (required for <code>augment</code>)</p> </td> </tr> </table> "	FALSE
"sp_tidiers"	"broom"	"tidying methods for classes from the sp package."	"<p>Tidy classes from the sp package to allow them to be plotted using ggplot2. To figure out the correct variable name for region, inspect <code>as.data.frame(x)</code>. </p>"	"<pre>## S3 method for class 'SpatialPolygonsDataFrame' tidy(x, region = NULL, ...)<br />## S3 method for class 'SpatialPolygons' tidy(x, ...)<br />## S3 method for class 'Polygons' tidy(x, ...)<br />## S3 method for class 'Polygon' tidy(x, ...)<br />## S3 method for class 'SpatialLinesDataFrame' tidy(x, ...)<br />## S3 method for class 'Lines' tidy(x, ...)<br />## S3 method for class 'Line' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p><code>SpatialPolygonsDataFrame</code> to convert into a dataframe.</p> </td> </tr> <tr valign='top'> <td><code>region</code></td> <td> <p>name of variable used to split up regions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used by this method</p> </td> </tr> </table> "	FALSE
"sp_tidiers"	"broom"	"tidying methods for classes from the sp package."	"<p>Tidy classes from the sp package to allow them to be plotted using ggplot2. To figure out the correct variable name for region, inspect <code>as.data.frame(x)</code>. </p>"	"<pre>## S3 method for class 'SpatialPolygonsDataFrame' tidy(x, region = NULL, ...)<br />## S3 method for class 'SpatialPolygons' tidy(x, ...)<br />## S3 method for class 'Polygons' tidy(x, ...)<br />## S3 method for class 'Polygon' tidy(x, ...)<br />## S3 method for class 'SpatialLinesDataFrame' tidy(x, ...)<br />## S3 method for class 'Lines' tidy(x, ...)<br />## S3 method for class 'Line' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p><code>SpatialPolygonsDataFrame</code> to convert into a dataframe.</p> </td> </tr> <tr valign='top'> <td><code>region</code></td> <td> <p>name of variable used to split up regions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used by this method</p> </td> </tr> </table> "	FALSE
"list_tidiers"	"broom"	"Tidiers for return values from functions that aren't S3 objects"	"<p>This method handles the return values of functions that return lists rather than S3 objects, such as <code>optim</code>, <code>svd</code>, or <code>interp</code>, and therefore cannot be handled by S3 dispatch. </p>"	"<pre>## S3 method for class 'list' tidy(x, ...)<br />## S3 method for class 'list' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>list object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, passed to the tidying function</p> </td> </tr> </table> "	FALSE
"lm_tidiers"	"broom"	"Tidying methods for a linear model"	"<p>These methods tidy the coefficients of a linear model into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'lm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'summary.lm' tidy(x, ...)<br />## S3 method for class 'lm' augment(x, data = stats::model.frame(x), newdata, type.predict,<br />   type.residuals, ...)<br />## S3 method for class 'lm' glance(x, ...)<br />## S3 method for class 'summary.lm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>lm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to the extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, performs predictions on the new data</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>Type of prediction to compute for a GLM; passed on to <code>predict.glm</code></p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>Type of residuals to compute for a GLM; passed on to <code>residuals.glm</code></p> </td> </tr> </table> "	FALSE
"nlme_tidiers"	"broom"	"Tidying methods for mixed effects models"	"<p>These methods tidy the coefficients of mixed effects models of the <code>lme</code> class from functions  of the <code>nlme</code> package. </p>"	"<pre>## S3 method for class 'lme' tidy(x, effects = 'random', ...)<br />## S3 method for class 'lme' augment(x, data = x$data, newdata, ...)<br />## S3 method for class 'lme' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>lme</code>, such as those from <code>lme</code> or <code>nlme</code></p> </td> </tr> <tr valign='top'> <td><code>effects</code></td> <td> <p>Either 'random' (default) or 'fixed'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data to be used for prediction; optional</p> </td> </tr> </table> "	FALSE
"lmodel2_tidiers"	"broom"	"Tidiers for linear model II objects from the lmodel2 package"	"<p>Tidy or glance an lmodel2 object. An lmodel2 represents model II simple linear regression, where both variables in the regression equation are random. </p>"	"<pre>## S3 method for class 'lmodel2' tidy(x, ...)<br />## S3 method for class 'lmodel2' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>lmodel2 object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table> "	FALSE
"vector_tidiers"	"broom"	"Tidy atomic vectors"	"<p>Turn atomic vectors into data frames, where the names of the vector (if they exist) are a column and the values of the vector are a column. </p>"	"<pre>## S3 method for class 'numeric' tidy(x, ...)<br />## S3 method for class 'character' tidy(x, ...)<br />## S3 method for class 'logical' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'numeric', 'integer', 'character', or 'logical'. Most likely a named vector</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"tidy.manova"	"broom"	"tidy a MANOVA object"	"<p>Constructs a data frame with one row for each of the terms in the model, containing the information from summary.manova. </p>"	"<pre>## S3 method for class 'manova' tidy(x, test = 'Pillai', ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>object of class 'manova'</p> </td> </tr> <tr valign='top'> <td><code>test</code></td> <td> <p>one of 'Pillai' (Pillai's trace), 'Wilks' (Wilk's lambda), 'Hotelling-Lawley' (Hotelling-Lawley trace) or 'Roy' (Roy's greatest root) indicating which test statistic should be used. Defaults to 'Pillai'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments passed on to <code>summary.manova</code></p> </td> </tr> </table> "	FALSE
"tidy.map"	"broom"	"Tidy method for map objects."	"<p>This function turns a map into a data frame. </p>"	"<pre>## S3 method for class 'map' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>map object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used by this method</p> </td> </tr> </table> "	FALSE
"matrix_tidiers"	"broom"	"Tidiers for matrix objects"	"<p>These perform tidying operations on matrix objects. <code>tidy</code> turns the matrix into a data.frame while bringing rownames, if they exist, in as a column called <code>.rownames</code> (since results of tidying operations never contain rownames). <code>glance</code> simply reports the number of rows and columns. Note that no augment method exists for matrices. </p>"	"<pre>## S3 method for class 'matrix' tidy(x, ...)<br />## S3 method for class 'matrix' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A matrix</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"mclust_tidiers"	"broom"	"Tidying methods for Mclust objects"	"<p>These methods summarize the results of Mclust clustering into three tidy forms. <code>tidy</code> describes the size, mixing probability, mean and variabilty of each class, <code>augment</code> adds the class assignments and their probabilities to the original data, and <code>glance</code> summarizes the model parameters of the clustering. </p>"	"<pre>## S3 method for class 'Mclust' tidy(x, ...)<br />## S3 method for class 'Mclust' augment(x, data, ...)<br />## S3 method for class 'Mclust' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Mclust object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data (required for <code>augment</code>)</p> </td> </tr> </table> "	FALSE
"lme4_tidiers"	"broom"	"Tidying methods for mixed effects models"	"<p>These methods tidy the coefficients of mixed effects models, particularly responses of the <code>merMod</code> class </p>"	"<pre>## S3 method for class 'merMod' tidy(x, effects = c('ran_pars', 'fixed'), scales = NULL,<br />   ran_prefix = NULL, conf.int = FALSE, conf.level = 0.95,<br />   conf.method = 'Wald', ...)<br />## S3 method for class 'merMod' augment(x, data = stats::model.frame(x), newdata, ...)<br />## S3 method for class 'merMod' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>merMod</code>, such as those from <code>lmer</code>, <code>glmer</code>, or <code>nlmer</code></p> </td> </tr> <tr valign='top'> <td><code>effects</code></td> <td> <p>A character vector including one or more of 'fixed' (fixed-effect parameters), 'ran_pars' (variances and covariances or standard deviations and correlations of random effect terms) or 'ran_modes' (conditional modes/BLUPs/latent variable estimates)</p> </td> </tr> <tr valign='top'> <td><code>scales</code></td> <td> <p>scales on which to report the variables: for random effects, the choices are ‘'sdcor'’ (standard deviations and correlations: the default if <code>scales</code> is <code>NULL</code>) or ‘'vcov'’ (variances and covariances). <code>NA</code> means no transformation, appropriate e.g. for fixed effects; inverse-link transformations (exponentiation or logistic) are not yet implemented, but may be in the future.</p> </td> </tr> <tr valign='top'> <td><code>ran_prefix</code></td> <td> <p>a length-2 character vector specifying the strings to use as prefixes for self- (variance/standard deviation) and cross- (covariance/correlation) random effects terms</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>conf.method</code></td> <td> <p>method for computing confidence intervals (see <code>lme4::confint.merMod</code>)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data to be used for prediction; optional</p> </td> </tr> </table> "	FALSE
"mle2_tidiers"	"broom"	"Tidy mle2 maximum likelihood objects"	"<p>Tidy mle2 objects from the bbmle package. </p>"	"<pre>## S3 method for class 'mle2' tidy(x, conf.int = FALSE, conf.level = 0.95, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An 'mle2' object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>Whether to add <code>conf.low</code> and <code>conf.high</code> columns</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>Confidence level to use for interval</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table> "	FALSE
"multinom_tidiers"	"broom"	"Tidying methods for multinomial logistic regression models"	"<p>These methods tidy the coefficients of multinomial logistic regression  models generated by <code>multinom</code> of the <code>nnet</code> package. </p>"	"<pre>## S3 method for class 'multinom' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = TRUE, ...)<br />## S3 method for class 'multinom' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A model object of class <code>multinom</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for multinomial logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"rq_tidiers"	"broom"	"Tidying methods for quantile regression models"	"<p>These methods tidy the coefficients of a quantile regression model into a summary, augment the original data with information on the fitted values and residuals, and construct a glance of the model's statistics. </p>"	"<pre>## S3 method for class 'rq' tidy(x, se.type = 'rank', conf.int = TRUE, conf.level = 0.95,<br />   alpha = 1 - conf.level, ...)<br />## S3 method for class 'rqs' tidy(x, se.type = 'rank', conf.int = TRUE,<br />   conf.level = 0.95, alpha = 1 - conf.level, ...)<br />## S3 method for class 'nlrq' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'rq' glance(x, ...)<br />## S3 method for class 'nlrq' glance(x, ...)<br />## S3 method for class 'rq' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'rqs' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'nlrq' augment(x, data = NULL, newdata = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>model object returned by <code>rq</code> or <code>nlrq</code></p> </td> </tr> <tr valign='top'> <td><code>se.type</code></td> <td> <p>Type of standard errors to calculate; see <code>summary.rq</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>boolean; should confidence intervals be calculated, ignored if <code>se.type = 'rank'</code></p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for intervals</p> </td> </tr> <tr valign='top'> <td><code>alpha</code></td> <td> <p>confidence level when <code>se.type = 'rank'</code>; defaults to the same as <code>conf.level</code> although the specification is inverted</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, new data frame to use for predictions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>summary.rq</code></p> </td> </tr> </table> "	FALSE
"nls_tidiers"	"broom"	"Tidying methods for a nonlinear model"	"<p>These methods tidy the coefficients of a nonlinear model into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'nls' tidy(x, conf.int = FALSE, conf.level = 0.95, quick = FALSE,<br />   ...)<br />## S3 method for class 'nls' augment(x, data = NULL, newdata = NULL, ...)<br />## S3 method for class 'nls' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'nls'</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data this was fitted on; if not given this will attempt to be reconstructed from nls (may not be successful)</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>new data frame to use for predictions</p> </td> </tr> </table> "	FALSE
"tidy.NULL"	"broom"	"tidy on a NULL input"	"<p>tidy on a NULL input returns an empty data frame, which means it can be combined with other data frames (treated as 'empty') </p>"	"<pre>## S3 method for class 'NULL' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A value NULL</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"vector_tidiers"	"broom"	"Tidy atomic vectors"	"<p>Turn atomic vectors into data frames, where the names of the vector (if they exist) are a column and the values of the vector are a column. </p>"	"<pre>## S3 method for class 'numeric' tidy(x, ...)<br />## S3 method for class 'character' tidy(x, ...)<br />## S3 method for class 'logical' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'numeric', 'integer', 'character', or 'logical'. Most likely a named vector</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"tidy.pairwise.htest"	"broom"	"tidy a pairwise hypothesis test"	"<p>Tidy a pairwise.htest object, containing (adjusted) p-values for multiple pairwise hypothesis tests. </p>"	"<pre>## S3 method for class 'pairwise.htest' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'pairwise.htest' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"plm_tidiers"	"broom"	"Tidiers for panel regression linear models"	"<p>Tidiers for panel regression linear models </p>"	"<pre>## S3 method for class 'plm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, ...)<br />## S3 method for class 'plm' augment(x, data = as.data.frame(stats::model.frame(x)), ...)<br />## S3 method for class 'plm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'plm' object representing a panel object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original dataset</p> </td> </tr> </table> "	FALSE
"poLCA_tidiers"	"broom"	"Tidiers for poLCA objects"	"<p>Tidiers for poLCA latent class regression models. Summarize the probabilities of each outcome for each variable within each class with <code>tidy</code>, add predictions to the data with <code>augment</code>, or find the log-likelihood/AIC/BIC with <code>glance</code>. </p>"	"<pre>## S3 method for class 'poLCA' tidy(x, ...)<br />## S3 method for class 'poLCA' augment(x, data, ...)<br />## S3 method for class 'poLCA' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A poLCA object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>For <code>augment</code>, the original dataset used to fit the latent class model. If not given, uses manifest variables in <code>x$y</code> and, if applicable, covariates in <code>x$x</code></p> </td> </tr> </table> "	FALSE
"sp_tidiers"	"broom"	"tidying methods for classes from the sp package."	"<p>Tidy classes from the sp package to allow them to be plotted using ggplot2. To figure out the correct variable name for region, inspect <code>as.data.frame(x)</code>. </p>"	"<pre>## S3 method for class 'SpatialPolygonsDataFrame' tidy(x, region = NULL, ...)<br />## S3 method for class 'SpatialPolygons' tidy(x, ...)<br />## S3 method for class 'Polygons' tidy(x, ...)<br />## S3 method for class 'Polygon' tidy(x, ...)<br />## S3 method for class 'SpatialLinesDataFrame' tidy(x, ...)<br />## S3 method for class 'Lines' tidy(x, ...)<br />## S3 method for class 'Line' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p><code>SpatialPolygonsDataFrame</code> to convert into a dataframe.</p> </td> </tr> <tr valign='top'> <td><code>region</code></td> <td> <p>name of variable used to split up regions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used by this method</p> </td> </tr> </table> "	FALSE
"sp_tidiers"	"broom"	"tidying methods for classes from the sp package."	"<p>Tidy classes from the sp package to allow them to be plotted using ggplot2. To figure out the correct variable name for region, inspect <code>as.data.frame(x)</code>. </p>"	"<pre>## S3 method for class 'SpatialPolygonsDataFrame' tidy(x, region = NULL, ...)<br />## S3 method for class 'SpatialPolygons' tidy(x, ...)<br />## S3 method for class 'Polygons' tidy(x, ...)<br />## S3 method for class 'Polygon' tidy(x, ...)<br />## S3 method for class 'SpatialLinesDataFrame' tidy(x, ...)<br />## S3 method for class 'Lines' tidy(x, ...)<br />## S3 method for class 'Line' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p><code>SpatialPolygonsDataFrame</code> to convert into a dataframe.</p> </td> </tr> <tr valign='top'> <td><code>region</code></td> <td> <p>name of variable used to split up regions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used by this method</p> </td> </tr> </table> "	FALSE
"tidy.power.htest"	"broom"	"tidy a power.htest"	"<p>tidy a power.htest </p>"	"<pre>## S3 method for class 'power.htest' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a power.htest object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"prcomp_tidiers"	"broom"	"Tidying methods for principal components analysis via prcomp"	"<p>These tidiers operate on the results of a principal components analysis computed using <code>prcomp</code>. The <code>tidy</code> method returns a data frame with either the eigenvectors representing each row or each column. </p>"	"<pre>## S3 method for class 'prcomp' tidy(x, matrix = 'u', ...)<br />## S3 method for class 'prcomp' augment(x, data = NULL, newdata, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class <code>'prcomp'</code> resulting from a call to <code>prcomp</code></p> </td> </tr> <tr valign='top'> <td><code>matrix</code></td> <td> <p>character; Indicates which sets of eigenvectors are returned in tidy form. 'v', 'rotation', or 'variables' will return information about each variable, while 'u', 'x', or 'samples' (default) returns the loadings for each original row. 'd' or 'pcs' returns information about each principal component.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>the original data on which principal components analysis was performed. This cannot be recovered from <code>x</code>. If <code>newdata</code> is supplied, <code>data</code> is ignored. If both <code>data</code> and <code>newdata</code> are missing, only the fitted locations on the principal components are returned.</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>data frame; new observations for which locations on principal components are sought.</p> </td> </tr> </table> "	FALSE
"pyears_tidiers"	"broom"	"Tidy person-year summaries"	"<p>These tidy the output of <code>pyears</code>, a calculation of the person-years of follow-up time contributed by a cohort of subject. Since the output of <code>pyears$data</code> is already tidy (if the <code>data.frame = TRUE</code> argument is given), this does only a little work and should rarely be necessary. </p>"	"<pre>## S3 method for class 'pyears' tidy(x, ...)<br />## S3 method for class 'pyears' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'pyears' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"rcorr_tidiers"	"broom"	"Tidying methods for rcorr objects"	"<p>Tidies a correlation matrix from the <code>rcorr</code> function in the 'Hmisc' package, including correlation estimates, p-values, and the number of observations in each pairwise correlation. Note that it returns these in 'long', or 'melted', format, with one row for each pair of columns being compared. </p>"	"<pre>## S3 method for class 'rcorr' tidy(x, diagonal = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'rcorr'</p> </td> </tr> <tr valign='top'> <td><code>diagonal</code></td> <td> <p>Whether to include diagonal elements (where <code>estimate</code> is 1 and <code>p.value</code> is NA), default FALSE</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"ridgelm_tidiers"	"broom"	"Tidying methods for ridgelm objects from the MASS package"	"<p>These methods tidies the coefficients of a ridge regression model chosen at each value of lambda into a data frame, or constructs a one-row glance of the model's choices of lambda (the ridge constant) </p>"	"<pre>## S3 method for class 'ridgelm' tidy(x, ...)<br />## S3 method for class 'ridgelm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'ridgelm'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"mcmc_tidiers"	"broom"	"Tidying methods for MCMC (Stan, JAGS, etc.) fits"	"<p>Tidying methods for MCMC (Stan, JAGS, etc.) fits </p>"	"<pre>tidyMCMC(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', droppars = 'lp__',<br />   rhat = FALSE, ess = FALSE, ...)<br />## S3 method for class 'rjags' tidy(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', ...)<br />## S3 method for class 'stanfit' tidy(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', droppars = 'lp__',<br />   rhat = FALSE, ess = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class ‘'stanfit'’</p> </td> </tr> <tr valign='top'> <td><code>pars</code></td> <td> <p>(character) specification of which parameters to include</p> </td> </tr> <tr valign='top'> <td><code>estimate.method</code></td> <td> <p>method for computing point estimate ('mean' or median')</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>(logical) include confidence interval?</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>probability level for CI</p> </td> </tr> <tr valign='top'> <td><code>conf.method</code></td> <td> <p>method for computing confidence intervals ('quantile' or 'HPDinterval')</p> </td> </tr> <tr valign='top'> <td><code>droppars</code></td> <td> <p>Parameters not to include in the output (such as log-probability information)</p> </td> </tr> <tr valign='top'> <td><code>rhat, ess</code></td> <td> <p>(logical) include Rhat and/or effective sample size estimates?</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>unused</p> </td> </tr> </table> "	FALSE
"auc_tidiers"	"broom"	"Tidiers for objects from the AUC package"	"<p>Tidy 'roc' objects from the 'auc' package. This can be used to, for example, draw ROC curves in ggplot2. </p>"	"<pre>## S3 method for class 'roc' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an 'roc' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments, not used</p> </td> </tr> </table> "	FALSE
"rowwise_df_tidiers"	"broom"	"Tidying methods for rowwise_dfs from dplyr, for tidying each row andrecombining the results"	"<p>These <code>tidy</code>, <code>augment</code> and <code>glance</code> methods are for performing tidying on each row of a rowwise data frame created by dplyr's <code>group_by</code> and <code>do</code> operations. They first group a rowwise data frame based on all columns that are not lists, then perform the tidying operation on the specified column. This greatly shortens a common idiom of extracting tidy/augment/glance outputs after a do statement. </p>"	"<pre>## S3 method for class 'rowwise_df' tidy(x, object, ...)<br />## S3 method for class 'rowwise_df' tidy_(x, object, ...)<br />## S3 method for class 'rowwise_df' augment(x, object, ...)<br />## S3 method for class 'rowwise_df' augment_(x, object, ...)<br />## S3 method for class 'rowwise_df' glance(x, object, ...)<br />## S3 method for class 'rowwise_df' glance_(x, object, ...)<br />## S3 method for class 'tbl_df' tidy(x, ...)<br />## S3 method for class 'tbl_df' augment(x, ...)<br />## S3 method for class 'tbl_df' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a rowwise_df</p> </td> </tr> <tr valign='top'> <td><code>object</code></td> <td> <p>the column name of the column containing the models to be tidied. For tidy, augment, and glance it should be the bare name; for _ methods it should be quoted.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass on to the respective tidying method</p> </td> </tr> </table> "	FALSE
"rq_tidiers"	"broom"	"Tidying methods for quantile regression models"	"<p>These methods tidy the coefficients of a quantile regression model into a summary, augment the original data with information on the fitted values and residuals, and construct a glance of the model's statistics. </p>"	"<pre>## S3 method for class 'rq' tidy(x, se.type = 'rank', conf.int = TRUE, conf.level = 0.95,<br />   alpha = 1 - conf.level, ...)<br />## S3 method for class 'rqs' tidy(x, se.type = 'rank', conf.int = TRUE,<br />   conf.level = 0.95, alpha = 1 - conf.level, ...)<br />## S3 method for class 'nlrq' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'rq' glance(x, ...)<br />## S3 method for class 'nlrq' glance(x, ...)<br />## S3 method for class 'rq' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'rqs' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'nlrq' augment(x, data = NULL, newdata = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>model object returned by <code>rq</code> or <code>nlrq</code></p> </td> </tr> <tr valign='top'> <td><code>se.type</code></td> <td> <p>Type of standard errors to calculate; see <code>summary.rq</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>boolean; should confidence intervals be calculated, ignored if <code>se.type = 'rank'</code></p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for intervals</p> </td> </tr> <tr valign='top'> <td><code>alpha</code></td> <td> <p>confidence level when <code>se.type = 'rank'</code>; defaults to the same as <code>conf.level</code> although the specification is inverted</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, new data frame to use for predictions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>summary.rq</code></p> </td> </tr> </table> "	FALSE
"rq_tidiers"	"broom"	"Tidying methods for quantile regression models"	"<p>These methods tidy the coefficients of a quantile regression model into a summary, augment the original data with information on the fitted values and residuals, and construct a glance of the model's statistics. </p>"	"<pre>## S3 method for class 'rq' tidy(x, se.type = 'rank', conf.int = TRUE, conf.level = 0.95,<br />   alpha = 1 - conf.level, ...)<br />## S3 method for class 'rqs' tidy(x, se.type = 'rank', conf.int = TRUE,<br />   conf.level = 0.95, alpha = 1 - conf.level, ...)<br />## S3 method for class 'nlrq' tidy(x, conf.int = FALSE, conf.level = 0.95, ...)<br />## S3 method for class 'rq' glance(x, ...)<br />## S3 method for class 'nlrq' glance(x, ...)<br />## S3 method for class 'rq' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'rqs' augment(x, data = model.frame(x), newdata, ...)<br />## S3 method for class 'nlrq' augment(x, data = NULL, newdata = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>model object returned by <code>rq</code> or <code>nlrq</code></p> </td> </tr> <tr valign='top'> <td><code>se.type</code></td> <td> <p>Type of standard errors to calculate; see <code>summary.rq</code></p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>boolean; should confidence intervals be calculated, ignored if <code>se.type = 'rank'</code></p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for intervals</p> </td> </tr> <tr valign='top'> <td><code>alpha</code></td> <td> <p>confidence level when <code>se.type = 'rank'</code>; defaults to the same as <code>conf.level</code> although the specification is inverted</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, new data frame to use for predictions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>summary.rq</code></p> </td> </tr> </table> "	FALSE
"sparse_tidiers"	"broom"	"Tidy a sparseMatrix object from the Matrix package"	"<p>Tidy a sparseMatrix object from the Matrix package into a three-column data frame, row, column, and value (with zeros missing). If there are row names or column names, use those, otherwise use indices </p>"	"<pre>## S3 method for class 'dgTMatrix' tidy(x, ...)<br />## S3 method for class 'dgCMatrix' tidy(x, ...)<br />## S3 method for class 'sparseMatrix' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A Matrix object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments, not used</p> </td> </tr> </table>"	FALSE
"sp_tidiers"	"broom"	"tidying methods for classes from the sp package."	"<p>Tidy classes from the sp package to allow them to be plotted using ggplot2. To figure out the correct variable name for region, inspect <code>as.data.frame(x)</code>. </p>"	"<pre>## S3 method for class 'SpatialPolygonsDataFrame' tidy(x, region = NULL, ...)<br />## S3 method for class 'SpatialPolygons' tidy(x, ...)<br />## S3 method for class 'Polygons' tidy(x, ...)<br />## S3 method for class 'Polygon' tidy(x, ...)<br />## S3 method for class 'SpatialLinesDataFrame' tidy(x, ...)<br />## S3 method for class 'Lines' tidy(x, ...)<br />## S3 method for class 'Line' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p><code>SpatialPolygonsDataFrame</code> to convert into a dataframe.</p> </td> </tr> <tr valign='top'> <td><code>region</code></td> <td> <p>name of variable used to split up regions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used by this method</p> </td> </tr> </table> "	FALSE
"sp_tidiers"	"broom"	"tidying methods for classes from the sp package."	"<p>Tidy classes from the sp package to allow them to be plotted using ggplot2. To figure out the correct variable name for region, inspect <code>as.data.frame(x)</code>. </p>"	"<pre>## S3 method for class 'SpatialPolygonsDataFrame' tidy(x, region = NULL, ...)<br />## S3 method for class 'SpatialPolygons' tidy(x, ...)<br />## S3 method for class 'Polygons' tidy(x, ...)<br />## S3 method for class 'Polygon' tidy(x, ...)<br />## S3 method for class 'SpatialLinesDataFrame' tidy(x, ...)<br />## S3 method for class 'Lines' tidy(x, ...)<br />## S3 method for class 'Line' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p><code>SpatialPolygonsDataFrame</code> to convert into a dataframe.</p> </td> </tr> <tr valign='top'> <td><code>region</code></td> <td> <p>name of variable used to split up regions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used by this method</p> </td> </tr> </table> "	FALSE
"sp_tidiers"	"broom"	"tidying methods for classes from the sp package."	"<p>Tidy classes from the sp package to allow them to be plotted using ggplot2. To figure out the correct variable name for region, inspect <code>as.data.frame(x)</code>. </p>"	"<pre>## S3 method for class 'SpatialPolygonsDataFrame' tidy(x, region = NULL, ...)<br />## S3 method for class 'SpatialPolygons' tidy(x, ...)<br />## S3 method for class 'Polygons' tidy(x, ...)<br />## S3 method for class 'Polygon' tidy(x, ...)<br />## S3 method for class 'SpatialLinesDataFrame' tidy(x, ...)<br />## S3 method for class 'Lines' tidy(x, ...)<br />## S3 method for class 'Line' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p><code>SpatialPolygonsDataFrame</code> to convert into a dataframe.</p> </td> </tr> <tr valign='top'> <td><code>region</code></td> <td> <p>name of variable used to split up regions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used by this method</p> </td> </tr> </table> "	FALSE
"tidy.spec"	"broom"	"tidy a spec objet"	"<p>Given a 'spec' object, which shows a spectrum across a range of frequencies, returns a tidy data frame with two columns: 'freq' and 'spec' </p>"	"<pre>## S3 method for class 'spec' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class 'spec'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"mcmc_tidiers"	"broom"	"Tidying methods for MCMC (Stan, JAGS, etc.) fits"	"<p>Tidying methods for MCMC (Stan, JAGS, etc.) fits </p>"	"<pre>tidyMCMC(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', droppars = 'lp__',<br />   rhat = FALSE, ess = FALSE, ...)<br />## S3 method for class 'rjags' tidy(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', ...)<br />## S3 method for class 'stanfit' tidy(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', droppars = 'lp__',<br />   rhat = FALSE, ess = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class ‘'stanfit'’</p> </td> </tr> <tr valign='top'> <td><code>pars</code></td> <td> <p>(character) specification of which parameters to include</p> </td> </tr> <tr valign='top'> <td><code>estimate.method</code></td> <td> <p>method for computing point estimate ('mean' or median')</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>(logical) include confidence interval?</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>probability level for CI</p> </td> </tr> <tr valign='top'> <td><code>conf.method</code></td> <td> <p>method for computing confidence intervals ('quantile' or 'HPDinterval')</p> </td> </tr> <tr valign='top'> <td><code>droppars</code></td> <td> <p>Parameters not to include in the output (such as log-probability information)</p> </td> </tr> <tr valign='top'> <td><code>rhat, ess</code></td> <td> <p>(logical) include Rhat and/or effective sample size estimates?</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>unused</p> </td> </tr> </table> "	FALSE
"rstanarm_tidiers"	"broom"	"Tidying methods for an rstanarm model"	"<p>These methods tidy the estimates from <code>stanreg-objects</code> (fitted model objects from the <span class='pkg'>rstanarm</span> package) into a summary. </p>"	"<pre>## S3 method for class 'stanreg' tidy(x, parameters = c('non-varying', 'varying',<br />   'hierarchical'), intervals = FALSE, prob = 0.9, ...)<br />## S3 method for class 'stanreg' glance(x, looic = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Fitted model object from the <span class='pkg'>rstanarm</span> package. See  <code>stanreg-objects</code>.</p> </td> </tr> <tr valign='top'> <td><code>parameters</code></td> <td> <p>One of <code>'non-varying'</code>, <code>'varying'</code>, or  <code>'hierarchical'</code> (can be abbreviated). See the Value section for  details.</p> </td> </tr> <tr valign='top'> <td><code>intervals</code></td> <td> <p>If <code>TRUE</code> columns for the lower and upper bounds of the <code>100*prob</code>% posterior uncertainty intervals are included. See  <code>posterior_interval</code> for details.</p> </td> </tr> <tr valign='top'> <td><code>prob</code></td> <td> <p>See <code>posterior_interval</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>For <code>glance</code>, if <code>looic=TRUE</code>, optional arguments to <code>loo.stanreg</code>.</p> </td> </tr> <tr valign='top'> <td><code>looic</code></td> <td> <p>Should the LOO Information Criterion be included? See  <code>loo.stanreg</code> for details. Note: for models fit to very large data this can be a slow computation.</p> </td> </tr> </table> "	FALSE
"multcomp_tidiers"	"broom"	"tidying methods for objects produced by multcomp"	"<p>These methods originated in ggplot2, as 'fortify.' In broom, they were renamed 'tidy' because they summarize terms and tests, rather than adding columns to a dataset. </p>"	"<pre>## S3 method for class 'glht' tidy(x, ...)<br />## S3 method for class 'confint.glht' tidy(x, ...)<br />## S3 method for class 'summary.glht' tidy(x, ...)<br />## S3 method for class 'cld' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class <code>glht</code>, <code>confint.glht</code>, <code>summary.glht</code> or <code>cld</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"lm_tidiers"	"broom"	"Tidying methods for a linear model"	"<p>These methods tidy the coefficients of a linear model into a summary, augment the original data with information on the fitted values and residuals, and construct a one-row glance of the model's statistics. </p>"	"<pre>## S3 method for class 'lm' tidy(x, conf.int = FALSE, conf.level = 0.95,<br />   exponentiate = FALSE, quick = FALSE, ...)<br />## S3 method for class 'summary.lm' tidy(x, ...)<br />## S3 method for class 'lm' augment(x, data = stats::model.frame(x), newdata, type.predict,<br />   type.residuals, ...)<br />## S3 method for class 'lm' glance(x, ...)<br />## S3 method for class 'summary.lm' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>lm object</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>whether to include a confidence interval</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level of the interval, used only if <code>conf.int=TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>exponentiate</code></td> <td> <p>whether to exponentiate the coefficient estimates and confidence intervals (typical for logistic regression)</p> </td> </tr> <tr valign='top'> <td><code>quick</code></td> <td> <p>whether to compute a smaller and faster version, containing only the <code>term</code> and <code>estimate</code> columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Original data, defaults to the extracting it from the model</p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>If provided, performs predictions on the new data</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>Type of prediction to compute for a GLM; passed on to <code>predict.glm</code></p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>Type of residuals to compute for a GLM; passed on to <code>residuals.glm</code></p> </td> </tr> </table> "	FALSE
"summary_tidiers"	"broom"	"Tidiers for summaryDefault objects"	"<p>Tidy a summary of a vector. </p>"	"<pre>## S3 method for class 'summaryDefault' tidy(x, ...)<br />## S3 method for class 'summaryDefault' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>summaryDefault object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"sexpfit_tidiers"	"broom"	"Tidy an expected survival curve"	"<p>This constructs a summary across time points or overall of an expected survival curve. Note that this contains less information than most survfit objects. </p>"	"<pre>## S3 method for class 'survexp' tidy(x, ...)<br />## S3 method for class 'survexp' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>'survexp' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"survfit_tidiers"	"broom"	"tidy survival curve fits"	"<p>Construct tidied data frames showing survival curves over time. </p>"	"<pre>## S3 method for class 'survfit' tidy(x, ...)<br />## S3 method for class 'survfit' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>'survfit' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments, not used</p> </td> </tr> </table> "	FALSE
"survreg_tidiers"	"broom"	"Tidiers for a parametric regression survival model"	"<p>Tidies the coefficients of a parametric survival regression model, from the 'survreg' function, adds fitted values and residuals, or summarizes the model statistics. </p>"	"<pre>## S3 method for class 'survreg' tidy(x, conf.level = 0.95, ...)<br />## S3 method for class 'survreg' augment(x, data = stats::model.frame(x), newdata,<br />   type.predict = 'response', type.residuals = 'response', ...)<br />## S3 method for class 'survreg' glance(x, conf.level = 0.95, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'survreg' model</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>confidence level for CI</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original data; if it is not provided, it is reconstructed as best as possible with <code>model.frame</code></p> </td> </tr> <tr valign='top'> <td><code>newdata</code></td> <td> <p>New data to use for prediction; optional</p> </td> </tr> <tr valign='top'> <td><code>type.predict</code></td> <td> <p>type of prediction, default 'response'</p> </td> </tr> <tr valign='top'> <td><code>type.residuals</code></td> <td> <p>type of residuals to calculate, default 'response'</p> </td> </tr> </table> "	FALSE
"tidy.table"	"broom"	"tidy a table object"	"<p>A table, typically created by the table function, contains a contingency table of frequencies across multiple vectors. This directly calls the <code>as.data.frame.table</code> method, which melts it into a data frame with one column for each variable and a <code>Freq</code> column. </p>"	"<pre>## S3 method for class 'table' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class 'table'</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"rowwise_df_tidiers"	"broom"	"Tidying methods for rowwise_dfs from dplyr, for tidying each row andrecombining the results"	"<p>These <code>tidy</code>, <code>augment</code> and <code>glance</code> methods are for performing tidying on each row of a rowwise data frame created by dplyr's <code>group_by</code> and <code>do</code> operations. They first group a rowwise data frame based on all columns that are not lists, then perform the tidying operation on the specified column. This greatly shortens a common idiom of extracting tidy/augment/glance outputs after a do statement. </p>"	"<pre>## S3 method for class 'rowwise_df' tidy(x, object, ...)<br />## S3 method for class 'rowwise_df' tidy_(x, object, ...)<br />## S3 method for class 'rowwise_df' augment(x, object, ...)<br />## S3 method for class 'rowwise_df' augment_(x, object, ...)<br />## S3 method for class 'rowwise_df' glance(x, object, ...)<br />## S3 method for class 'rowwise_df' glance_(x, object, ...)<br />## S3 method for class 'tbl_df' tidy(x, ...)<br />## S3 method for class 'tbl_df' augment(x, ...)<br />## S3 method for class 'tbl_df' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a rowwise_df</p> </td> </tr> <tr valign='top'> <td><code>object</code></td> <td> <p>the column name of the column containing the models to be tidied. For tidy, augment, and glance it should be the bare name; for _ methods it should be quoted.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass on to the respective tidying method</p> </td> </tr> </table> "	FALSE
"tidy.ts"	"broom"	"tidy a ts timeseries object"	"<p>Turn a ts object into a tidy data frame. Right now simply uses <code>as.data.frame.ts</code>. </p>"	"<pre>## S3 method for class 'ts' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a 'ts' object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"tidy.TukeyHSD"	"broom"	"tidy a TukeyHSD object"	"<p>Returns a data.frame with one row for each pairwise comparison </p>"	"<pre>## S3 method for class 'TukeyHSD' tidy(x, separate.levels = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>object of class 'TukeyHSD'</p> </td> </tr> <tr valign='top'> <td><code>separate.levels</code></td> <td> <p>Whether to separate comparison into <code>level1</code> and <code>level2</code> columns</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments (not used)</p> </td> </tr> </table> "	FALSE
"zoo_tidiers"	"broom"	"Tidying methods for a zoo object"	"<p>Tidies <code>zoo</code> (Z's ordered observations) time series objects. <code>zoo</code> objects are not tidy by default because they contain one row for each index and one series per column, rather than one row per observation per series. </p>"	"<pre>## S3 method for class 'zoo' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>'zoo'</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"mcmc_tidiers"	"broom"	"Tidying methods for MCMC (Stan, JAGS, etc.) fits"	"<p>Tidying methods for MCMC (Stan, JAGS, etc.) fits </p>"	"<pre>tidyMCMC(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', droppars = 'lp__',<br />   rhat = FALSE, ess = FALSE, ...)<br />## S3 method for class 'rjags' tidy(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', ...)<br />## S3 method for class 'stanfit' tidy(x, pars, estimate.method = 'mean', conf.int = FALSE,<br />   conf.level = 0.95, conf.method = 'quantile', droppars = 'lp__',<br />   rhat = FALSE, ess = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object of class ‘'stanfit'’</p> </td> </tr> <tr valign='top'> <td><code>pars</code></td> <td> <p>(character) specification of which parameters to include</p> </td> </tr> <tr valign='top'> <td><code>estimate.method</code></td> <td> <p>method for computing point estimate ('mean' or median')</p> </td> </tr> <tr valign='top'> <td><code>conf.int</code></td> <td> <p>(logical) include confidence interval?</p> </td> </tr> <tr valign='top'> <td><code>conf.level</code></td> <td> <p>probability level for CI</p> </td> </tr> <tr valign='top'> <td><code>conf.method</code></td> <td> <p>method for computing confidence intervals ('quantile' or 'HPDinterval')</p> </td> </tr> <tr valign='top'> <td><code>droppars</code></td> <td> <p>Parameters not to include in the output (such as log-probability information)</p> </td> </tr> <tr valign='top'> <td><code>rhat, ess</code></td> <td> <p>(logical) include Rhat and/or effective sample size estimates?</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>unused</p> </td> </tr> </table> "	FALSE
"rowwise_df_tidiers"	"broom"	"Tidying methods for rowwise_dfs from dplyr, for tidying each row andrecombining the results"	"<p>These <code>tidy</code>, <code>augment</code> and <code>glance</code> methods are for performing tidying on each row of a rowwise data frame created by dplyr's <code>group_by</code> and <code>do</code> operations. They first group a rowwise data frame based on all columns that are not lists, then perform the tidying operation on the specified column. This greatly shortens a common idiom of extracting tidy/augment/glance outputs after a do statement. </p>"	"<pre>## S3 method for class 'rowwise_df' tidy(x, object, ...)<br />## S3 method for class 'rowwise_df' tidy_(x, object, ...)<br />## S3 method for class 'rowwise_df' augment(x, object, ...)<br />## S3 method for class 'rowwise_df' augment_(x, object, ...)<br />## S3 method for class 'rowwise_df' glance(x, object, ...)<br />## S3 method for class 'rowwise_df' glance_(x, object, ...)<br />## S3 method for class 'tbl_df' tidy(x, ...)<br />## S3 method for class 'tbl_df' augment(x, ...)<br />## S3 method for class 'tbl_df' glance(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a rowwise_df</p> </td> </tr> <tr valign='top'> <td><code>object</code></td> <td> <p>the column name of the column containing the models to be tidied. For tidy, augment, and glance it should be the bare name; for _ methods it should be quoted.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass on to the respective tidying method</p> </td> </tr> </table> "	FALSE
"optim_tidiers"	"broom"	"Tidiers for lists returned from optim"	"<p>Tidies objects returned by the <code>optim</code> function for general-purpose minimization and maximization. </p>"	"<pre>tidy_optim(x, ...)<br />glance_optim(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>list returned from <code>optim</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments</p> </td> </tr> </table> "	FALSE
"orcutt_tidiers"	"broom"	"Tidiers for Cochrane Orcutt object"	"<p>Tidies a Cochrane Orcutt object, which estimates autocorrelation and beta coefficients. This function is not exported and would not typically be called directly: it is dispatched by <code>tidy.list</code> and <code>glance.list</code>. </p>"	"<pre>tidy_orcutt(x, ...)<br />glance_orcutt(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list returned by <code>cochrane.orcutt</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments passed on to <code>tidy.summary.lm</code></p> </td> </tr> </table> "	FALSE
"svd_tidiers"	"broom"	"Tidying methods for singular value decomposition"	"<p>These methods tidy the U, D, and V matrices returned by the <code>svd</code> function into a tidy format. Because <code>svd</code> returns a list without a class, this function has to be called by <code>tidy.list</code> when it recognizes a list as an SVD object. </p>"	"<pre>tidy_svd(x, matrix = 'u', ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>list containing d, u, v components, returned from <code>svd</code></p> </td> </tr> <tr valign='top'> <td><code>matrix</code></td> <td> <p>which of the u, d or v matrix to tidy</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"xyz_tidiers"	"broom"	"Tidiers for x, y, z lists suitable for persp, image, etc."	"<p>Tidies lists with components x, y (vector of coordinates) and z (matrix of values) which are typically used by functions such as <code>persp</code> or <code>image</code> and returned by interpolation functions such as <code>interp</code>. </p>"	"<pre>tidy_xyz(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>list with components x, y and z</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments</p> </td> </tr> </table> "	FALSE
"unrowname"	"broom"	"strip rownames from an object"	"<p>strip rownames from an object </p>"	"<pre>unrowname(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>a data frame</p> </td> </tr></table>"	FALSE
"xyz_tidiers"	"broom"	"Tidiers for x, y, z lists suitable for persp, image, etc."	"<p>Tidies lists with components x, y (vector of coordinates) and z (matrix of values) which are typically used by functions such as <code>persp</code> or <code>image</code> and returned by interpolation functions such as <code>interp</code>. </p>"	"<pre>tidy_xyz(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>list with components x, y and z</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments</p> </td> </tr> </table> "	FALSE
"zoo_tidiers"	"broom"	"Tidying methods for a zoo object"	"<p>Tidies <code>zoo</code> (Z's ordered observations) time series objects. <code>zoo</code> objects are not tidy by default because they contain one row for each index and one series per column, rather than one row per observation per series. </p>"	"<pre>## S3 method for class 'zoo' tidy(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object of class <code>'zoo'</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>extra arguments (not used)</p> </td> </tr> </table> "	FALSE
"dplyr"	"dplyr"	"dplyr: a grammar of data manipulation"	"<p>dplyr provides a flexible grammar of data manipulation. It's the next iteration of plyr, focused on tools for working with data frames (hence the <em>d</em> in the name). </p>"	NA	NA	FALSE
"add_rownames"	"dplyr"	"Convert row names to an explicit variable."	"<p>Deprecated, use <code>rownames_to_column</code> instead. </p>"	"<pre>add_rownames(df, var = 'rowname') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>df</code></td> <td> <p>Input data frame with rownames.</p> </td> </tr> <tr valign='top'> <td><code>var</code></td> <td> <p>Name of variable to use</p> </td> </tr> </table> "	FALSE
"all_equal"	"dplyr"	"Flexible equality comparison for data frames."	"<p>You can use <code>all_equal</code> with any data frame, and dplyr also provides <code>tbl_df</code> methods for <code>all.equal</code>. </p>"	"<pre>all_equal(target, current, ignore_col_order = TRUE, ignore_row_order = TRUE,<br />   convert = FALSE, ...)<br />## S3 method for class 'tbl_df' all.equal(target, current, ignore_col_order = TRUE,<br />   ignore_row_order = TRUE, convert = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>target, current</code></td> <td> <p>Two data frames to compare.</p> </td> </tr> <tr valign='top'> <td><code>ignore_col_order</code></td> <td> <p>Should order of columns be ignored?</p> </td> </tr> <tr valign='top'> <td><code>ignore_row_order</code></td> <td> <p>Should order of rows be ignored?</p> </td> </tr> <tr valign='top'> <td><code>convert</code></td> <td> <p>Should similar classes be converted? Currently this will convert factor to character and integer to double.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Ignored. Needed for compatibility with <code>all.equal</code>.</p> </td> </tr> </table> "	FALSE
"all_equal"	"dplyr"	"Flexible equality comparison for data frames."	"<p>You can use <code>all_equal</code> with any data frame, and dplyr also provides <code>tbl_df</code> methods for <code>all.equal</code>. </p>"	"<pre>all_equal(target, current, ignore_col_order = TRUE, ignore_row_order = TRUE,<br />   convert = FALSE, ...)<br />## S3 method for class 'tbl_df' all.equal(target, current, ignore_col_order = TRUE,<br />   ignore_row_order = TRUE, convert = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>target, current</code></td> <td> <p>Two data frames to compare.</p> </td> </tr> <tr valign='top'> <td><code>ignore_col_order</code></td> <td> <p>Should order of columns be ignored?</p> </td> </tr> <tr valign='top'> <td><code>ignore_row_order</code></td> <td> <p>Should order of rows be ignored?</p> </td> </tr> <tr valign='top'> <td><code>convert</code></td> <td> <p>Should similar classes be converted? Currently this will convert factor to character and integer to double.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Ignored. Needed for compatibility with <code>all.equal</code>.</p> </td> </tr> </table> "	FALSE
"join"	"dplyr"	"Join two tbls together."	"<p>These are generic functions that dispatch to individual tbl methods - see the method documentation for details of individual data sources. <code>x</code> and <code>y</code> should usually be from the same data source, but if <code>copy</code> is <code>TRUE</code>, <code>y</code> will automatically be copied to the same source as <code>x</code> - this may be an expensive operation. </p>"	"<pre>inner_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />right_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />semi_join(x, y, by = NULL, copy = FALSE, ...)<br />anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"join.tbl_df"	"dplyr"	"Join data frame tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_df' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' semi_join(x, y, by = NULL, copy = FALSE, ...)<br />## S3 method for class 'tbl_df' anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>included for compatibility with the generic; otherwise ignored.</p> </td> </tr> </table> "	FALSE
"join.tbl_sql"	"dplyr"	"Join sql tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_lazy' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' left_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' full_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' semi_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' anti_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into a temporary table in same database as <code>x</code>. <code>join</code> will automatically run <code>ANALYZE</code> on the created table in the hope that this will make you queries as efficient as possible by giving more data to the query planner. </p> <p>This allows you to join tables across srcs, but it's potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>auto_index</code></td> <td> <p>if <code>copy</code> is <code>TRUE</code>, automatically create indices for the variables in <code>by</code>. This may speed up the join if there are matching indexes in <code>x</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"arrange"	"dplyr"	"Arrange rows by variables."	"<p>Use <code>desc</code> to sort a variable in descending order. Generally, this will not also automatically order by grouping variables. </p>"	"<pre>arrange(.data, ...)<br />arrange_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Comma separated list of unquoted variable names. Use <code>desc</code> to sort a variable in descending order.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"arrange"	"dplyr"	"Arrange rows by variables."	"<p>Use <code>desc</code> to sort a variable in descending order. Generally, this will not also automatically order by grouping variables. </p>"	"<pre>arrange(.data, ...)<br />arrange_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Comma separated list of unquoted variable names. Use <code>desc</code> to sort a variable in descending order.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"as.table.tbl_cube"	"dplyr"	"Coerce a tbl_cube to other data structures"	"<p>Supports conversion to tables, data frames, tibbles. </p> <p>For a cube, the data frame returned by <code>as_data_frame</code> resulting data frame contains the dimensions as character values (and not as factors). </p>"	"<pre>## S3 method for class 'tbl_cube' as.table(x, ..., measure = 1L)<br />## S3 method for class 'tbl_cube' as.data.frame(x, ...)<br />## S3 method for class 'tbl_cube' as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a <code>tbl_cube</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Passed on to individual methods; otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>measure</code></td> <td> <p>A measure name or index, default: the first measure</p> </td> </tr> </table>"	FALSE
"as.table.tbl_cube"	"dplyr"	"Coerce a tbl_cube to other data structures"	"<p>Supports conversion to tables, data frames, tibbles. </p> <p>For a cube, the data frame returned by <code>as_data_frame</code> resulting data frame contains the dimensions as character values (and not as factors). </p>"	"<pre>## S3 method for class 'tbl_cube' as.table(x, ..., measure = 1L)<br />## S3 method for class 'tbl_cube' as.data.frame(x, ...)<br />## S3 method for class 'tbl_cube' as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a <code>tbl_cube</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Passed on to individual methods; otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>measure</code></td> <td> <p>A measure name or index, default: the first measure</p> </td> </tr> </table>"	FALSE
"tbl"	"dplyr"	"Create a table from a data source"	"<p>This is a generic method that dispatches based on the first argument. </p>"	"<pre>tbl(src, ...)<br />is.tbl(x)<br />as.tbl(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>src</code></td> <td> <p>A data source</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to the individual methods</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an object to coerce to a <code>tbl</code></p> </td> </tr> </table>"	FALSE
"as.tbl_cube"	"dplyr"	"Coerce an existing data structure into a tbl_cube"	"<p>Coerce an existing data structure into a <code>tbl_cube</code> </p>"	"<pre>as.tbl_cube(x, ...)<br />## S3 method for class 'array' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = deparse(substitute(x)), ...)<br />## S3 method for class 'table' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = 'Freq', ...)<br />## S3 method for class 'matrix' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = deparse(substitute(x)), ...)<br />## S3 method for class 'data.frame' as.tbl_cube(x, dim_names = NULL,<br />   met_name = guess_met(x), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object to convert. Built in methods will convert arrays, tables and data frames.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Passed on to individual methods; otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>dim_names</code></td> <td> <p>names of the dimesions. Defaults to the names of</p> </td> </tr> <tr valign='top'> <td><code>met_name</code></td> <td> <p>a string to use as the name for the measure the <code>dimnames</code>.</p> </td> </tr> </table>"	FALSE
"as.tbl_cube"	"dplyr"	"Coerce an existing data structure into a tbl_cube"	"<p>Coerce an existing data structure into a <code>tbl_cube</code> </p>"	"<pre>as.tbl_cube(x, ...)<br />## S3 method for class 'array' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = deparse(substitute(x)), ...)<br />## S3 method for class 'table' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = 'Freq', ...)<br />## S3 method for class 'matrix' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = deparse(substitute(x)), ...)<br />## S3 method for class 'data.frame' as.tbl_cube(x, dim_names = NULL,<br />   met_name = guess_met(x), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object to convert. Built in methods will convert arrays, tables and data frames.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Passed on to individual methods; otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>dim_names</code></td> <td> <p>names of the dimesions. Defaults to the names of</p> </td> </tr> <tr valign='top'> <td><code>met_name</code></td> <td> <p>a string to use as the name for the measure the <code>dimnames</code>.</p> </td> </tr> </table>"	FALSE
"as.tbl_cube"	"dplyr"	"Coerce an existing data structure into a tbl_cube"	"<p>Coerce an existing data structure into a <code>tbl_cube</code> </p>"	"<pre>as.tbl_cube(x, ...)<br />## S3 method for class 'array' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = deparse(substitute(x)), ...)<br />## S3 method for class 'table' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = 'Freq', ...)<br />## S3 method for class 'matrix' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = deparse(substitute(x)), ...)<br />## S3 method for class 'data.frame' as.tbl_cube(x, dim_names = NULL,<br />   met_name = guess_met(x), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object to convert. Built in methods will convert arrays, tables and data frames.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Passed on to individual methods; otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>dim_names</code></td> <td> <p>names of the dimesions. Defaults to the names of</p> </td> </tr> <tr valign='top'> <td><code>met_name</code></td> <td> <p>a string to use as the name for the measure the <code>dimnames</code>.</p> </td> </tr> </table>"	FALSE
"as.tbl_cube"	"dplyr"	"Coerce an existing data structure into a tbl_cube"	"<p>Coerce an existing data structure into a <code>tbl_cube</code> </p>"	"<pre>as.tbl_cube(x, ...)<br />## S3 method for class 'array' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = deparse(substitute(x)), ...)<br />## S3 method for class 'table' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = 'Freq', ...)<br />## S3 method for class 'matrix' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = deparse(substitute(x)), ...)<br />## S3 method for class 'data.frame' as.tbl_cube(x, dim_names = NULL,<br />   met_name = guess_met(x), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object to convert. Built in methods will convert arrays, tables and data frames.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Passed on to individual methods; otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>dim_names</code></td> <td> <p>names of the dimesions. Defaults to the names of</p> </td> </tr> <tr valign='top'> <td><code>met_name</code></td> <td> <p>a string to use as the name for the measure the <code>dimnames</code>.</p> </td> </tr> </table>"	FALSE
"as.tbl_cube"	"dplyr"	"Coerce an existing data structure into a tbl_cube"	"<p>Coerce an existing data structure into a <code>tbl_cube</code> </p>"	"<pre>as.tbl_cube(x, ...)<br />## S3 method for class 'array' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = deparse(substitute(x)), ...)<br />## S3 method for class 'table' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = 'Freq', ...)<br />## S3 method for class 'matrix' as.tbl_cube(x, dim_names = names(dimnames(x)),<br />   met_name = deparse(substitute(x)), ...)<br />## S3 method for class 'data.frame' as.tbl_cube(x, dim_names = NULL,<br />   met_name = guess_met(x), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an object to convert. Built in methods will convert arrays, tables and data frames.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Passed on to individual methods; otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>dim_names</code></td> <td> <p>names of the dimesions. Defaults to the names of</p> </td> </tr> <tr valign='top'> <td><code>met_name</code></td> <td> <p>a string to use as the name for the measure the <code>dimnames</code>.</p> </td> </tr> </table>"	FALSE
"as.table.tbl_cube"	"dplyr"	"Coerce a tbl_cube to other data structures"	"<p>Supports conversion to tables, data frames, tibbles. </p> <p>For a cube, the data frame returned by <code>as_data_frame</code> resulting data frame contains the dimensions as character values (and not as factors). </p>"	"<pre>## S3 method for class 'tbl_cube' as.table(x, ..., measure = 1L)<br />## S3 method for class 'tbl_cube' as.data.frame(x, ...)<br />## S3 method for class 'tbl_cube' as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a <code>tbl_cube</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Passed on to individual methods; otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>measure</code></td> <td> <p>A measure name or index, default: the first measure</p> </td> </tr> </table>"	FALSE
"auto_copy"	"dplyr"	"Copy tables to same source, if necessary."	"<p>Copy tables to same source, if necessary. </p>"	"<pre>auto_copy(x, y, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p><code>y</code> will be copied to <code>x</code>, if neccessary.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to methods.</p> </td> </tr> </table>"	FALSE
"bench_compare"	"dplyr"	"Evaluate, compare, benchmark operations of a set of srcs."	"<p>These functions support the comparison of results and timings across multiple sources. </p>"	"<pre>bench_tbls(tbls, op, ..., times = 10)<br />compare_tbls(tbls, op, ref = NULL, compare = equal_data_frame, ...)<br />eval_tbls(tbls, op) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbls</code></td> <td> <p>A list of <code>tbl</code>s.</p> </td> </tr> <tr valign='top'> <td><code>op</code></td> <td> <p>A function with a single argument, called often with each element of <code>tbls</code>.</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>For benchmarking, the number of times each operation is repeated.</p> </td> </tr> <tr valign='top'> <td><code>ref</code></td> <td> <p>For checking, an data frame to test results against. If not supplied, defaults to the results from the first <code>src</code>.</p> </td> </tr> <tr valign='top'> <td><code>compare</code></td> <td> <p>A function used to compare the results. Defaults to <code>equal_data_frame</code> which ignores the order of rows and columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>For <code>compare_tbls</code>: additional parameters passed on the <code>compare</code> function </p> <p>For <code>bench_tbls</code>: additional benchmarks to run.</p> </td> </tr> </table> "	FALSE
"bench_compare"	"dplyr"	"Evaluate, compare, benchmark operations of a set of srcs."	"<p>These functions support the comparison of results and timings across multiple sources. </p>"	"<pre>bench_tbls(tbls, op, ..., times = 10)<br />compare_tbls(tbls, op, ref = NULL, compare = equal_data_frame, ...)<br />eval_tbls(tbls, op) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbls</code></td> <td> <p>A list of <code>tbl</code>s.</p> </td> </tr> <tr valign='top'> <td><code>op</code></td> <td> <p>A function with a single argument, called often with each element of <code>tbls</code>.</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>For benchmarking, the number of times each operation is repeated.</p> </td> </tr> <tr valign='top'> <td><code>ref</code></td> <td> <p>For checking, an data frame to test results against. If not supplied, defaults to the results from the first <code>src</code>.</p> </td> </tr> <tr valign='top'> <td><code>compare</code></td> <td> <p>A function used to compare the results. Defaults to <code>equal_data_frame</code> which ignores the order of rows and columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>For <code>compare_tbls</code>: additional parameters passed on the <code>compare</code> function </p> <p>For <code>bench_tbls</code>: additional benchmarks to run.</p> </td> </tr> </table> "	FALSE
"between"	"dplyr"	"Do values in a numeric vector fall in specified range?"	"<p>This is a shortcut for <code>x &gt;= left &amp; x &lt;= right</code>, implemented efficiently in C++ for local values, and translated to the appropriate SQL for remote tables. </p>"	"<pre>between(x, left, right) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A numeric vector of values</p> </td> </tr> <tr valign='top'> <td><code>left, right</code></td> <td> <p>Boundary values</p> </td> </tr> </table> "	FALSE
"bind"	"dplyr"	"Efficiently bind multiple data frames by row and column."	"<p>This is an efficient implementation of the common pattern of <code>do.call(rbind, dfs)</code> or <code>do.call(cbind, dfs)</code> for binding many data frames into one. <code>combine()</code> acts like <code>c()</code> or <code>unlist()</code> but uses consistent dplyr coercion rules. </p>"	"<pre>bind_rows(..., .id = NULL)<br />bind_cols(...)<br />combine(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Data frames to combine. </p> <p>Each argument can either be a data frame, a list that could be a data frame, or a list of data frames. </p> <p>When column-binding, rows are matched by position, not value so all data frames must have the same number of rows. To match by value, not position, see <code>left_join</code> etc. When row-binding, columns are matched by name, and any values that don't match will be filled with NA.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>Data frames identifier. </p> <p>When <code>.id</code> is supplied, a new column of identifiers is created to link each row to its original data frame. The labels are taken from the named arguments to <code>bind_rows()</code>. When a list of data frames is supplied, the labels are taken from the names of the list. If no names are found a numeric sequence is used instead.</p> </td> </tr> </table> "	FALSE
"bind"	"dplyr"	"Efficiently bind multiple data frames by row and column."	"<p>This is an efficient implementation of the common pattern of <code>do.call(rbind, dfs)</code> or <code>do.call(cbind, dfs)</code> for binding many data frames into one. <code>combine()</code> acts like <code>c()</code> or <code>unlist()</code> but uses consistent dplyr coercion rules. </p>"	"<pre>bind_rows(..., .id = NULL)<br />bind_cols(...)<br />combine(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Data frames to combine. </p> <p>Each argument can either be a data frame, a list that could be a data frame, or a list of data frames. </p> <p>When column-binding, rows are matched by position, not value so all data frames must have the same number of rows. To match by value, not position, see <code>left_join</code> etc. When row-binding, columns are matched by name, and any values that don't match will be filled with NA.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>Data frames identifier. </p> <p>When <code>.id</code> is supplied, a new column of identifiers is created to link each row to its original data frame. The labels are taken from the named arguments to <code>bind_rows()</code>. When a list of data frames is supplied, the labels are taken from the names of the list. If no names are found a numeric sequence is used instead.</p> </td> </tr> </table> "	FALSE
"bind"	"dplyr"	"Efficiently bind multiple data frames by row and column."	"<p>This is an efficient implementation of the common pattern of <code>do.call(rbind, dfs)</code> or <code>do.call(cbind, dfs)</code> for binding many data frames into one. <code>combine()</code> acts like <code>c()</code> or <code>unlist()</code> but uses consistent dplyr coercion rules. </p>"	"<pre>bind_rows(..., .id = NULL)<br />bind_cols(...)<br />combine(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Data frames to combine. </p> <p>Each argument can either be a data frame, a list that could be a data frame, or a list of data frames. </p> <p>When column-binding, rows are matched by position, not value so all data frames must have the same number of rows. To match by value, not position, see <code>left_join</code> etc. When row-binding, columns are matched by name, and any values that don't match will be filled with NA.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>Data frames identifier. </p> <p>When <code>.id</code> is supplied, a new column of identifiers is created to link each row to its original data frame. The labels are taken from the named arguments to <code>bind_rows()</code>. When a list of data frames is supplied, the labels are taken from the names of the list. If no names are found a numeric sequence is used instead.</p> </td> </tr> </table> "	FALSE
"build_sql"	"dplyr"	"Build a SQL string."	"<p>This is a convenience function that should prevent sql injection attacks (which in the context of dplyr are most likely to be accidental not deliberate) by automatically escaping all expressions in the input, while treating bare strings as sql. This is unlikely to prevent any serious attack, but should make it unlikely that you produce invalid sql. </p>"	"<pre>build_sql(..., .env = parent.frame(), con = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>input to convert to SQL. Use <code>sql</code> to preserve user input as is (dangerous), and <code>ident</code> to label user input as sql identifiers (safe)</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>the environment in which to evalute the arguments. Should not be needed in typical use.</p> </td> </tr> <tr valign='top'> <td><code>con</code></td> <td> <p>database connection; used to select correct quoting characters.</p> </td> </tr> </table> "	FALSE
"case_when"	"dplyr"	"A general vectorised if."	"<p>This function allows you to vectorise mutiple <code>if</code> and <code>else if</code> statements. It is an R equivalent of the SQL <code>CASE WHEN</code> statement. </p>"	"<pre>case_when(...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>...</code></td> <td> <p>A sequence of two-sided formulas. The left hand side (LHS) determines which values match this case. The right hand side (RHS) provides the replacement value. </p> <p>The LHS must evaluate to a logical vector. Each logical vector can either have length 1 or a common length. All RHSs must evaluate to the same type of vector.</p> </td> </tr></table> "	FALSE
"location"	"dplyr"	"Print the location in memory of a data frame"	"<p>This is useful for understand how and when dplyr makes copies of data frames </p>"	"<pre>location(df)<br />changes(x, y) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>df</code></td> <td> <p>a data frame</p> </td> </tr> <tr valign='top'> <td><code>x, y</code></td> <td> <p>two data frames to compare</p> </td> </tr> </table> "	FALSE
"coalesce"	"dplyr"	"Find first non-missing element"	"<p>Given a set of vectors, <code>coelesce</code> finds the first non-missing value at each position. This is inspired by the SQL <code>COALESCE</code> function which does the same thing for <code>NULL</code>s. </p>"	"<pre>coalesce(x, ...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x, ...</code></td> <td> <p>Vectors. All inputs should either be length 1, or the same length as <code>x</code></p> </td> </tr></table> "	FALSE
"compute"	"dplyr"	"Compute a lazy tbl."	"<p><code>compute</code> forces computation of lazy tbls, leaving data in the remote source. <code>collect</code> also forces computation, but will bring data back into an R data.frame (stored in a <code>tbl_df</code>). <code>collapse</code> doesn't force computation, but collapses a complex tbl into a form that additional restrictions can be placed on. </p>"	"<pre>compute(x, name = random_table_name(), ...)<br />collect(x, ...)<br />collapse(x, ...)<br />## S3 method for class 'tbl_sql' compute(x, name = random_table_name(), temporary = TRUE,<br />   unique_indexes = list(), indexes = list(), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a data tbl</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>name of temporary table on database.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to methods</p> </td> </tr> <tr valign='top'> <td><code>temporary</code></td> <td> <p>if <code>TRUE</code>, will create a temporary table that is local to this connection and will be automatically deleted when the connection expires</p> </td> </tr> <tr valign='top'> <td><code>unique_indexes</code></td> <td> <p>a list of character vectors. Each element of the list will create a new unique index over the specified column(s). Duplicate rows will result in failure.</p> </td> </tr> <tr valign='top'> <td><code>indexes</code></td> <td> <p>a list of character vectors. Each element of the list will create a new index.</p> </td> </tr> </table> "	FALSE
"compute"	"dplyr"	"Compute a lazy tbl."	"<p><code>compute</code> forces computation of lazy tbls, leaving data in the remote source. <code>collect</code> also forces computation, but will bring data back into an R data.frame (stored in a <code>tbl_df</code>). <code>collapse</code> doesn't force computation, but collapses a complex tbl into a form that additional restrictions can be placed on. </p>"	"<pre>compute(x, name = random_table_name(), ...)<br />collect(x, ...)<br />collapse(x, ...)<br />## S3 method for class 'tbl_sql' compute(x, name = random_table_name(), temporary = TRUE,<br />   unique_indexes = list(), indexes = list(), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a data tbl</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>name of temporary table on database.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to methods</p> </td> </tr> <tr valign='top'> <td><code>temporary</code></td> <td> <p>if <code>TRUE</code>, will create a temporary table that is local to this connection and will be automatically deleted when the connection expires</p> </td> </tr> <tr valign='top'> <td><code>unique_indexes</code></td> <td> <p>a list of character vectors. Each element of the list will create a new unique index over the specified column(s). Duplicate rows will result in failure.</p> </td> </tr> <tr valign='top'> <td><code>indexes</code></td> <td> <p>a list of character vectors. Each element of the list will create a new index.</p> </td> </tr> </table> "	FALSE
"bind"	"dplyr"	"Efficiently bind multiple data frames by row and column."	"<p>This is an efficient implementation of the common pattern of <code>do.call(rbind, dfs)</code> or <code>do.call(cbind, dfs)</code> for binding many data frames into one. <code>combine()</code> acts like <code>c()</code> or <code>unlist()</code> but uses consistent dplyr coercion rules. </p>"	"<pre>bind_rows(..., .id = NULL)<br />bind_cols(...)<br />combine(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Data frames to combine. </p> <p>Each argument can either be a data frame, a list that could be a data frame, or a list of data frames. </p> <p>When column-binding, rows are matched by position, not value so all data frames must have the same number of rows. To match by value, not position, see <code>left_join</code> etc. When row-binding, columns are matched by name, and any values that don't match will be filled with NA.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>Data frames identifier. </p> <p>When <code>.id</code> is supplied, a new column of identifiers is created to link each row to its original data frame. The labels are taken from the named arguments to <code>bind_rows()</code>. When a list of data frames is supplied, the labels are taken from the names of the list. If no names are found a numeric sequence is used instead.</p> </td> </tr> </table> "	FALSE
"bench_compare"	"dplyr"	"Evaluate, compare, benchmark operations of a set of srcs."	"<p>These functions support the comparison of results and timings across multiple sources. </p>"	"<pre>bench_tbls(tbls, op, ..., times = 10)<br />compare_tbls(tbls, op, ref = NULL, compare = equal_data_frame, ...)<br />eval_tbls(tbls, op) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbls</code></td> <td> <p>A list of <code>tbl</code>s.</p> </td> </tr> <tr valign='top'> <td><code>op</code></td> <td> <p>A function with a single argument, called often with each element of <code>tbls</code>.</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>For benchmarking, the number of times each operation is repeated.</p> </td> </tr> <tr valign='top'> <td><code>ref</code></td> <td> <p>For checking, an data frame to test results against. If not supplied, defaults to the results from the first <code>src</code>.</p> </td> </tr> <tr valign='top'> <td><code>compare</code></td> <td> <p>A function used to compare the results. Defaults to <code>equal_data_frame</code> which ignores the order of rows and columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>For <code>compare_tbls</code>: additional parameters passed on the <code>compare</code> function </p> <p>For <code>bench_tbls</code>: additional benchmarks to run.</p> </td> </tr> </table> "	FALSE
"compute"	"dplyr"	"Compute a lazy tbl."	"<p><code>compute</code> forces computation of lazy tbls, leaving data in the remote source. <code>collect</code> also forces computation, but will bring data back into an R data.frame (stored in a <code>tbl_df</code>). <code>collapse</code> doesn't force computation, but collapses a complex tbl into a form that additional restrictions can be placed on. </p>"	"<pre>compute(x, name = random_table_name(), ...)<br />collect(x, ...)<br />collapse(x, ...)<br />## S3 method for class 'tbl_sql' compute(x, name = random_table_name(), temporary = TRUE,<br />   unique_indexes = list(), indexes = list(), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a data tbl</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>name of temporary table on database.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to methods</p> </td> </tr> <tr valign='top'> <td><code>temporary</code></td> <td> <p>if <code>TRUE</code>, will create a temporary table that is local to this connection and will be automatically deleted when the connection expires</p> </td> </tr> <tr valign='top'> <td><code>unique_indexes</code></td> <td> <p>a list of character vectors. Each element of the list will create a new unique index over the specified column(s). Duplicate rows will result in failure.</p> </td> </tr> <tr valign='top'> <td><code>indexes</code></td> <td> <p>a list of character vectors. Each element of the list will create a new index.</p> </td> </tr> </table> "	FALSE
"compute"	"dplyr"	"Compute a lazy tbl."	"<p><code>compute</code> forces computation of lazy tbls, leaving data in the remote source. <code>collect</code> also forces computation, but will bring data back into an R data.frame (stored in a <code>tbl_df</code>). <code>collapse</code> doesn't force computation, but collapses a complex tbl into a form that additional restrictions can be placed on. </p>"	"<pre>compute(x, name = random_table_name(), ...)<br />collect(x, ...)<br />collapse(x, ...)<br />## S3 method for class 'tbl_sql' compute(x, name = random_table_name(), temporary = TRUE,<br />   unique_indexes = list(), indexes = list(), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a data tbl</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>name of temporary table on database.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to methods</p> </td> </tr> <tr valign='top'> <td><code>temporary</code></td> <td> <p>if <code>TRUE</code>, will create a temporary table that is local to this connection and will be automatically deleted when the connection expires</p> </td> </tr> <tr valign='top'> <td><code>unique_indexes</code></td> <td> <p>a list of character vectors. Each element of the list will create a new unique index over the specified column(s). Duplicate rows will result in failure.</p> </td> </tr> <tr valign='top'> <td><code>indexes</code></td> <td> <p>a list of character vectors. Each element of the list will create a new index.</p> </td> </tr> </table> "	FALSE
"select_helpers"	"dplyr"	"Select helpers"	"<p>These functions allow you to select variables based on their names. </p> <ul> <li> <p><code>starts_with()</code>: starts with a prefix </p> </li> <li> <p><code>ends_with()</code>: ends with a prefix </p> </li> <li> <p><code>contains()</code>: contains a literal string </p> </li> <li> <p><code>matches()</code>: matches a regular expression </p> </li> <li> <p><code>num_range()</code>: a numerical range like x01, x02, x03. </p> </li> <li> <p><code>one_of()</code>: variables in character vector. </p> </li> <li> <p><code>everything()</code>: all variables. </p> </li> </ul> "	"<pre>current_vars()<br />starts_with(match, ignore.case = TRUE, vars = current_vars())<br />ends_with(match, ignore.case = TRUE, vars = current_vars())<br />contains(match, ignore.case = TRUE, vars = current_vars())<br />matches(match, ignore.case = TRUE, vars = current_vars())<br />num_range(prefix, range, width = NULL, vars = current_vars())<br />one_of(..., vars = current_vars())<br />everything(vars = current_vars()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>match</code></td> <td> <p>A string.</p> </td> </tr> <tr valign='top'> <td><code>ignore.case</code></td> <td> <p>If <code>TRUE</code>, the default, ignores case when matching names.</p> </td> </tr> <tr valign='top'> <td><code>vars</code></td> <td> <p>A character vector of variable names. When called from inside <code>select()</code> these are automatically set to the names of the table.</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>A prefix that starts the numeric range.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>A sequence of integers, like <code>1:5</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Optionally, the 'width' of the numeric range. For example, a range of 2 gives '01', a range of three '001', etc.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>One or more character vectors.</p> </td> </tr> </table> "	FALSE
"copy_to"	"dplyr"	"Copy a local data frame to a remote src."	"<p>This function uploads a local data frame into a remote data source, creating the table definition as needed. Wherever possible, the new object will be temporary, limited to the current connection to the source. </p>"	"<pre>copy_to(dest, df, name = deparse(substitute(df)), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>dest</code></td> <td> <p>remote data source</p> </td> </tr> <tr valign='top'> <td><code>df</code></td> <td> <p>local data frame</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>name for new remote table.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed to methods.</p> </td> </tr> </table> "	FALSE
"copy_to.src_sql"	"dplyr"	"Copy a local data frame to a sqlite src."	"<p>This standard method works for all sql sources. </p>"	"<pre>## S3 method for class 'src_sql' copy_to(dest, df, name = deparse(substitute(df)),<br />   types = NULL, temporary = TRUE, unique_indexes = NULL, indexes = NULL,<br />   analyze = TRUE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>dest</code></td> <td> <p>remote data source</p> </td> </tr> <tr valign='top'> <td><code>df</code></td> <td> <p>local data frame</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>name for new remote table.</p> </td> </tr> <tr valign='top'> <td><code>types</code></td> <td> <p>a character vector giving variable types to use for the columns. See <a href='http://www.sqlite.org/datatype3.html'>http://www.sqlite.org/datatype3.html</a> for available types.</p> </td> </tr> <tr valign='top'> <td><code>temporary</code></td> <td> <p>if <code>TRUE</code>, will create a temporary table that is local to this connection and will be automatically deleted when the connection expires</p> </td> </tr> <tr valign='top'> <td><code>unique_indexes</code></td> <td> <p>a list of character vectors. Each element of the list will create a new unique index over the specified column(s). Duplicate rows will result in failure.</p> </td> </tr> <tr valign='top'> <td><code>indexes</code></td> <td> <p>a list of character vectors. Each element of the list will create a new index.</p> </td> </tr> <tr valign='top'> <td><code>analyze</code></td> <td> <p>if <code>TRUE</code> (the default), will automatically ANALYZE the new table so that the query optimiser has useful information.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed to methods.</p> </td> </tr> </table> "	FALSE
"tally"	"dplyr"	"Counts/tally observations by group."	"<p><code>tally</code> is a convenient wrapper for summarise that will either call <code>n</code> or <code>sum(n)</code> depending on whether you're tallying for the first time, or re-tallying. <code>count()</code> is similar, but also does the <code>group_by</code> for you. </p>"	"<pre>tally(x, wt, sort = FALSE)<br />count(x, ..., wt = NULL, sort = FALSE)<br />count_(x, vars, wt = NULL, sort = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a <code>tbl</code> to tally/count.</p> </td> </tr> <tr valign='top'> <td><code>wt</code></td> <td> <p>(Optional) If omitted, will count the number of rows. If specified, will perform a 'weighted' tally by summing the (non-missing) values of variable <code>wt</code>.</p> </td> </tr> <tr valign='top'> <td><code>sort</code></td> <td> <p>if <code>TRUE</code> will sort output in descending order of <code>n</code></p> </td> </tr> <tr valign='top'> <td><code>..., vars</code></td> <td> <p>Variables to group by.</p> </td> </tr> </table> "	FALSE
"tally"	"dplyr"	"Counts/tally observations by group."	"<p><code>tally</code> is a convenient wrapper for summarise that will either call <code>n</code> or <code>sum(n)</code> depending on whether you're tallying for the first time, or re-tallying. <code>count()</code> is similar, but also does the <code>group_by</code> for you. </p>"	"<pre>tally(x, wt, sort = FALSE)<br />count(x, ..., wt = NULL, sort = FALSE)<br />count_(x, vars, wt = NULL, sort = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a <code>tbl</code> to tally/count.</p> </td> </tr> <tr valign='top'> <td><code>wt</code></td> <td> <p>(Optional) If omitted, will count the number of rows. If specified, will perform a 'weighted' tally by summing the (non-missing) values of variable <code>wt</code>.</p> </td> </tr> <tr valign='top'> <td><code>sort</code></td> <td> <p>if <code>TRUE</code> will sort output in descending order of <code>n</code></p> </td> </tr> <tr valign='top'> <td><code>..., vars</code></td> <td> <p>Variables to group by.</p> </td> </tr> </table> "	FALSE
"cumall"	"dplyr"	"Cumulativate versions of any, all, and mean"	"<p>dplyr adds <code>cumall</code>, <code>cumany</code>, and <code>cummean</code> to complete R's set of cumulate functions to match the aggregation functions available in most databases </p>"	"<pre>cumall(x)<br />cumany(x)<br />cummean(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>For <code>cumall</code> &amp; <code>cumany</code>, a logical vector; for <code>cummean</code> an integer or numeric vector</p> </td> </tr></table>"	FALSE
"cumall"	"dplyr"	"Cumulativate versions of any, all, and mean"	"<p>dplyr adds <code>cumall</code>, <code>cumany</code>, and <code>cummean</code> to complete R's set of cumulate functions to match the aggregation functions available in most databases </p>"	"<pre>cumall(x)<br />cumany(x)<br />cummean(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>For <code>cumall</code> &amp; <code>cumany</code>, a logical vector; for <code>cummean</code> an integer or numeric vector</p> </td> </tr></table>"	FALSE
"ranking"	"dplyr"	"Windowed rank functions."	"<p>Six variations on ranking functions, mimicing the ranking functions described in SQL2003. They are currently implemented using the built in <code>rank</code> function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use <code>desc</code> to reverse the direction.. </p>"	"<pre>row_number(x)<br />ntile(x, n)<br />min_rank(x)<br />dense_rank(x)<br />percent_rank(x)<br />cume_dist(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of values to rank. Missing values are left as is. If you want to treat them as the smallest or largest values, replace with Inf or -Inf before ranking.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of groups to split up into.</p> </td> </tr> </table> "	FALSE
"cumall"	"dplyr"	"Cumulativate versions of any, all, and mean"	"<p>dplyr adds <code>cumall</code>, <code>cumany</code>, and <code>cummean</code> to complete R's set of cumulate functions to match the aggregation functions available in most databases </p>"	"<pre>cumall(x)<br />cumany(x)<br />cummean(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>For <code>cumall</code> &amp; <code>cumany</code>, a logical vector; for <code>cummean</code> an integer or numeric vector</p> </td> </tr></table>"	FALSE
"select_helpers"	"dplyr"	"Select helpers"	"<p>These functions allow you to select variables based on their names. </p> <ul> <li> <p><code>starts_with()</code>: starts with a prefix </p> </li> <li> <p><code>ends_with()</code>: ends with a prefix </p> </li> <li> <p><code>contains()</code>: contains a literal string </p> </li> <li> <p><code>matches()</code>: matches a regular expression </p> </li> <li> <p><code>num_range()</code>: a numerical range like x01, x02, x03. </p> </li> <li> <p><code>one_of()</code>: variables in character vector. </p> </li> <li> <p><code>everything()</code>: all variables. </p> </li> </ul> "	"<pre>current_vars()<br />starts_with(match, ignore.case = TRUE, vars = current_vars())<br />ends_with(match, ignore.case = TRUE, vars = current_vars())<br />contains(match, ignore.case = TRUE, vars = current_vars())<br />matches(match, ignore.case = TRUE, vars = current_vars())<br />num_range(prefix, range, width = NULL, vars = current_vars())<br />one_of(..., vars = current_vars())<br />everything(vars = current_vars()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>match</code></td> <td> <p>A string.</p> </td> </tr> <tr valign='top'> <td><code>ignore.case</code></td> <td> <p>If <code>TRUE</code>, the default, ignores case when matching names.</p> </td> </tr> <tr valign='top'> <td><code>vars</code></td> <td> <p>A character vector of variable names. When called from inside <code>select()</code> these are automatically set to the names of the table.</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>A prefix that starts the numeric range.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>A sequence of integers, like <code>1:5</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Optionally, the 'width' of the numeric range. For example, a range of 2 gives '01', a range of three '001', etc.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>One or more character vectors.</p> </td> </tr> </table> "	FALSE
"src-test"	"dplyr"	"A set of DBI methods to ease unit testing dplyr with DBI"	"<p>A set of DBI methods to ease unit testing dplyr with DBI </p>"	"<pre>## S3 method for class 'DBITestConnection' db_query_fields(con, sql, ...)<br />## S3 method for class 'DBITestConnection' sql_escape_ident(con, x)<br />## S3 method for class 'DBITestConnection' sql_translate_env(con) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>con</code></td> <td> <p>A database connection.</p> </td> </tr> <tr valign='top'> <td><code>sql</code></td> <td> <p>A string containing an sql query.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to the individual methods</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to transform</p> </td> </tr> </table>"	FALSE
"ranking"	"dplyr"	"Windowed rank functions."	"<p>Six variations on ranking functions, mimicing the ranking functions described in SQL2003. They are currently implemented using the built in <code>rank</code> function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use <code>desc</code> to reverse the direction.. </p>"	"<pre>row_number(x)<br />ntile(x, n)<br />min_rank(x)<br />dense_rank(x)<br />percent_rank(x)<br />cume_dist(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of values to rank. Missing values are left as is. If you want to treat them as the smallest or largest values, replace with Inf or -Inf before ranking.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of groups to split up into.</p> </td> </tr> </table> "	FALSE
"desc"	"dplyr"	"Descending order."	"<p>Transform a vector into a format that will be sorted in descending order. </p>"	"<pre>desc(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>vector to transform</p> </td> </tr></table> "	FALSE
"distinct"	"dplyr"	"Select distinct/unique rows."	"<p>Retain only unique/distinct rows from an input tbl. This is similar to <code>unique.data.frame</code>, but considerably faster. </p>"	"<pre>distinct(.data, ..., .keep_all = FALSE)<br />distinct_(.data, ..., .dots, .keep_all = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Optional variables to use when determining uniqueness. If there are multiple rows for a given combination of inputs, only the first row will be preserved. If omitted, will use all variables.</p> </td> </tr> <tr valign='top'> <td><code>.keep_all</code></td> <td> <p>If <code>TRUE</code>, keep all variables in <code>.data</code>. If a combination of <code>...</code> is not distinct, this keeps the first row of values.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"distinct"	"dplyr"	"Select distinct/unique rows."	"<p>Retain only unique/distinct rows from an input tbl. This is similar to <code>unique.data.frame</code>, but considerably faster. </p>"	"<pre>distinct(.data, ..., .keep_all = FALSE)<br />distinct_(.data, ..., .dots, .keep_all = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Optional variables to use when determining uniqueness. If there are multiple rows for a given combination of inputs, only the first row will be preserved. If omitted, will use all variables.</p> </td> </tr> <tr valign='top'> <td><code>.keep_all</code></td> <td> <p>If <code>TRUE</code>, keep all variables in <code>.data</code>. If a combination of <code>...</code> is not distinct, this keeps the first row of values.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"do"	"dplyr"	"Do arbitrary operations on a tbl."	"<p>This is a general purpose complement to the specialised manipulation functions <code>filter</code>, <code>select</code>, <code>mutate</code>, <code>summarise</code> and <code>arrange</code>. You can use <code>do</code> to perform arbitrary computation, returning either a data frame or arbitrary objects which will be stored in a list. This is particularly useful when working with models: you can fit models per group with <code>do</code> and then flexibly extract components with either another <code>do</code> or <code>summarise</code>. </p>"	"<pre>do(.data, ...)<br />do_(.data, ..., .dots)<br />## S3 method for class 'tbl_sql' do_(.data, ..., .dots, .chunk_size = 10000L) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Expressions to apply to each group. If named, results will be stored in a new column. If unnamed, should return a data frame. You can use <code>.</code> to refer to the current group. You can not mix named and unnamed arguments.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> <tr valign='top'> <td><code>.chunk_size</code></td> <td> <p>The size of each chunk to pull into R. If this number is too big, the process will be slow because R has to allocate and free a lot of memory. If it's too small, it will be slow, because of the overhead of talking to the database.</p> </td> </tr> </table> "	FALSE
"do"	"dplyr"	"Do arbitrary operations on a tbl."	"<p>This is a general purpose complement to the specialised manipulation functions <code>filter</code>, <code>select</code>, <code>mutate</code>, <code>summarise</code> and <code>arrange</code>. You can use <code>do</code> to perform arbitrary computation, returning either a data frame or arbitrary objects which will be stored in a list. This is particularly useful when working with models: you can fit models per group with <code>do</code> and then flexibly extract components with either another <code>do</code> or <code>summarise</code>. </p>"	"<pre>do(.data, ...)<br />do_(.data, ..., .dots)<br />## S3 method for class 'tbl_sql' do_(.data, ..., .dots, .chunk_size = 10000L) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Expressions to apply to each group. If named, results will be stored in a new column. If unnamed, should return a data frame. You can use <code>.</code> to refer to the current group. You can not mix named and unnamed arguments.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> <tr valign='top'> <td><code>.chunk_size</code></td> <td> <p>The size of each chunk to pull into R. If this number is too big, the process will be slow because R has to allocate and free a lot of memory. If it's too small, it will be slow, because of the overhead of talking to the database.</p> </td> </tr> </table> "	FALSE
"do"	"dplyr"	"Do arbitrary operations on a tbl."	"<p>This is a general purpose complement to the specialised manipulation functions <code>filter</code>, <code>select</code>, <code>mutate</code>, <code>summarise</code> and <code>arrange</code>. You can use <code>do</code> to perform arbitrary computation, returning either a data frame or arbitrary objects which will be stored in a list. This is particularly useful when working with models: you can fit models per group with <code>do</code> and then flexibly extract components with either another <code>do</code> or <code>summarise</code>. </p>"	"<pre>do(.data, ...)<br />do_(.data, ..., .dots)<br />## S3 method for class 'tbl_sql' do_(.data, ..., .dots, .chunk_size = 10000L) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Expressions to apply to each group. If named, results will be stored in a new column. If unnamed, should return a data frame. You can use <code>.</code> to refer to the current group. You can not mix named and unnamed arguments.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> <tr valign='top'> <td><code>.chunk_size</code></td> <td> <p>The size of each chunk to pull into R. If this number is too big, the process will be slow because R has to allocate and free a lot of memory. If it's too small, it will be slow, because of the overhead of talking to the database.</p> </td> </tr> </table> "	FALSE
"dplyr"	"dplyr"	"dplyr: a grammar of data manipulation"	"<p>dplyr provides a flexible grammar of data manipulation. It's the next iteration of plyr, focused on tools for working with data frames (hence the <em>d</em> in the name). </p>"	NA	NA	FALSE
"select_helpers"	"dplyr"	"Select helpers"	"<p>These functions allow you to select variables based on their names. </p> <ul> <li> <p><code>starts_with()</code>: starts with a prefix </p> </li> <li> <p><code>ends_with()</code>: ends with a prefix </p> </li> <li> <p><code>contains()</code>: contains a literal string </p> </li> <li> <p><code>matches()</code>: matches a regular expression </p> </li> <li> <p><code>num_range()</code>: a numerical range like x01, x02, x03. </p> </li> <li> <p><code>one_of()</code>: variables in character vector. </p> </li> <li> <p><code>everything()</code>: all variables. </p> </li> </ul> "	"<pre>current_vars()<br />starts_with(match, ignore.case = TRUE, vars = current_vars())<br />ends_with(match, ignore.case = TRUE, vars = current_vars())<br />contains(match, ignore.case = TRUE, vars = current_vars())<br />matches(match, ignore.case = TRUE, vars = current_vars())<br />num_range(prefix, range, width = NULL, vars = current_vars())<br />one_of(..., vars = current_vars())<br />everything(vars = current_vars()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>match</code></td> <td> <p>A string.</p> </td> </tr> <tr valign='top'> <td><code>ignore.case</code></td> <td> <p>If <code>TRUE</code>, the default, ignores case when matching names.</p> </td> </tr> <tr valign='top'> <td><code>vars</code></td> <td> <p>A character vector of variable names. When called from inside <code>select()</code> these are automatically set to the names of the table.</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>A prefix that starts the numeric range.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>A sequence of integers, like <code>1:5</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Optionally, the 'width' of the numeric range. For example, a range of 2 gives '01', a range of three '001', etc.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>One or more character vectors.</p> </td> </tr> </table> "	FALSE
"bench_compare"	"dplyr"	"Evaluate, compare, benchmark operations of a set of srcs."	"<p>These functions support the comparison of results and timings across multiple sources. </p>"	"<pre>bench_tbls(tbls, op, ..., times = 10)<br />compare_tbls(tbls, op, ref = NULL, compare = equal_data_frame, ...)<br />eval_tbls(tbls, op) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbls</code></td> <td> <p>A list of <code>tbl</code>s.</p> </td> </tr> <tr valign='top'> <td><code>op</code></td> <td> <p>A function with a single argument, called often with each element of <code>tbls</code>.</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>For benchmarking, the number of times each operation is repeated.</p> </td> </tr> <tr valign='top'> <td><code>ref</code></td> <td> <p>For checking, an data frame to test results against. If not supplied, defaults to the results from the first <code>src</code>.</p> </td> </tr> <tr valign='top'> <td><code>compare</code></td> <td> <p>A function used to compare the results. Defaults to <code>equal_data_frame</code> which ignores the order of rows and columns.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>For <code>compare_tbls</code>: additional parameters passed on the <code>compare</code> function </p> <p>For <code>bench_tbls</code>: additional benchmarks to run.</p> </td> </tr> </table> "	FALSE
"select_helpers"	"dplyr"	"Select helpers"	"<p>These functions allow you to select variables based on their names. </p> <ul> <li> <p><code>starts_with()</code>: starts with a prefix </p> </li> <li> <p><code>ends_with()</code>: ends with a prefix </p> </li> <li> <p><code>contains()</code>: contains a literal string </p> </li> <li> <p><code>matches()</code>: matches a regular expression </p> </li> <li> <p><code>num_range()</code>: a numerical range like x01, x02, x03. </p> </li> <li> <p><code>one_of()</code>: variables in character vector. </p> </li> <li> <p><code>everything()</code>: all variables. </p> </li> </ul> "	"<pre>current_vars()<br />starts_with(match, ignore.case = TRUE, vars = current_vars())<br />ends_with(match, ignore.case = TRUE, vars = current_vars())<br />contains(match, ignore.case = TRUE, vars = current_vars())<br />matches(match, ignore.case = TRUE, vars = current_vars())<br />num_range(prefix, range, width = NULL, vars = current_vars())<br />one_of(..., vars = current_vars())<br />everything(vars = current_vars()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>match</code></td> <td> <p>A string.</p> </td> </tr> <tr valign='top'> <td><code>ignore.case</code></td> <td> <p>If <code>TRUE</code>, the default, ignores case when matching names.</p> </td> </tr> <tr valign='top'> <td><code>vars</code></td> <td> <p>A character vector of variable names. When called from inside <code>select()</code> these are automatically set to the names of the table.</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>A prefix that starts the numeric range.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>A sequence of integers, like <code>1:5</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Optionally, the 'width' of the numeric range. For example, a range of 2 gives '01', a range of three '001', etc.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>One or more character vectors.</p> </td> </tr> </table> "	FALSE
"explain"	"dplyr"	"Explain details of a tbl."	"<p>This is a generic function which gives more details about an object than <code>print</code>, and is more focussed on human readable output than <code>str</code>. </p>"	"<pre>explain(x, ...)<br />show_query(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object to explain</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other parameters possibly used by generic</p> </td> </tr> </table> "	FALSE
"failwith"	"dplyr"	"Fail with specified value."	"<p>Modify a function so that it returns a default value when there is an error. </p>"	"<pre>failwith(default = NULL, f, quiet = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>default</code></td> <td> <p>default value</p> </td> </tr> <tr valign='top'> <td><code>f</code></td> <td> <p>function</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>all error messages be suppressed?</p> </td> </tr> </table> "	FALSE
"filter"	"dplyr"	"Return rows with matching conditions."	"<p>Return rows with matching conditions. </p>"	"<pre>filter(.data, ...)<br />filter_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Logical predicates. Multiple conditions are combined with <code>&amp;</code>.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"filter"	"dplyr"	"Return rows with matching conditions."	"<p>Return rows with matching conditions. </p>"	"<pre>filter(.data, ...)<br />filter_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Logical predicates. Multiple conditions are combined with <code>&amp;</code>.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"nth"	"dplyr"	"Extract the first, last or nth value from a vector."	"<p>These are straightforward wrappers around <code>[[</code>. The main advantage is that you can provide an optional secondary vector that defines the ordering, and provide a default value to use when the input is shorter than expected. </p>"	"<pre>nth(x, n, order_by = NULL, default = default_missing(x))<br />first(x, order_by = NULL, default = default_missing(x))<br />last(x, order_by = NULL, default = default_missing(x)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A vector</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>For <code>nth_value</code>, a single integer specifying the position. Negative integers index from the end (i.e. <code>-1L</code> will return the last value in the vector). </p> <p>If a double is supplied, it will be silently truncated.</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>An optional vector used to determine the order</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>A default value to use if the position does not exist in the input. This is guessed by default for atomic vectors, where a missing value of the appropriate type is return, and for lists, where a <code>NULL</code> is return. For more complicated objects, you'll need to supply this value.</p> </td> </tr> </table> "	FALSE
"join"	"dplyr"	"Join two tbls together."	"<p>These are generic functions that dispatch to individual tbl methods - see the method documentation for details of individual data sources. <code>x</code> and <code>y</code> should usually be from the same data source, but if <code>copy</code> is <code>TRUE</code>, <code>y</code> will automatically be copied to the same source as <code>x</code> - this may be an expensive operation. </p>"	"<pre>inner_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />right_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />semi_join(x, y, by = NULL, copy = FALSE, ...)<br />anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"join.tbl_df"	"dplyr"	"Join data frame tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_df' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' semi_join(x, y, by = NULL, copy = FALSE, ...)<br />## S3 method for class 'tbl_df' anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>included for compatibility with the generic; otherwise ignored.</p> </td> </tr> </table> "	FALSE
"join.tbl_sql"	"dplyr"	"Join sql tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_lazy' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' left_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' full_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' semi_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' anti_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into a temporary table in same database as <code>x</code>. <code>join</code> will automatically run <code>ANALYZE</code> on the created table in the hope that this will make you queries as efficient as possible by giving more data to the query planner. </p> <p>This allows you to join tables across srcs, but it's potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>auto_index</code></td> <td> <p>if <code>copy</code> is <code>TRUE</code>, automatically create indices for the variables in <code>by</code>. This may speed up the join if there are matching indexes in <code>x</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"funs"	"dplyr"	"Create a list of functions calls."	"<p><code>funs</code> provides a flexible way to generate a named list of functions for input to other functions like <code>summarise_each</code>. </p>"	"<pre>funs(...)<br />funs_(dots, args = list(), env = baseenv()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>dots, ...</code></td> <td> <p>A list of functions specified by: </p><br /><ul> <li> <p> Their name, <code>'mean'</code> </p> </li> <li> <p> The function itself, <code>mean</code> </p> </li> <li> <p> A call to the function with <code>.</code> as a dummy parameter, <code>mean(., na.rm = TRUE)</code> </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>args</code></td> <td> <p>A named list of additional arguments to be added to all function calls.</p> </td> </tr> <tr valign='top'> <td><code>env</code></td> <td> <p>The environment in which functions should be evaluated.</p> </td> </tr> </table> "	FALSE
"funs"	"dplyr"	"Create a list of functions calls."	"<p><code>funs</code> provides a flexible way to generate a named list of functions for input to other functions like <code>summarise_each</code>. </p>"	"<pre>funs(...)<br />funs_(dots, args = list(), env = baseenv()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>dots, ...</code></td> <td> <p>A list of functions specified by: </p><br /><ul> <li> <p> Their name, <code>'mean'</code> </p> </li> <li> <p> The function itself, <code>mean</code> </p> </li> <li> <p> A call to the function with <code>.</code> as a dummy parameter, <code>mean(., na.rm = TRUE)</code> </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>args</code></td> <td> <p>A named list of additional arguments to be added to all function calls.</p> </td> </tr> <tr valign='top'> <td><code>env</code></td> <td> <p>The environment in which functions should be evaluated.</p> </td> </tr> </table> "	FALSE
"groups"	"dplyr"	"Get/set the grouping variables for tbl."	"<p>These functions do not perform non-standard evaluation, and so are useful when programming against <code>tbl</code> objects. <code>ungroup</code> is a convenient inline way of removing existing grouping. </p>"	"<pre>groups(x)<br />ungroup(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>data <code>tbl</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments that maybe used by methods.</p> </td> </tr> </table> "	FALSE
"group_by"	"dplyr"	"Group a tbl by one or more variables."	"<p>Most data operations are useful done on groups defined by variables in the the dataset. The <code>group_by</code> function takes an existing tbl and converts it into a grouped tbl where operations are performed 'by group'. </p>"	"<pre>group_by(.data, ..., add = FALSE)<br />group_by_(.data, ..., .dots, add = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>variables to group by. All tbls accept variable names, some will also accept functions of variables. Duplicated groups will be silently dropped.</p> </td> </tr> <tr valign='top'> <td><code>add</code></td> <td> <p>By default, when <code>add = FALSE</code>, <code>group_by</code> will override existing groups. To instead add to the existing groups, use <code>add = TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"group_by"	"dplyr"	"Group a tbl by one or more variables."	"<p>Most data operations are useful done on groups defined by variables in the the dataset. The <code>group_by</code> function takes an existing tbl and converts it into a grouped tbl where operations are performed 'by group'. </p>"	"<pre>group_by(.data, ..., add = FALSE)<br />group_by_(.data, ..., .dots, add = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>variables to group by. All tbls accept variable names, some will also accept functions of variables. Duplicated groups will be silently dropped.</p> </td> </tr> <tr valign='top'> <td><code>add</code></td> <td> <p>By default, when <code>add = FALSE</code>, <code>group_by</code> will override existing groups. To instead add to the existing groups, use <code>add = TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"group_indices"	"dplyr"	"Group id."	"<p>Generate a unique id for each group </p>"	"<pre>group_indices(.data, ...)<br />group_indices_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>variables to group by. All tbls accept variable names, some will also accept functions of variables. Duplicated groups will be silently dropped.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"group_indices"	"dplyr"	"Group id."	"<p>Generate a unique id for each group </p>"	"<pre>group_indices(.data, ...)<br />group_indices_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>variables to group by. All tbls accept variable names, some will also accept functions of variables. Duplicated groups will be silently dropped.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"group_size"	"dplyr"	"Calculate group sizes."	"<p>Calculate group sizes. </p>"	"<pre>group_size(x)<br />n_groups(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>a grouped tbl</p> </td> </tr></table> "	FALSE
"if_else"	"dplyr"	"Vectorised if."	"<p>Compared to the base <code>ifelse()</code>, this function is more strict. It checks that <code>true</code> and <code>false</code> are the same type. This strictness makes the output type more predictable, and makes it somewhat faster. </p>"	"<pre>if_else(condition, true, false, missing = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>condition</code></td> <td> <p>Logical vector</p> </td> </tr> <tr valign='top'> <td><code>true, false</code></td> <td> <p>Values to use for <code>TRUE</code> and <code>FALSE</code> values of <code>condition</code>. They must be either the same length as <code>condition</code>, or length 1. They must also be the same type: <code>if_else</code> checks that they have the same type and same class. All other attributes are taken from <code>true</code>.</p> </td> </tr> <tr valign='top'> <td><code>missing</code></td> <td> <p>If not <code>NULL</code>, will be used to replace missing values.</p> </td> </tr> </table> "	FALSE
"join"	"dplyr"	"Join two tbls together."	"<p>These are generic functions that dispatch to individual tbl methods - see the method documentation for details of individual data sources. <code>x</code> and <code>y</code> should usually be from the same data source, but if <code>copy</code> is <code>TRUE</code>, <code>y</code> will automatically be copied to the same source as <code>x</code> - this may be an expensive operation. </p>"	"<pre>inner_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />right_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />semi_join(x, y, by = NULL, copy = FALSE, ...)<br />anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"join.tbl_df"	"dplyr"	"Join data frame tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_df' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' semi_join(x, y, by = NULL, copy = FALSE, ...)<br />## S3 method for class 'tbl_df' anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>included for compatibility with the generic; otherwise ignored.</p> </td> </tr> </table> "	FALSE
"join.tbl_sql"	"dplyr"	"Join sql tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_lazy' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' left_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' full_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' semi_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' anti_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into a temporary table in same database as <code>x</code>. <code>join</code> will automatically run <code>ANALYZE</code> on the created table in the hope that this will make you queries as efficient as possible by giving more data to the query planner. </p> <p>This allows you to join tables across srcs, but it's potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>auto_index</code></td> <td> <p>if <code>copy</code> is <code>TRUE</code>, automatically create indices for the variables in <code>by</code>. This may speed up the join if there are matching indexes in <code>x</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"setops"	"dplyr"	"Set operations."	"<p>These functions override the set functions provided in base to make them generic so that efficient versions for data frames and other tables can be provided. The default methods call the base versions. </p>"	"<pre>intersect(x, y, ...)<br />union(x, y, ...)<br />union_all(x, y, ...)<br />setdiff(x, y, ...)<br />setequal(x, y, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>objects to perform set function on (ignoring order)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to methods</p> </td> </tr> </table> "	FALSE
"tbl"	"dplyr"	"Create a table from a data source"	"<p>This is a generic method that dispatches based on the first argument. </p>"	"<pre>tbl(src, ...)<br />is.tbl(x)<br />as.tbl(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>src</code></td> <td> <p>A data source</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to the individual methods</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an object to coerce to a <code>tbl</code></p> </td> </tr> </table>"	FALSE
"join"	"dplyr"	"Join two tbls together."	"<p>These are generic functions that dispatch to individual tbl methods - see the method documentation for details of individual data sources. <code>x</code> and <code>y</code> should usually be from the same data source, but if <code>copy</code> is <code>TRUE</code>, <code>y</code> will automatically be copied to the same source as <code>x</code> - this may be an expensive operation. </p>"	"<pre>inner_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />right_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />semi_join(x, y, by = NULL, copy = FALSE, ...)<br />anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"join.tbl_df"	"dplyr"	"Join data frame tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_df' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' semi_join(x, y, by = NULL, copy = FALSE, ...)<br />## S3 method for class 'tbl_df' anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>included for compatibility with the generic; otherwise ignored.</p> </td> </tr> </table> "	FALSE
"join.tbl_sql"	"dplyr"	"Join sql tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_lazy' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' left_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' full_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' semi_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' anti_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into a temporary table in same database as <code>x</code>. <code>join</code> will automatically run <code>ANALYZE</code> on the created table in the hope that this will make you queries as efficient as possible by giving more data to the query planner. </p> <p>This allows you to join tables across srcs, but it's potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>auto_index</code></td> <td> <p>if <code>copy</code> is <code>TRUE</code>, automatically create indices for the variables in <code>by</code>. This may speed up the join if there are matching indexes in <code>x</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"lead-lag"	"dplyr"	"Lead and lag."	"<p>Lead and lag are useful for comparing values offset by a constant (e.g. the previous or next value) </p>"	"<pre>lead(x, n = 1L, default = NA, order_by = NULL, ...)<br />lag(x, n = 1L, default = NA, order_by = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of values</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>a postive integer of length 1, giving the number of positions to lead or lag by</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>value used for non-existant rows. Defaults to <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>override the default ordering to use another vector</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Needed for compatibility with lag generic.</p> </td> </tr> </table> "	FALSE
"nth"	"dplyr"	"Extract the first, last or nth value from a vector."	"<p>These are straightforward wrappers around <code>[[</code>. The main advantage is that you can provide an optional secondary vector that defines the ordering, and provide a default value to use when the input is shorter than expected. </p>"	"<pre>nth(x, n, order_by = NULL, default = default_missing(x))<br />first(x, order_by = NULL, default = default_missing(x))<br />last(x, order_by = NULL, default = default_missing(x)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A vector</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>For <code>nth_value</code>, a single integer specifying the position. Negative integers index from the end (i.e. <code>-1L</code> will return the last value in the vector). </p> <p>If a double is supplied, it will be silently truncated.</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>An optional vector used to determine the order</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>A default value to use if the position does not exist in the input. This is guessed by default for atomic vectors, where a missing value of the appropriate type is return, and for lists, where a <code>NULL</code> is return. For more complicated objects, you'll need to supply this value.</p> </td> </tr> </table> "	FALSE
"lead-lag"	"dplyr"	"Lead and lag."	"<p>Lead and lag are useful for comparing values offset by a constant (e.g. the previous or next value) </p>"	"<pre>lead(x, n = 1L, default = NA, order_by = NULL, ...)<br />lag(x, n = 1L, default = NA, order_by = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of values</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>a postive integer of length 1, giving the number of positions to lead or lag by</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>value used for non-existant rows. Defaults to <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>override the default ordering to use another vector</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Needed for compatibility with lag generic.</p> </td> </tr> </table> "	FALSE
"lead-lag"	"dplyr"	"Lead and lag."	"<p>Lead and lag are useful for comparing values offset by a constant (e.g. the previous or next value) </p>"	"<pre>lead(x, n = 1L, default = NA, order_by = NULL, ...)<br />lag(x, n = 1L, default = NA, order_by = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of values</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>a postive integer of length 1, giving the number of positions to lead or lag by</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>value used for non-existant rows. Defaults to <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>override the default ordering to use another vector</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Needed for compatibility with lag generic.</p> </td> </tr> </table> "	FALSE
"join"	"dplyr"	"Join two tbls together."	"<p>These are generic functions that dispatch to individual tbl methods - see the method documentation for details of individual data sources. <code>x</code> and <code>y</code> should usually be from the same data source, but if <code>copy</code> is <code>TRUE</code>, <code>y</code> will automatically be copied to the same source as <code>x</code> - this may be an expensive operation. </p>"	"<pre>inner_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />right_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />semi_join(x, y, by = NULL, copy = FALSE, ...)<br />anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"join.tbl_df"	"dplyr"	"Join data frame tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_df' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' semi_join(x, y, by = NULL, copy = FALSE, ...)<br />## S3 method for class 'tbl_df' anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>included for compatibility with the generic; otherwise ignored.</p> </td> </tr> </table> "	FALSE
"join.tbl_sql"	"dplyr"	"Join sql tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_lazy' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' left_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' full_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' semi_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' anti_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into a temporary table in same database as <code>x</code>. <code>join</code> will automatically run <code>ANALYZE</code> on the created table in the hope that this will make you queries as efficient as possible by giving more data to the query planner. </p> <p>This allows you to join tables across srcs, but it's potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>auto_index</code></td> <td> <p>if <code>copy</code> is <code>TRUE</code>, automatically create indices for the variables in <code>by</code>. This may speed up the join if there are matching indexes in <code>x</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"location"	"dplyr"	"Print the location in memory of a data frame"	"<p>This is useful for understand how and when dplyr makes copies of data frames </p>"	"<pre>location(df)<br />changes(x, y) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>df</code></td> <td> <p>a data frame</p> </td> </tr> <tr valign='top'> <td><code>x, y</code></td> <td> <p>two data frames to compare</p> </td> </tr> </table> "	FALSE
"select_helpers"	"dplyr"	"Select helpers"	"<p>These functions allow you to select variables based on their names. </p> <ul> <li> <p><code>starts_with()</code>: starts with a prefix </p> </li> <li> <p><code>ends_with()</code>: ends with a prefix </p> </li> <li> <p><code>contains()</code>: contains a literal string </p> </li> <li> <p><code>matches()</code>: matches a regular expression </p> </li> <li> <p><code>num_range()</code>: a numerical range like x01, x02, x03. </p> </li> <li> <p><code>one_of()</code>: variables in character vector. </p> </li> <li> <p><code>everything()</code>: all variables. </p> </li> </ul> "	"<pre>current_vars()<br />starts_with(match, ignore.case = TRUE, vars = current_vars())<br />ends_with(match, ignore.case = TRUE, vars = current_vars())<br />contains(match, ignore.case = TRUE, vars = current_vars())<br />matches(match, ignore.case = TRUE, vars = current_vars())<br />num_range(prefix, range, width = NULL, vars = current_vars())<br />one_of(..., vars = current_vars())<br />everything(vars = current_vars()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>match</code></td> <td> <p>A string.</p> </td> </tr> <tr valign='top'> <td><code>ignore.case</code></td> <td> <p>If <code>TRUE</code>, the default, ignores case when matching names.</p> </td> </tr> <tr valign='top'> <td><code>vars</code></td> <td> <p>A character vector of variable names. When called from inside <code>select()</code> these are automatically set to the names of the table.</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>A prefix that starts the numeric range.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>A sequence of integers, like <code>1:5</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Optionally, the 'width' of the numeric range. For example, a range of 2 gives '01', a range of three '001', etc.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>One or more character vectors.</p> </td> </tr> </table> "	FALSE
"src_memdb"	"dplyr"	"Per-session in-memory SQLite databases."	"<p><code>src_memdb</code> lets you easily access a sessio-temporary in-memory SQLite database. <code>memdb_frame()</code> works like <code>data_frame</code>, but instead of creating a new data frame in R, it creates a table in <code>src_memdb</code> </p>"	"<pre>src_memdb()<br />memdb_frame(..., .name = random_table_name()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A set of name-value pairs. Arguments are evaluated sequentially, so you can refer to previously created variables.</p> </td> </tr> <tr valign='top'> <td><code>.name</code></td> <td> <p>Name of table in database: defaults to a random name that's unlikely to conflict with exist</p> </td> </tr> </table> "	FALSE
"ranking"	"dplyr"	"Windowed rank functions."	"<p>Six variations on ranking functions, mimicing the ranking functions described in SQL2003. They are currently implemented using the built in <code>rank</code> function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use <code>desc</code> to reverse the direction.. </p>"	"<pre>row_number(x)<br />ntile(x, n)<br />min_rank(x)<br />dense_rank(x)<br />percent_rank(x)<br />cume_dist(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of values to rank. Missing values are left as is. If you want to treat them as the smallest or largest values, replace with Inf or -Inf before ranking.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of groups to split up into.</p> </td> </tr> </table> "	FALSE
"mutate"	"dplyr"	"Add new variables."	"<p>Mutate adds new variables and preserves existing; transmute drops existing variables. </p>"	"<pre>mutate(.data, ...)<br />mutate_(.data, ..., .dots)<br />transmute(.data, ...)<br />transmute_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Name-value pairs of expressions. Use <code>NULL</code> to drop a variable.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"mutate"	"dplyr"	"Add new variables."	"<p>Mutate adds new variables and preserves existing; transmute drops existing variables. </p>"	"<pre>mutate(.data, ...)<br />mutate_(.data, ..., .dots)<br />transmute(.data, ...)<br />transmute_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Name-value pairs of expressions. Use <code>NULL</code> to drop a variable.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"summarise_all"	"dplyr"	"Summarise and mutate multiple columns."	"<p><code>summarise_all()</code> and <code>mutate_all()</code> apply the functions to all (non-grouping) columns. <code>summarise_at()</code> and <code>mutate_at()</code> allow you to select columns using the same name-based <code>select_helpers</code> as with <code>select()</code>. <code>summarise_if</code>() and <code>mutate_if</code>() operate on columns for which a predicate returns <code>TRUE</code>. Finally, <code>summarise_each()</code> and <code>mutate_each()</code> are older variants that will be deprecated in the future. </p>"	"<pre>summarise_all(.tbl, .funs, ...)<br />mutate_all(.tbl, .funs, ...)<br />summarise_if(.tbl, .predicate, .funs, ...)<br />mutate_if(.tbl, .predicate, .funs, ...)<br />summarise_at(.tbl, .cols, .funs, ...)<br />mutate_at(.tbl, .cols, .funs, ...)<br />summarize_all(.tbl, .funs, ...)<br />summarize_at(.tbl, .cols, .funs, ...)<br />summarize_if(.tbl, .predicate, .funs, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>.funs</code></td> <td> <p>List of function calls generated by <code>funs()</code>, or a character vector of function names, or simply a function (only for local sources).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for the function calls. These are evaluated only once.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A list of columns generated by <code>vars()</code>, or a character vector of column names, or a numeric vector of column positions.</p> </td> </tr> </table> "	FALSE
"summarise_all"	"dplyr"	"Summarise and mutate multiple columns."	"<p><code>summarise_all()</code> and <code>mutate_all()</code> apply the functions to all (non-grouping) columns. <code>summarise_at()</code> and <code>mutate_at()</code> allow you to select columns using the same name-based <code>select_helpers</code> as with <code>select()</code>. <code>summarise_if</code>() and <code>mutate_if</code>() operate on columns for which a predicate returns <code>TRUE</code>. Finally, <code>summarise_each()</code> and <code>mutate_each()</code> are older variants that will be deprecated in the future. </p>"	"<pre>summarise_all(.tbl, .funs, ...)<br />mutate_all(.tbl, .funs, ...)<br />summarise_if(.tbl, .predicate, .funs, ...)<br />mutate_if(.tbl, .predicate, .funs, ...)<br />summarise_at(.tbl, .cols, .funs, ...)<br />mutate_at(.tbl, .cols, .funs, ...)<br />summarize_all(.tbl, .funs, ...)<br />summarize_at(.tbl, .cols, .funs, ...)<br />summarize_if(.tbl, .predicate, .funs, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>.funs</code></td> <td> <p>List of function calls generated by <code>funs()</code>, or a character vector of function names, or simply a function (only for local sources).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for the function calls. These are evaluated only once.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A list of columns generated by <code>vars()</code>, or a character vector of column names, or a numeric vector of column positions.</p> </td> </tr> </table> "	FALSE
"summarise_each"	"dplyr"	"Summarise and mutate multiple columns."	"<p>Apply one or more functions to one or more columns. Grouping variables are always excluded from modification. </p>"	"<pre>summarise_each(tbl, funs, ...)<br />summarise_each_(tbl, funs, vars)<br />summarize_each(tbl, funs, ...)<br />summarize_each_(tbl, funs, vars)<br />mutate_each(tbl, funs, ...)<br />mutate_each_(tbl, funs, vars) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>funs</code></td> <td> <p>List of function calls, generated by <code>funs</code>, or a character vector of function names.</p> </td> </tr> <tr valign='top'> <td><code>vars, ...</code></td> <td> <p>Variables to include/exclude in mutate/summarise. You can use same specifications as in <code>select</code>. If missing, defaults to all non-grouping variables. </p> <p>For standard evaluation versions (ending in <code>_</code>) these can be either a list of expressions or a character vector.</p> </td> </tr> </table> "	FALSE
"summarise_each"	"dplyr"	"Summarise and mutate multiple columns."	"<p>Apply one or more functions to one or more columns. Grouping variables are always excluded from modification. </p>"	"<pre>summarise_each(tbl, funs, ...)<br />summarise_each_(tbl, funs, vars)<br />summarize_each(tbl, funs, ...)<br />summarize_each_(tbl, funs, vars)<br />mutate_each(tbl, funs, ...)<br />mutate_each_(tbl, funs, vars) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>funs</code></td> <td> <p>List of function calls, generated by <code>funs</code>, or a character vector of function names.</p> </td> </tr> <tr valign='top'> <td><code>vars, ...</code></td> <td> <p>Variables to include/exclude in mutate/summarise. You can use same specifications as in <code>select</code>. If missing, defaults to all non-grouping variables. </p> <p>For standard evaluation versions (ending in <code>_</code>) these can be either a list of expressions or a character vector.</p> </td> </tr> </table> "	FALSE
"summarise_all"	"dplyr"	"Summarise and mutate multiple columns."	"<p><code>summarise_all()</code> and <code>mutate_all()</code> apply the functions to all (non-grouping) columns. <code>summarise_at()</code> and <code>mutate_at()</code> allow you to select columns using the same name-based <code>select_helpers</code> as with <code>select()</code>. <code>summarise_if</code>() and <code>mutate_if</code>() operate on columns for which a predicate returns <code>TRUE</code>. Finally, <code>summarise_each()</code> and <code>mutate_each()</code> are older variants that will be deprecated in the future. </p>"	"<pre>summarise_all(.tbl, .funs, ...)<br />mutate_all(.tbl, .funs, ...)<br />summarise_if(.tbl, .predicate, .funs, ...)<br />mutate_if(.tbl, .predicate, .funs, ...)<br />summarise_at(.tbl, .cols, .funs, ...)<br />mutate_at(.tbl, .cols, .funs, ...)<br />summarize_all(.tbl, .funs, ...)<br />summarize_at(.tbl, .cols, .funs, ...)<br />summarize_if(.tbl, .predicate, .funs, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>.funs</code></td> <td> <p>List of function calls generated by <code>funs()</code>, or a character vector of function names, or simply a function (only for local sources).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for the function calls. These are evaluated only once.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A list of columns generated by <code>vars()</code>, or a character vector of column names, or a numeric vector of column positions.</p> </td> </tr> </table> "	FALSE
"summarise_all"	"dplyr"	"Summarise and mutate multiple columns."	"<p><code>summarise_all()</code> and <code>mutate_all()</code> apply the functions to all (non-grouping) columns. <code>summarise_at()</code> and <code>mutate_at()</code> allow you to select columns using the same name-based <code>select_helpers</code> as with <code>select()</code>. <code>summarise_if</code>() and <code>mutate_if</code>() operate on columns for which a predicate returns <code>TRUE</code>. Finally, <code>summarise_each()</code> and <code>mutate_each()</code> are older variants that will be deprecated in the future. </p>"	"<pre>summarise_all(.tbl, .funs, ...)<br />mutate_all(.tbl, .funs, ...)<br />summarise_if(.tbl, .predicate, .funs, ...)<br />mutate_if(.tbl, .predicate, .funs, ...)<br />summarise_at(.tbl, .cols, .funs, ...)<br />mutate_at(.tbl, .cols, .funs, ...)<br />summarize_all(.tbl, .funs, ...)<br />summarize_at(.tbl, .cols, .funs, ...)<br />summarize_if(.tbl, .predicate, .funs, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>.funs</code></td> <td> <p>List of function calls generated by <code>funs()</code>, or a character vector of function names, or simply a function (only for local sources).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for the function calls. These are evaluated only once.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A list of columns generated by <code>vars()</code>, or a character vector of column names, or a numeric vector of column positions.</p> </td> </tr> </table> "	FALSE
"n"	"dplyr"	"The number of observations in the current group."	"<p>This function is implemented special for each data source and can only be used from within <code>summarise</code>, <code>mutate</code> and <code>filter</code> </p>"	"<pre>n() </pre>"	NA	FALSE
"nasa"	"dplyr"	"NASA spatio-temporal data"	"<p>This data comes from the ASA 2007 data expo, <a href='http://stat-computing.org/dataexpo/2006/'>http://stat-computing.org/dataexpo/2006/</a>. The data are geographic and atmospheric measures on a very coarse 24 by 24 grid covering Central America. The variables are: temperature (surface and air), ozone, air pressure, and cloud cover (low, mid, and high). All variables are monthly averages, with observations for Jan 1995 to Dec 2000. These data were obtained from the NASA Langley Research Center Atmospheric Sciences Data Center (with permission; see important copyright terms below). </p>"	"<pre>nasa </pre>"	NA	FALSE
"na_if"	"dplyr"	"Convert values to NA."	"<p>This is a translation of the SQL command <code>NULL_IF</code>. It is useful if you want to convert an annoying value to <code>NA</code>. </p>"	"<pre>na_if(x, y) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Vector to modify</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>If th</p> </td> </tr> </table> "	FALSE
"near"	"dplyr"	"Compare two numeric vectors."	"<p>This is a safe way of comparing if two vectors of floating point numbers are (pairwise) equal.  This is safer than using <code>==</code>, because it has a built in tolerance </p>"	"<pre>near(x, y, tol = .Machine$double.eps^0.5) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>Numeric vectors to compare</p> </td> </tr> <tr valign='top'> <td><code>tol</code></td> <td> <p>Tolerance of comparison.</p> </td> </tr> </table> "	FALSE
"nth"	"dplyr"	"Extract the first, last or nth value from a vector."	"<p>These are straightforward wrappers around <code>[[</code>. The main advantage is that you can provide an optional secondary vector that defines the ordering, and provide a default value to use when the input is shorter than expected. </p>"	"<pre>nth(x, n, order_by = NULL, default = default_missing(x))<br />first(x, order_by = NULL, default = default_missing(x))<br />last(x, order_by = NULL, default = default_missing(x)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A vector</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>For <code>nth_value</code>, a single integer specifying the position. Negative integers index from the end (i.e. <code>-1L</code> will return the last value in the vector). </p> <p>If a double is supplied, it will be silently truncated.</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>An optional vector used to determine the order</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>A default value to use if the position does not exist in the input. This is guessed by default for atomic vectors, where a missing value of the appropriate type is return, and for lists, where a <code>NULL</code> is return. For more complicated objects, you'll need to supply this value.</p> </td> </tr> </table> "	FALSE
"ranking"	"dplyr"	"Windowed rank functions."	"<p>Six variations on ranking functions, mimicing the ranking functions described in SQL2003. They are currently implemented using the built in <code>rank</code> function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use <code>desc</code> to reverse the direction.. </p>"	"<pre>row_number(x)<br />ntile(x, n)<br />min_rank(x)<br />dense_rank(x)<br />percent_rank(x)<br />cume_dist(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of values to rank. Missing values are left as is. If you want to treat them as the smallest or largest values, replace with Inf or -Inf before ranking.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of groups to split up into.</p> </td> </tr> </table> "	FALSE
"select_helpers"	"dplyr"	"Select helpers"	"<p>These functions allow you to select variables based on their names. </p> <ul> <li> <p><code>starts_with()</code>: starts with a prefix </p> </li> <li> <p><code>ends_with()</code>: ends with a prefix </p> </li> <li> <p><code>contains()</code>: contains a literal string </p> </li> <li> <p><code>matches()</code>: matches a regular expression </p> </li> <li> <p><code>num_range()</code>: a numerical range like x01, x02, x03. </p> </li> <li> <p><code>one_of()</code>: variables in character vector. </p> </li> <li> <p><code>everything()</code>: all variables. </p> </li> </ul> "	"<pre>current_vars()<br />starts_with(match, ignore.case = TRUE, vars = current_vars())<br />ends_with(match, ignore.case = TRUE, vars = current_vars())<br />contains(match, ignore.case = TRUE, vars = current_vars())<br />matches(match, ignore.case = TRUE, vars = current_vars())<br />num_range(prefix, range, width = NULL, vars = current_vars())<br />one_of(..., vars = current_vars())<br />everything(vars = current_vars()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>match</code></td> <td> <p>A string.</p> </td> </tr> <tr valign='top'> <td><code>ignore.case</code></td> <td> <p>If <code>TRUE</code>, the default, ignores case when matching names.</p> </td> </tr> <tr valign='top'> <td><code>vars</code></td> <td> <p>A character vector of variable names. When called from inside <code>select()</code> these are automatically set to the names of the table.</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>A prefix that starts the numeric range.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>A sequence of integers, like <code>1:5</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Optionally, the 'width' of the numeric range. For example, a range of 2 gives '01', a range of three '001', etc.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>One or more character vectors.</p> </td> </tr> </table> "	FALSE
"n_distinct"	"dplyr"	"Efficiently count the number of unique values in a set of vector"	"<p>This is a faster and more concise equivalent of <code>length(unique(x))</code> </p>"	"<pre>n_distinct(..., na.rm = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>id <code>TRUE</code> missing values don't count</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>vectors of values</p> </td> </tr> </table> "	FALSE
"group_size"	"dplyr"	"Calculate group sizes."	"<p>Calculate group sizes. </p>"	"<pre>group_size(x)<br />n_groups(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>a grouped tbl</p> </td> </tr></table> "	FALSE
"select_helpers"	"dplyr"	"Select helpers"	"<p>These functions allow you to select variables based on their names. </p> <ul> <li> <p><code>starts_with()</code>: starts with a prefix </p> </li> <li> <p><code>ends_with()</code>: ends with a prefix </p> </li> <li> <p><code>contains()</code>: contains a literal string </p> </li> <li> <p><code>matches()</code>: matches a regular expression </p> </li> <li> <p><code>num_range()</code>: a numerical range like x01, x02, x03. </p> </li> <li> <p><code>one_of()</code>: variables in character vector. </p> </li> <li> <p><code>everything()</code>: all variables. </p> </li> </ul> "	"<pre>current_vars()<br />starts_with(match, ignore.case = TRUE, vars = current_vars())<br />ends_with(match, ignore.case = TRUE, vars = current_vars())<br />contains(match, ignore.case = TRUE, vars = current_vars())<br />matches(match, ignore.case = TRUE, vars = current_vars())<br />num_range(prefix, range, width = NULL, vars = current_vars())<br />one_of(..., vars = current_vars())<br />everything(vars = current_vars()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>match</code></td> <td> <p>A string.</p> </td> </tr> <tr valign='top'> <td><code>ignore.case</code></td> <td> <p>If <code>TRUE</code>, the default, ignores case when matching names.</p> </td> </tr> <tr valign='top'> <td><code>vars</code></td> <td> <p>A character vector of variable names. When called from inside <code>select()</code> these are automatically set to the names of the table.</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>A prefix that starts the numeric range.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>A sequence of integers, like <code>1:5</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Optionally, the 'width' of the numeric range. For example, a range of 2 gives '01', a range of three '001', etc.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>One or more character vectors.</p> </td> </tr> </table> "	FALSE
"order_by"	"dplyr"	"A helper function for ordering window function output."	"<p>This is a useful function to control the order of window functions in  R that don't have a specific ordering parameter. When translated to SQL it will modify the order clause of the OVER function. </p>"	"<pre>order_by(order_by, call) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>order_by</code></td> <td> <p>a vector to order_by</p> </td> </tr> <tr valign='top'> <td><code>call</code></td> <td> <p>a function call to a window function, where the first argument is the vector being operated on</p> </td> </tr> </table> "	FALSE
"ranking"	"dplyr"	"Windowed rank functions."	"<p>Six variations on ranking functions, mimicing the ranking functions described in SQL2003. They are currently implemented using the built in <code>rank</code> function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use <code>desc</code> to reverse the direction.. </p>"	"<pre>row_number(x)<br />ntile(x, n)<br />min_rank(x)<br />dense_rank(x)<br />percent_rank(x)<br />cume_dist(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of values to rank. Missing values are left as is. If you want to treat them as the smallest or largest values, replace with Inf or -Inf before ranking.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of groups to split up into.</p> </td> </tr> </table> "	FALSE
"ranking"	"dplyr"	"Windowed rank functions."	"<p>Six variations on ranking functions, mimicing the ranking functions described in SQL2003. They are currently implemented using the built in <code>rank</code> function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use <code>desc</code> to reverse the direction.. </p>"	"<pre>row_number(x)<br />ntile(x, n)<br />min_rank(x)<br />dense_rank(x)<br />percent_rank(x)<br />cume_dist(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of values to rank. Missing values are left as is. If you want to treat them as the smallest or largest values, replace with Inf or -Inf before ranking.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of groups to split up into.</p> </td> </tr> </table> "	FALSE
"bind"	"dplyr"	"Efficiently bind multiple data frames by row and column."	"<p>This is an efficient implementation of the common pattern of <code>do.call(rbind, dfs)</code> or <code>do.call(cbind, dfs)</code> for binding many data frames into one. <code>combine()</code> acts like <code>c()</code> or <code>unlist()</code> but uses consistent dplyr coercion rules. </p>"	"<pre>bind_rows(..., .id = NULL)<br />bind_cols(...)<br />combine(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Data frames to combine. </p> <p>Each argument can either be a data frame, a list that could be a data frame, or a list of data frames. </p> <p>When column-binding, rows are matched by position, not value so all data frames must have the same number of rows. To match by value, not position, see <code>left_join</code> etc. When row-binding, columns are matched by name, and any values that don't match will be filled with NA.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>Data frames identifier. </p> <p>When <code>.id</code> is supplied, a new column of identifiers is created to link each row to its original data frame. The labels are taken from the named arguments to <code>bind_rows()</code>. When a list of data frames is supplied, the labels are taken from the names of the list. If no names are found a numeric sequence is used instead.</p> </td> </tr> </table> "	FALSE
"bind"	"dplyr"	"Efficiently bind multiple data frames by row and column."	"<p>This is an efficient implementation of the common pattern of <code>do.call(rbind, dfs)</code> or <code>do.call(cbind, dfs)</code> for binding many data frames into one. <code>combine()</code> acts like <code>c()</code> or <code>unlist()</code> but uses consistent dplyr coercion rules. </p>"	"<pre>bind_rows(..., .id = NULL)<br />bind_cols(...)<br />combine(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Data frames to combine. </p> <p>Each argument can either be a data frame, a list that could be a data frame, or a list of data frames. </p> <p>When column-binding, rows are matched by position, not value so all data frames must have the same number of rows. To match by value, not position, see <code>left_join</code> etc. When row-binding, columns are matched by name, and any values that don't match will be filled with NA.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>Data frames identifier. </p> <p>When <code>.id</code> is supplied, a new column of identifiers is created to link each row to its original data frame. The labels are taken from the named arguments to <code>bind_rows()</code>. When a list of data frames is supplied, the labels are taken from the names of the list. If no names are found a numeric sequence is used instead.</p> </td> </tr> </table> "	FALSE
"recode"	"dplyr"	"Recode values"	"<p>This is a vectorised version of <code>switch()</code>: you can replace numeric values based on their position, and character values by their name. This is an S3 generic: dplyr provides methods for numeric, character, and factors. For logical vectors, use <code>if_else</code> </p>"	"<pre>recode(.x, ..., .default = NULL, .missing = NULL)<br />recode_factor(.x, ..., .default = NULL, .missing = NULL, .ordered = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A vector to modify</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Replacments. These should be named for character and factor <code>.x</code>, and can be named for numeric <code>.x</code>. </p> <p>All replacements must be the same type, and must have either length one or the same length as x.</p> </td> </tr> <tr valign='top'> <td><code>.default</code></td> <td> <p>If supplied, all values not otherwise matched will be given this value. If not supplied and if the replacements are the same type as the original values in <code>.x</code>, unmatched values are not changed. If not supplied and if the replacements are not compatible, unmatched values are replaced with <code>NA</code>. <code>.default</code> must be either length 1 or the same length as <code>.x</code>.</p> </td> </tr> <tr valign='top'> <td><code>.missing</code></td> <td> <p>If supplied, any missing values in <code>.x</code> will be replaced by this value. Must be either length 1 or the same length as <code>.x</code>.</p> </td> </tr> <tr valign='top'> <td><code>.ordered</code></td> <td> <p>If <code>TRUE</code>, <code>recode_factor()</code> creates an ordered factor.</p> </td> </tr> </table> "	FALSE
"recode"	"dplyr"	"Recode values"	"<p>This is a vectorised version of <code>switch()</code>: you can replace numeric values based on their position, and character values by their name. This is an S3 generic: dplyr provides methods for numeric, character, and factors. For logical vectors, use <code>if_else</code> </p>"	"<pre>recode(.x, ..., .default = NULL, .missing = NULL)<br />recode_factor(.x, ..., .default = NULL, .missing = NULL, .ordered = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A vector to modify</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Replacments. These should be named for character and factor <code>.x</code>, and can be named for numeric <code>.x</code>. </p> <p>All replacements must be the same type, and must have either length one or the same length as x.</p> </td> </tr> <tr valign='top'> <td><code>.default</code></td> <td> <p>If supplied, all values not otherwise matched will be given this value. If not supplied and if the replacements are the same type as the original values in <code>.x</code>, unmatched values are not changed. If not supplied and if the replacements are not compatible, unmatched values are replaced with <code>NA</code>. <code>.default</code> must be either length 1 or the same length as <code>.x</code>.</p> </td> </tr> <tr valign='top'> <td><code>.missing</code></td> <td> <p>If supplied, any missing values in <code>.x</code> will be replaced by this value. Must be either length 1 or the same length as <code>.x</code>.</p> </td> </tr> <tr valign='top'> <td><code>.ordered</code></td> <td> <p>If <code>TRUE</code>, <code>recode_factor()</code> creates an ordered factor.</p> </td> </tr> </table> "	FALSE
"group_by"	"dplyr"	"Group a tbl by one or more variables."	"<p>Most data operations are useful done on groups defined by variables in the the dataset. The <code>group_by</code> function takes an existing tbl and converts it into a grouped tbl where operations are performed 'by group'. </p>"	"<pre>group_by(.data, ..., add = FALSE)<br />group_by_(.data, ..., .dots, add = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>variables to group by. All tbls accept variable names, some will also accept functions of variables. Duplicated groups will be silently dropped.</p> </td> </tr> <tr valign='top'> <td><code>add</code></td> <td> <p>By default, when <code>add = FALSE</code>, <code>group_by</code> will override existing groups. To instead add to the existing groups, use <code>add = TRUE</code></p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"select"	"dplyr"	"Select/rename variables by name."	"<p><code>select()</code> keeps only the variables you mention; <code>rename()</code> keeps all variables. </p>"	"<pre>select(.data, ...)<br />select_(.data, ..., .dots)<br />rename(.data, ...)<br />rename_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Comma separated list of unquoted expressions. You can treat variable names like they are positions. Use positive values to select variables; use negative values to drop variables.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Use <code>select_()</code> to do standard evaluation. See <code>vignette('nse')</code> for details</p> </td> </tr> </table> "	FALSE
"select"	"dplyr"	"Select/rename variables by name."	"<p><code>select()</code> keeps only the variables you mention; <code>rename()</code> keeps all variables. </p>"	"<pre>select(.data, ...)<br />select_(.data, ..., .dots)<br />rename(.data, ...)<br />rename_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Comma separated list of unquoted expressions. You can treat variable names like they are positions. Use positive values to select variables; use negative values to drop variables.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Use <code>select_()</code> to do standard evaluation. See <code>vignette('nse')</code> for details</p> </td> </tr> </table> "	FALSE
"join"	"dplyr"	"Join two tbls together."	"<p>These are generic functions that dispatch to individual tbl methods - see the method documentation for details of individual data sources. <code>x</code> and <code>y</code> should usually be from the same data source, but if <code>copy</code> is <code>TRUE</code>, <code>y</code> will automatically be copied to the same source as <code>x</code> - this may be an expensive operation. </p>"	"<pre>inner_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />right_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />semi_join(x, y, by = NULL, copy = FALSE, ...)<br />anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"join.tbl_df"	"dplyr"	"Join data frame tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_df' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' semi_join(x, y, by = NULL, copy = FALSE, ...)<br />## S3 method for class 'tbl_df' anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>included for compatibility with the generic; otherwise ignored.</p> </td> </tr> </table> "	FALSE
"join.tbl_sql"	"dplyr"	"Join sql tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_lazy' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' left_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' full_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' semi_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' anti_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into a temporary table in same database as <code>x</code>. <code>join</code> will automatically run <code>ANALYZE</code> on the created table in the hope that this will make you queries as efficient as possible by giving more data to the query planner. </p> <p>This allows you to join tables across srcs, but it's potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>auto_index</code></td> <td> <p>if <code>copy</code> is <code>TRUE</code>, automatically create indices for the variables in <code>by</code>. This may speed up the join if there are matching indexes in <code>x</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"rowwise"	"dplyr"	"Group input by rows"	"<p><code>rowwise</code> is used for the results of <code>do</code> when you create list-variables. It is also useful to support arbitrary complex operations that need to be applied to each row. </p>"	"<pre>rowwise(data) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>data</code></td> <td> <p>Input data frame.</p> </td> </tr></table> "	FALSE
"ranking"	"dplyr"	"Windowed rank functions."	"<p>Six variations on ranking functions, mimicing the ranking functions described in SQL2003. They are currently implemented using the built in <code>rank</code> function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use <code>desc</code> to reverse the direction.. </p>"	"<pre>row_number(x)<br />ntile(x, n)<br />min_rank(x)<br />dense_rank(x)<br />percent_rank(x)<br />cume_dist(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of values to rank. Missing values are left as is. If you want to treat them as the smallest or largest values, replace with Inf or -Inf before ranking.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of groups to split up into.</p> </td> </tr> </table> "	FALSE
"sample"	"dplyr"	"Sample n rows from a table."	"<p>This is a wrapper around <code>sample.int</code> to make it easy to select random rows from a table. It currently only works for local tbls. </p>"	"<pre>sample_n(tbl, size, replace = FALSE, weight = NULL, .env = parent.frame())<br />sample_frac(tbl, size = 1, replace = FALSE, weight = NULL,<br />   .env = parent.frame()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbl</code></td> <td> <p>tbl of data.</p> </td> </tr> <tr valign='top'> <td><code>size</code></td> <td> <p>For <code>sample_n</code>, the number of rows to select. For <code>sample_frac</code>, the fraction of rows to select. If <code>tbl</code> is grouped, <code>size</code> applies to each group.</p> </td> </tr> <tr valign='top'> <td><code>replace</code></td> <td> <p>Sample with or without replacement?</p> </td> </tr> <tr valign='top'> <td><code>weight</code></td> <td> <p>Sampling weights. This expression is evaluated in the context of the data frame. It must return a vector of non-negative numbers the same length as the input. Weights are automatically standardised to sum to 1.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>Environment in which to look for non-data names used in <code>weight</code>. Non-default settings for experts only.</p> </td> </tr> </table> "	FALSE
"sample"	"dplyr"	"Sample n rows from a table."	"<p>This is a wrapper around <code>sample.int</code> to make it easy to select random rows from a table. It currently only works for local tbls. </p>"	"<pre>sample_n(tbl, size, replace = FALSE, weight = NULL, .env = parent.frame())<br />sample_frac(tbl, size = 1, replace = FALSE, weight = NULL,<br />   .env = parent.frame()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbl</code></td> <td> <p>tbl of data.</p> </td> </tr> <tr valign='top'> <td><code>size</code></td> <td> <p>For <code>sample_n</code>, the number of rows to select. For <code>sample_frac</code>, the fraction of rows to select. If <code>tbl</code> is grouped, <code>size</code> applies to each group.</p> </td> </tr> <tr valign='top'> <td><code>replace</code></td> <td> <p>Sample with or without replacement?</p> </td> </tr> <tr valign='top'> <td><code>weight</code></td> <td> <p>Sampling weights. This expression is evaluated in the context of the data frame. It must return a vector of non-negative numbers the same length as the input. Weights are automatically standardised to sum to 1.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>Environment in which to look for non-data names used in <code>weight</code>. Non-default settings for experts only.</p> </td> </tr> </table> "	FALSE
"sample"	"dplyr"	"Sample n rows from a table."	"<p>This is a wrapper around <code>sample.int</code> to make it easy to select random rows from a table. It currently only works for local tbls. </p>"	"<pre>sample_n(tbl, size, replace = FALSE, weight = NULL, .env = parent.frame())<br />sample_frac(tbl, size = 1, replace = FALSE, weight = NULL,<br />   .env = parent.frame()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbl</code></td> <td> <p>tbl of data.</p> </td> </tr> <tr valign='top'> <td><code>size</code></td> <td> <p>For <code>sample_n</code>, the number of rows to select. For <code>sample_frac</code>, the fraction of rows to select. If <code>tbl</code> is grouped, <code>size</code> applies to each group.</p> </td> </tr> <tr valign='top'> <td><code>replace</code></td> <td> <p>Sample with or without replacement?</p> </td> </tr> <tr valign='top'> <td><code>weight</code></td> <td> <p>Sampling weights. This expression is evaluated in the context of the data frame. It must return a vector of non-negative numbers the same length as the input. Weights are automatically standardised to sum to 1.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>Environment in which to look for non-data names used in <code>weight</code>. Non-default settings for experts only.</p> </td> </tr> </table> "	FALSE
"select"	"dplyr"	"Select/rename variables by name."	"<p><code>select()</code> keeps only the variables you mention; <code>rename()</code> keeps all variables. </p>"	"<pre>select(.data, ...)<br />select_(.data, ..., .dots)<br />rename(.data, ...)<br />rename_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Comma separated list of unquoted expressions. You can treat variable names like they are positions. Use positive values to select variables; use negative values to drop variables.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Use <code>select_()</code> to do standard evaluation. See <code>vignette('nse')</code> for details</p> </td> </tr> </table> "	FALSE
"select"	"dplyr"	"Select/rename variables by name."	"<p><code>select()</code> keeps only the variables you mention; <code>rename()</code> keeps all variables. </p>"	"<pre>select(.data, ...)<br />select_(.data, ..., .dots)<br />rename(.data, ...)<br />rename_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Comma separated list of unquoted expressions. You can treat variable names like they are positions. Use positive values to select variables; use negative values to drop variables.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Use <code>select_()</code> to do standard evaluation. See <code>vignette('nse')</code> for details</p> </td> </tr> </table> "	FALSE
"select_helpers"	"dplyr"	"Select helpers"	"<p>These functions allow you to select variables based on their names. </p> <ul> <li> <p><code>starts_with()</code>: starts with a prefix </p> </li> <li> <p><code>ends_with()</code>: ends with a prefix </p> </li> <li> <p><code>contains()</code>: contains a literal string </p> </li> <li> <p><code>matches()</code>: matches a regular expression </p> </li> <li> <p><code>num_range()</code>: a numerical range like x01, x02, x03. </p> </li> <li> <p><code>one_of()</code>: variables in character vector. </p> </li> <li> <p><code>everything()</code>: all variables. </p> </li> </ul> "	"<pre>current_vars()<br />starts_with(match, ignore.case = TRUE, vars = current_vars())<br />ends_with(match, ignore.case = TRUE, vars = current_vars())<br />contains(match, ignore.case = TRUE, vars = current_vars())<br />matches(match, ignore.case = TRUE, vars = current_vars())<br />num_range(prefix, range, width = NULL, vars = current_vars())<br />one_of(..., vars = current_vars())<br />everything(vars = current_vars()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>match</code></td> <td> <p>A string.</p> </td> </tr> <tr valign='top'> <td><code>ignore.case</code></td> <td> <p>If <code>TRUE</code>, the default, ignores case when matching names.</p> </td> </tr> <tr valign='top'> <td><code>vars</code></td> <td> <p>A character vector of variable names. When called from inside <code>select()</code> these are automatically set to the names of the table.</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>A prefix that starts the numeric range.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>A sequence of integers, like <code>1:5</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Optionally, the 'width' of the numeric range. For example, a range of 2 gives '01', a range of three '001', etc.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>One or more character vectors.</p> </td> </tr> </table> "	FALSE
"select_if"	"dplyr"	"Select columns using a predicate"	"<p>This verb is analogous to <code>summarise_if()</code> and <code>mutate_if()</code> in that it lets you use a predicate on the columns of a data frame. Only those columns for which the predicate returns <code>TRUE</code> will be selected. </p>"	"<pre>select_if(.data, .predicate, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A local tbl source.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed to <code>.predicate</code>.</p> </td> </tr> </table> "	FALSE
"join"	"dplyr"	"Join two tbls together."	"<p>These are generic functions that dispatch to individual tbl methods - see the method documentation for details of individual data sources. <code>x</code> and <code>y</code> should usually be from the same data source, but if <code>copy</code> is <code>TRUE</code>, <code>y</code> will automatically be copied to the same source as <code>x</code> - this may be an expensive operation. </p>"	"<pre>inner_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />right_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x', '.y'), ...)<br />semi_join(x, y, by = NULL, copy = FALSE, ...)<br />anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"join.tbl_df"	"dplyr"	"Join data frame tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_df' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' left_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), ...)<br />## S3 method for class 'tbl_df' full_join(x, y, by = NULL, copy = FALSE, suffix = c('.x',<br />   '.y'), ...)<br />## S3 method for class 'tbl_df' semi_join(x, y, by = NULL, copy = FALSE, ...)<br />## S3 method for class 'tbl_df' anti_join(x, y, by = NULL, copy = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the same src as <code>x</code>.  This allows you to join tables across srcs, but it is a potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>included for compatibility with the generic; otherwise ignored.</p> </td> </tr> </table> "	FALSE
"join.tbl_sql"	"dplyr"	"Join sql tbls."	"<p>See <code>join</code> for a description of the general purpose of the functions. </p>"	"<pre>## S3 method for class 'tbl_lazy' inner_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' left_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' right_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' full_join(x, y, by = NULL, copy = FALSE,<br />   suffix = c('.x', '.y'), auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' semi_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...)<br />## S3 method for class 'tbl_lazy' anti_join(x, y, by = NULL, copy = FALSE,<br />   auto_index = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>tbls to join</p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>a character vector of variables to join by.  If <code>NULL</code>, the default, <code>join</code> will do a natural join, using all variables with common names across the two tables. A message lists the variables so that you can check they're right (to suppress the message, simply explicitly list the variables that you want to join). </p> <p>To join by different variables on x and y use a named vector. For example, <code>by = c('a' = 'b')</code> will match <code>x.a</code> to <code>y.b</code>.</p> </td> </tr> <tr valign='top'> <td><code>copy</code></td> <td> <p>If <code>x</code> and <code>y</code> are not from the same data source, and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into a temporary table in same database as <code>x</code>. <code>join</code> will automatically run <code>ANALYZE</code> on the created table in the hope that this will make you queries as efficient as possible by giving more data to the query planner. </p> <p>This allows you to join tables across srcs, but it's potentially expensive operation so you must opt into it.</p> </td> </tr> <tr valign='top'> <td><code>suffix</code></td> <td> <p>If there are non-joined duplicate variables in <code>x</code> and <code>y</code>, these suffixes will be added to the output to diambiguate them.</p> </td> </tr> <tr valign='top'> <td><code>auto_index</code></td> <td> <p>if <code>copy</code> is <code>TRUE</code>, automatically create indices for the variables in <code>by</code>. This may speed up the join if there are matching indexes in <code>x</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other parameters passed onto methods</p> </td> </tr> </table> "	FALSE
"setops"	"dplyr"	"Set operations."	"<p>These functions override the set functions provided in base to make them generic so that efficient versions for data frames and other tables can be provided. The default methods call the base versions. </p>"	"<pre>intersect(x, y, ...)<br />union(x, y, ...)<br />union_all(x, y, ...)<br />setdiff(x, y, ...)<br />setequal(x, y, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>objects to perform set function on (ignoring order)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to methods</p> </td> </tr> </table> "	FALSE
"setops"	"dplyr"	"Set operations."	"<p>These functions override the set functions provided in base to make them generic so that efficient versions for data frames and other tables can be provided. The default methods call the base versions. </p>"	"<pre>intersect(x, y, ...)<br />union(x, y, ...)<br />union_all(x, y, ...)<br />setdiff(x, y, ...)<br />setequal(x, y, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>objects to perform set function on (ignoring order)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to methods</p> </td> </tr> </table> "	FALSE
"setops"	"dplyr"	"Set operations."	"<p>These functions override the set functions provided in base to make them generic so that efficient versions for data frames and other tables can be provided. The default methods call the base versions. </p>"	"<pre>intersect(x, y, ...)<br />union(x, y, ...)<br />union_all(x, y, ...)<br />setdiff(x, y, ...)<br />setequal(x, y, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>objects to perform set function on (ignoring order)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to methods</p> </td> </tr> </table> "	FALSE
"explain"	"dplyr"	"Explain details of a tbl."	"<p>This is a generic function which gives more details about an object than <code>print</code>, and is more focussed on human readable output than <code>str</code>. </p>"	"<pre>explain(x, ...)<br />show_query(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object to explain</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other parameters possibly used by generic</p> </td> </tr> </table> "	FALSE
"slice"	"dplyr"	"Select rows by position."	"<p>Slice does not work with relational databases because they have no intrinsic notion of row order. If you want to perform the equivalent operation, use <code>filter()</code> and <code>row_number()</code>. </p>"	"<pre>slice(.data, ...)<br />slice_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Integer row values</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"slice"	"dplyr"	"Select rows by position."	"<p>Slice does not work with relational databases because they have no intrinsic notion of row order. If you want to perform the equivalent operation, use <code>filter()</code> and <code>row_number()</code>. </p>"	"<pre>slice(.data, ...)<br />slice_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Integer row values</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"src-test"	"dplyr"	"A set of DBI methods to ease unit testing dplyr with DBI"	"<p>A set of DBI methods to ease unit testing dplyr with DBI </p>"	"<pre>## S3 method for class 'DBITestConnection' db_query_fields(con, sql, ...)<br />## S3 method for class 'DBITestConnection' sql_escape_ident(con, x)<br />## S3 method for class 'DBITestConnection' sql_translate_env(con) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>con</code></td> <td> <p>A database connection.</p> </td> </tr> <tr valign='top'> <td><code>sql</code></td> <td> <p>A string containing an sql query.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to the individual methods</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to transform</p> </td> </tr> </table>"	FALSE
"src-test"	"dplyr"	"A set of DBI methods to ease unit testing dplyr with DBI"	"<p>A set of DBI methods to ease unit testing dplyr with DBI </p>"	"<pre>## S3 method for class 'DBITestConnection' db_query_fields(con, sql, ...)<br />## S3 method for class 'DBITestConnection' sql_escape_ident(con, x)<br />## S3 method for class 'DBITestConnection' sql_translate_env(con) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>con</code></td> <td> <p>A database connection.</p> </td> </tr> <tr valign='top'> <td><code>sql</code></td> <td> <p>A string containing an sql query.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to the individual methods</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to transform</p> </td> </tr> </table>"	FALSE
"src-test"	"dplyr"	"A set of DBI methods to ease unit testing dplyr with DBI"	"<p>A set of DBI methods to ease unit testing dplyr with DBI </p>"	"<pre>## S3 method for class 'DBITestConnection' db_query_fields(con, sql, ...)<br />## S3 method for class 'DBITestConnection' sql_escape_ident(con, x)<br />## S3 method for class 'DBITestConnection' sql_translate_env(con) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>con</code></td> <td> <p>A database connection.</p> </td> </tr> <tr valign='top'> <td><code>sql</code></td> <td> <p>A string containing an sql query.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to the individual methods</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to transform</p> </td> </tr> </table>"	FALSE
"src_memdb"	"dplyr"	"Per-session in-memory SQLite databases."	"<p><code>src_memdb</code> lets you easily access a sessio-temporary in-memory SQLite database. <code>memdb_frame()</code> works like <code>data_frame</code>, but instead of creating a new data frame in R, it creates a table in <code>src_memdb</code> </p>"	"<pre>src_memdb()<br />memdb_frame(..., .name = random_table_name()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A set of name-value pairs. Arguments are evaluated sequentially, so you can refer to previously created variables.</p> </td> </tr> <tr valign='top'> <td><code>.name</code></td> <td> <p>Name of table in database: defaults to a random name that's unlikely to conflict with exist</p> </td> </tr> </table> "	FALSE
"src_mysql"	"dplyr"	"Connect to mysql/mariadb."	"<p>Use <code>src_mysql</code> to connect to an existing mysql or mariadb database, and <code>tbl</code> to connect to tables within that database. If you are running a local mysqlql database, leave all parameters set as their defaults to connect. If you're connecting to a remote database, ask your database administrator for the values of these variables. </p>"	"<pre>src_mysql(dbname, host = NULL, port = 0L, user = 'root', password = '',<br />   ...)<br />## S3 method for class 'src_mysql' tbl(src, from, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>dbname</code></td> <td> <p>Database name</p> </td> </tr> <tr valign='top'> <td><code>host, port</code></td> <td> <p>Host name and port number of database</p> </td> </tr> <tr valign='top'> <td><code>user, password</code></td> <td> <p>User name and password. Rather than supplying a username and password here, it's better to save them in <code>my.cnf</code>, as described in <code>MySQL</code>. In that case, supply <code>NULL</code> to both <code>user</code> and <code>password</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>for the src, other arguments passed on to the underlying database connector, <code>dbConnect</code>. For the tbl, included for compatibility with the generic, but otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>src</code></td> <td> <p>a mysql src created with <code>src_mysql</code>.</p> </td> </tr> <tr valign='top'> <td><code>from</code></td> <td> <p>Either a string giving the name of table in database, or <code>sql</code> described a derived table or compound join.</p> </td> </tr> </table> "	FALSE
"src_postgres"	"dplyr"	"Connect to postgresql."	"<p>Use <code>src_postgres</code> to connect to an existing postgresql database, and <code>tbl</code> to connect to tables within that database. If you are running a local postgresql database, leave all parameters set as their defaults to connect. If you're connecting to a remote database, ask your database administrator for the values of these variables. </p>"	"<pre>src_postgres(dbname = NULL, host = NULL, port = NULL, user = NULL,<br />   password = NULL, ...)<br />## S3 method for class 'src_postgres' tbl(src, from, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>dbname</code></td> <td> <p>Database name</p> </td> </tr> <tr valign='top'> <td><code>host, port</code></td> <td> <p>Host name and port number of database</p> </td> </tr> <tr valign='top'> <td><code>user, password</code></td> <td> <p>User name and password (if needed)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>for the src, other arguments passed on to the underlying database connector, <code>dbConnect</code>. For the tbl, included for compatibility with the generic, but otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>src</code></td> <td> <p>a postgres src created with <code>src_postgres</code>.</p> </td> </tr> <tr valign='top'> <td><code>from</code></td> <td> <p>Either a string giving the name of table in database, or <code>sql</code> described a derived table or compound join.</p> </td> </tr> </table> "	FALSE
"src_sqlite"	"dplyr"	"Connect to a sqlite database."	"<p>Use <code>src_sqlite</code> to connect to an existing sqlite database, and <code>tbl</code> to connect to tables within that database. If you are running a local sqliteql database, leave all parameters set as their defaults to connect. If you're connecting to a remote database, ask your database administrator for the values of these variables. <code>src_memdb</code> is an easy way to use an in-memory SQLite database that is scoped to the current session. </p>"	"<pre>src_sqlite(path, create = FALSE)<br />## S3 method for class 'src_sqlite' tbl(src, from, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to SQLite database</p> </td> </tr> <tr valign='top'> <td><code>create</code></td> <td> <p>if <code>FALSE</code>, <code>path</code> must already exist. If <code>TRUE</code>, will create a new SQlite3 database at <code>path</code> if <code>path</code> does not exist and connect to the existing database if <code>path</code> does exist.</p> </td> </tr> <tr valign='top'> <td><code>src</code></td> <td> <p>a sqlite src created with <code>src_sqlite</code>.</p> </td> </tr> <tr valign='top'> <td><code>from</code></td> <td> <p>Either a string giving the name of table in database, or <code>sql</code> described a derived table or compound join.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Included for compatibility with the generic, but otherwise ignored.</p> </td> </tr> </table> "	FALSE
"src_tbls"	"dplyr"	"List all tbls provided by a source."	"<p>This is a generic method which individual src's will provide methods for. Most methods will not be documented because it's usually pretty obvious what possible results will be. </p>"	"<pre>src_tbls(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>a data src.</p> </td> </tr></table>"	FALSE
"select_helpers"	"dplyr"	"Select helpers"	"<p>These functions allow you to select variables based on their names. </p> <ul> <li> <p><code>starts_with()</code>: starts with a prefix </p> </li> <li> <p><code>ends_with()</code>: ends with a prefix </p> </li> <li> <p><code>contains()</code>: contains a literal string </p> </li> <li> <p><code>matches()</code>: matches a regular expression </p> </li> <li> <p><code>num_range()</code>: a numerical range like x01, x02, x03. </p> </li> <li> <p><code>one_of()</code>: variables in character vector. </p> </li> <li> <p><code>everything()</code>: all variables. </p> </li> </ul> "	"<pre>current_vars()<br />starts_with(match, ignore.case = TRUE, vars = current_vars())<br />ends_with(match, ignore.case = TRUE, vars = current_vars())<br />contains(match, ignore.case = TRUE, vars = current_vars())<br />matches(match, ignore.case = TRUE, vars = current_vars())<br />num_range(prefix, range, width = NULL, vars = current_vars())<br />one_of(..., vars = current_vars())<br />everything(vars = current_vars()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>match</code></td> <td> <p>A string.</p> </td> </tr> <tr valign='top'> <td><code>ignore.case</code></td> <td> <p>If <code>TRUE</code>, the default, ignores case when matching names.</p> </td> </tr> <tr valign='top'> <td><code>vars</code></td> <td> <p>A character vector of variable names. When called from inside <code>select()</code> these are automatically set to the names of the table.</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>A prefix that starts the numeric range.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>A sequence of integers, like <code>1:5</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Optionally, the 'width' of the numeric range. For example, a range of 2 gives '01', a range of three '001', etc.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>One or more character vectors.</p> </td> </tr> </table> "	FALSE
"summarise"	"dplyr"	"Summarise multiple values to a single value."	"<p>Summarise multiple values to a single value. </p>"	"<pre>summarise(.data, ...)<br />summarise_(.data, ..., .dots)<br />summarize(.data, ...)<br />summarize_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Name-value pairs of summary functions like <code>min()</code>, <code>mean()</code>, <code>max()</code> etc.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"summarise"	"dplyr"	"Summarise multiple values to a single value."	"<p>Summarise multiple values to a single value. </p>"	"<pre>summarise(.data, ...)<br />summarise_(.data, ..., .dots)<br />summarize(.data, ...)<br />summarize_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Name-value pairs of summary functions like <code>min()</code>, <code>mean()</code>, <code>max()</code> etc.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"summarise_all"	"dplyr"	"Summarise and mutate multiple columns."	"<p><code>summarise_all()</code> and <code>mutate_all()</code> apply the functions to all (non-grouping) columns. <code>summarise_at()</code> and <code>mutate_at()</code> allow you to select columns using the same name-based <code>select_helpers</code> as with <code>select()</code>. <code>summarise_if</code>() and <code>mutate_if</code>() operate on columns for which a predicate returns <code>TRUE</code>. Finally, <code>summarise_each()</code> and <code>mutate_each()</code> are older variants that will be deprecated in the future. </p>"	"<pre>summarise_all(.tbl, .funs, ...)<br />mutate_all(.tbl, .funs, ...)<br />summarise_if(.tbl, .predicate, .funs, ...)<br />mutate_if(.tbl, .predicate, .funs, ...)<br />summarise_at(.tbl, .cols, .funs, ...)<br />mutate_at(.tbl, .cols, .funs, ...)<br />summarize_all(.tbl, .funs, ...)<br />summarize_at(.tbl, .cols, .funs, ...)<br />summarize_if(.tbl, .predicate, .funs, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>.funs</code></td> <td> <p>List of function calls generated by <code>funs()</code>, or a character vector of function names, or simply a function (only for local sources).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for the function calls. These are evaluated only once.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A list of columns generated by <code>vars()</code>, or a character vector of column names, or a numeric vector of column positions.</p> </td> </tr> </table> "	FALSE
"summarise_all"	"dplyr"	"Summarise and mutate multiple columns."	"<p><code>summarise_all()</code> and <code>mutate_all()</code> apply the functions to all (non-grouping) columns. <code>summarise_at()</code> and <code>mutate_at()</code> allow you to select columns using the same name-based <code>select_helpers</code> as with <code>select()</code>. <code>summarise_if</code>() and <code>mutate_if</code>() operate on columns for which a predicate returns <code>TRUE</code>. Finally, <code>summarise_each()</code> and <code>mutate_each()</code> are older variants that will be deprecated in the future. </p>"	"<pre>summarise_all(.tbl, .funs, ...)<br />mutate_all(.tbl, .funs, ...)<br />summarise_if(.tbl, .predicate, .funs, ...)<br />mutate_if(.tbl, .predicate, .funs, ...)<br />summarise_at(.tbl, .cols, .funs, ...)<br />mutate_at(.tbl, .cols, .funs, ...)<br />summarize_all(.tbl, .funs, ...)<br />summarize_at(.tbl, .cols, .funs, ...)<br />summarize_if(.tbl, .predicate, .funs, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>.funs</code></td> <td> <p>List of function calls generated by <code>funs()</code>, or a character vector of function names, or simply a function (only for local sources).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for the function calls. These are evaluated only once.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A list of columns generated by <code>vars()</code>, or a character vector of column names, or a numeric vector of column positions.</p> </td> </tr> </table> "	FALSE
"summarise_each"	"dplyr"	"Summarise and mutate multiple columns."	"<p>Apply one or more functions to one or more columns. Grouping variables are always excluded from modification. </p>"	"<pre>summarise_each(tbl, funs, ...)<br />summarise_each_(tbl, funs, vars)<br />summarize_each(tbl, funs, ...)<br />summarize_each_(tbl, funs, vars)<br />mutate_each(tbl, funs, ...)<br />mutate_each_(tbl, funs, vars) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>funs</code></td> <td> <p>List of function calls, generated by <code>funs</code>, or a character vector of function names.</p> </td> </tr> <tr valign='top'> <td><code>vars, ...</code></td> <td> <p>Variables to include/exclude in mutate/summarise. You can use same specifications as in <code>select</code>. If missing, defaults to all non-grouping variables. </p> <p>For standard evaluation versions (ending in <code>_</code>) these can be either a list of expressions or a character vector.</p> </td> </tr> </table> "	FALSE
"summarise_each"	"dplyr"	"Summarise and mutate multiple columns."	"<p>Apply one or more functions to one or more columns. Grouping variables are always excluded from modification. </p>"	"<pre>summarise_each(tbl, funs, ...)<br />summarise_each_(tbl, funs, vars)<br />summarize_each(tbl, funs, ...)<br />summarize_each_(tbl, funs, vars)<br />mutate_each(tbl, funs, ...)<br />mutate_each_(tbl, funs, vars) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>funs</code></td> <td> <p>List of function calls, generated by <code>funs</code>, or a character vector of function names.</p> </td> </tr> <tr valign='top'> <td><code>vars, ...</code></td> <td> <p>Variables to include/exclude in mutate/summarise. You can use same specifications as in <code>select</code>. If missing, defaults to all non-grouping variables. </p> <p>For standard evaluation versions (ending in <code>_</code>) these can be either a list of expressions or a character vector.</p> </td> </tr> </table> "	FALSE
"summarise_all"	"dplyr"	"Summarise and mutate multiple columns."	"<p><code>summarise_all()</code> and <code>mutate_all()</code> apply the functions to all (non-grouping) columns. <code>summarise_at()</code> and <code>mutate_at()</code> allow you to select columns using the same name-based <code>select_helpers</code> as with <code>select()</code>. <code>summarise_if</code>() and <code>mutate_if</code>() operate on columns for which a predicate returns <code>TRUE</code>. Finally, <code>summarise_each()</code> and <code>mutate_each()</code> are older variants that will be deprecated in the future. </p>"	"<pre>summarise_all(.tbl, .funs, ...)<br />mutate_all(.tbl, .funs, ...)<br />summarise_if(.tbl, .predicate, .funs, ...)<br />mutate_if(.tbl, .predicate, .funs, ...)<br />summarise_at(.tbl, .cols, .funs, ...)<br />mutate_at(.tbl, .cols, .funs, ...)<br />summarize_all(.tbl, .funs, ...)<br />summarize_at(.tbl, .cols, .funs, ...)<br />summarize_if(.tbl, .predicate, .funs, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>.funs</code></td> <td> <p>List of function calls generated by <code>funs()</code>, or a character vector of function names, or simply a function (only for local sources).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for the function calls. These are evaluated only once.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A list of columns generated by <code>vars()</code>, or a character vector of column names, or a numeric vector of column positions.</p> </td> </tr> </table> "	FALSE
"summarise_all"	"dplyr"	"Summarise and mutate multiple columns."	"<p><code>summarise_all()</code> and <code>mutate_all()</code> apply the functions to all (non-grouping) columns. <code>summarise_at()</code> and <code>mutate_at()</code> allow you to select columns using the same name-based <code>select_helpers</code> as with <code>select()</code>. <code>summarise_if</code>() and <code>mutate_if</code>() operate on columns for which a predicate returns <code>TRUE</code>. Finally, <code>summarise_each()</code> and <code>mutate_each()</code> are older variants that will be deprecated in the future. </p>"	"<pre>summarise_all(.tbl, .funs, ...)<br />mutate_all(.tbl, .funs, ...)<br />summarise_if(.tbl, .predicate, .funs, ...)<br />mutate_if(.tbl, .predicate, .funs, ...)<br />summarise_at(.tbl, .cols, .funs, ...)<br />mutate_at(.tbl, .cols, .funs, ...)<br />summarize_all(.tbl, .funs, ...)<br />summarize_at(.tbl, .cols, .funs, ...)<br />summarize_if(.tbl, .predicate, .funs, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>.funs</code></td> <td> <p>List of function calls generated by <code>funs()</code>, or a character vector of function names, or simply a function (only for local sources).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for the function calls. These are evaluated only once.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A list of columns generated by <code>vars()</code>, or a character vector of column names, or a numeric vector of column positions.</p> </td> </tr> </table> "	FALSE
"summarise"	"dplyr"	"Summarise multiple values to a single value."	"<p>Summarise multiple values to a single value. </p>"	"<pre>summarise(.data, ...)<br />summarise_(.data, ..., .dots)<br />summarize(.data, ...)<br />summarize_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Name-value pairs of summary functions like <code>min()</code>, <code>mean()</code>, <code>max()</code> etc.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"summarise"	"dplyr"	"Summarise multiple values to a single value."	"<p>Summarise multiple values to a single value. </p>"	"<pre>summarise(.data, ...)<br />summarise_(.data, ..., .dots)<br />summarize(.data, ...)<br />summarize_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Name-value pairs of summary functions like <code>min()</code>, <code>mean()</code>, <code>max()</code> etc.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"summarise_all"	"dplyr"	"Summarise and mutate multiple columns."	"<p><code>summarise_all()</code> and <code>mutate_all()</code> apply the functions to all (non-grouping) columns. <code>summarise_at()</code> and <code>mutate_at()</code> allow you to select columns using the same name-based <code>select_helpers</code> as with <code>select()</code>. <code>summarise_if</code>() and <code>mutate_if</code>() operate on columns for which a predicate returns <code>TRUE</code>. Finally, <code>summarise_each()</code> and <code>mutate_each()</code> are older variants that will be deprecated in the future. </p>"	"<pre>summarise_all(.tbl, .funs, ...)<br />mutate_all(.tbl, .funs, ...)<br />summarise_if(.tbl, .predicate, .funs, ...)<br />mutate_if(.tbl, .predicate, .funs, ...)<br />summarise_at(.tbl, .cols, .funs, ...)<br />mutate_at(.tbl, .cols, .funs, ...)<br />summarize_all(.tbl, .funs, ...)<br />summarize_at(.tbl, .cols, .funs, ...)<br />summarize_if(.tbl, .predicate, .funs, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>.funs</code></td> <td> <p>List of function calls generated by <code>funs()</code>, or a character vector of function names, or simply a function (only for local sources).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for the function calls. These are evaluated only once.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A list of columns generated by <code>vars()</code>, or a character vector of column names, or a numeric vector of column positions.</p> </td> </tr> </table> "	FALSE
"summarise_all"	"dplyr"	"Summarise and mutate multiple columns."	"<p><code>summarise_all()</code> and <code>mutate_all()</code> apply the functions to all (non-grouping) columns. <code>summarise_at()</code> and <code>mutate_at()</code> allow you to select columns using the same name-based <code>select_helpers</code> as with <code>select()</code>. <code>summarise_if</code>() and <code>mutate_if</code>() operate on columns for which a predicate returns <code>TRUE</code>. Finally, <code>summarise_each()</code> and <code>mutate_each()</code> are older variants that will be deprecated in the future. </p>"	"<pre>summarise_all(.tbl, .funs, ...)<br />mutate_all(.tbl, .funs, ...)<br />summarise_if(.tbl, .predicate, .funs, ...)<br />mutate_if(.tbl, .predicate, .funs, ...)<br />summarise_at(.tbl, .cols, .funs, ...)<br />mutate_at(.tbl, .cols, .funs, ...)<br />summarize_all(.tbl, .funs, ...)<br />summarize_at(.tbl, .cols, .funs, ...)<br />summarize_if(.tbl, .predicate, .funs, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>.funs</code></td> <td> <p>List of function calls generated by <code>funs()</code>, or a character vector of function names, or simply a function (only for local sources).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for the function calls. These are evaluated only once.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A list of columns generated by <code>vars()</code>, or a character vector of column names, or a numeric vector of column positions.</p> </td> </tr> </table> "	FALSE
"summarise_each"	"dplyr"	"Summarise and mutate multiple columns."	"<p>Apply one or more functions to one or more columns. Grouping variables are always excluded from modification. </p>"	"<pre>summarise_each(tbl, funs, ...)<br />summarise_each_(tbl, funs, vars)<br />summarize_each(tbl, funs, ...)<br />summarize_each_(tbl, funs, vars)<br />mutate_each(tbl, funs, ...)<br />mutate_each_(tbl, funs, vars) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>funs</code></td> <td> <p>List of function calls, generated by <code>funs</code>, or a character vector of function names.</p> </td> </tr> <tr valign='top'> <td><code>vars, ...</code></td> <td> <p>Variables to include/exclude in mutate/summarise. You can use same specifications as in <code>select</code>. If missing, defaults to all non-grouping variables. </p> <p>For standard evaluation versions (ending in <code>_</code>) these can be either a list of expressions or a character vector.</p> </td> </tr> </table> "	FALSE
"summarise_each"	"dplyr"	"Summarise and mutate multiple columns."	"<p>Apply one or more functions to one or more columns. Grouping variables are always excluded from modification. </p>"	"<pre>summarise_each(tbl, funs, ...)<br />summarise_each_(tbl, funs, vars)<br />summarize_each(tbl, funs, ...)<br />summarize_each_(tbl, funs, vars)<br />mutate_each(tbl, funs, ...)<br />mutate_each_(tbl, funs, vars) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>funs</code></td> <td> <p>List of function calls, generated by <code>funs</code>, or a character vector of function names.</p> </td> </tr> <tr valign='top'> <td><code>vars, ...</code></td> <td> <p>Variables to include/exclude in mutate/summarise. You can use same specifications as in <code>select</code>. If missing, defaults to all non-grouping variables. </p> <p>For standard evaluation versions (ending in <code>_</code>) these can be either a list of expressions or a character vector.</p> </td> </tr> </table> "	FALSE
"summarise_all"	"dplyr"	"Summarise and mutate multiple columns."	"<p><code>summarise_all()</code> and <code>mutate_all()</code> apply the functions to all (non-grouping) columns. <code>summarise_at()</code> and <code>mutate_at()</code> allow you to select columns using the same name-based <code>select_helpers</code> as with <code>select()</code>. <code>summarise_if</code>() and <code>mutate_if</code>() operate on columns for which a predicate returns <code>TRUE</code>. Finally, <code>summarise_each()</code> and <code>mutate_each()</code> are older variants that will be deprecated in the future. </p>"	"<pre>summarise_all(.tbl, .funs, ...)<br />mutate_all(.tbl, .funs, ...)<br />summarise_if(.tbl, .predicate, .funs, ...)<br />mutate_if(.tbl, .predicate, .funs, ...)<br />summarise_at(.tbl, .cols, .funs, ...)<br />mutate_at(.tbl, .cols, .funs, ...)<br />summarize_all(.tbl, .funs, ...)<br />summarize_at(.tbl, .cols, .funs, ...)<br />summarize_if(.tbl, .predicate, .funs, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.tbl</code></td> <td> <p>a tbl</p> </td> </tr> <tr valign='top'> <td><code>.funs</code></td> <td> <p>List of function calls generated by <code>funs()</code>, or a character vector of function names, or simply a function (only for local sources).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for the function calls. These are evaluated only once.</p> </td> </tr> <tr valign='top'> <td><code>.predicate</code></td> <td> <p>A predicate function to be applied to the columns or a logical vector. The columns for which <code>.predicate</code> is or returns <code>TRUE</code> will be summarised or mutated.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A list of columns generated by <code>vars()</code>, or a character vector of column names, or a numeric vector of column positions.</p> </td> </tr> </table> "	FALSE
"tally"	"dplyr"	"Counts/tally observations by group."	"<p><code>tally</code> is a convenient wrapper for summarise that will either call <code>n</code> or <code>sum(n)</code> depending on whether you're tallying for the first time, or re-tallying. <code>count()</code> is similar, but also does the <code>group_by</code> for you. </p>"	"<pre>tally(x, wt, sort = FALSE)<br />count(x, ..., wt = NULL, sort = FALSE)<br />count_(x, vars, wt = NULL, sort = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a <code>tbl</code> to tally/count.</p> </td> </tr> <tr valign='top'> <td><code>wt</code></td> <td> <p>(Optional) If omitted, will count the number of rows. If specified, will perform a 'weighted' tally by summing the (non-missing) values of variable <code>wt</code>.</p> </td> </tr> <tr valign='top'> <td><code>sort</code></td> <td> <p>if <code>TRUE</code> will sort output in descending order of <code>n</code></p> </td> </tr> <tr valign='top'> <td><code>..., vars</code></td> <td> <p>Variables to group by.</p> </td> </tr> </table> "	FALSE
"tbl"	"dplyr"	"Create a table from a data source"	"<p>This is a generic method that dispatches based on the first argument. </p>"	"<pre>tbl(src, ...)<br />is.tbl(x)<br />as.tbl(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>src</code></td> <td> <p>A data source</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to the individual methods</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an object to coerce to a <code>tbl</code></p> </td> </tr> </table>"	FALSE
"src_mysql"	"dplyr"	"Connect to mysql/mariadb."	"<p>Use <code>src_mysql</code> to connect to an existing mysql or mariadb database, and <code>tbl</code> to connect to tables within that database. If you are running a local mysqlql database, leave all parameters set as their defaults to connect. If you're connecting to a remote database, ask your database administrator for the values of these variables. </p>"	"<pre>src_mysql(dbname, host = NULL, port = 0L, user = 'root', password = '',<br />   ...)<br />## S3 method for class 'src_mysql' tbl(src, from, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>dbname</code></td> <td> <p>Database name</p> </td> </tr> <tr valign='top'> <td><code>host, port</code></td> <td> <p>Host name and port number of database</p> </td> </tr> <tr valign='top'> <td><code>user, password</code></td> <td> <p>User name and password. Rather than supplying a username and password here, it's better to save them in <code>my.cnf</code>, as described in <code>MySQL</code>. In that case, supply <code>NULL</code> to both <code>user</code> and <code>password</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>for the src, other arguments passed on to the underlying database connector, <code>dbConnect</code>. For the tbl, included for compatibility with the generic, but otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>src</code></td> <td> <p>a mysql src created with <code>src_mysql</code>.</p> </td> </tr> <tr valign='top'> <td><code>from</code></td> <td> <p>Either a string giving the name of table in database, or <code>sql</code> described a derived table or compound join.</p> </td> </tr> </table> "	FALSE
"src_postgres"	"dplyr"	"Connect to postgresql."	"<p>Use <code>src_postgres</code> to connect to an existing postgresql database, and <code>tbl</code> to connect to tables within that database. If you are running a local postgresql database, leave all parameters set as their defaults to connect. If you're connecting to a remote database, ask your database administrator for the values of these variables. </p>"	"<pre>src_postgres(dbname = NULL, host = NULL, port = NULL, user = NULL,<br />   password = NULL, ...)<br />## S3 method for class 'src_postgres' tbl(src, from, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>dbname</code></td> <td> <p>Database name</p> </td> </tr> <tr valign='top'> <td><code>host, port</code></td> <td> <p>Host name and port number of database</p> </td> </tr> <tr valign='top'> <td><code>user, password</code></td> <td> <p>User name and password (if needed)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>for the src, other arguments passed on to the underlying database connector, <code>dbConnect</code>. For the tbl, included for compatibility with the generic, but otherwise ignored.</p> </td> </tr> <tr valign='top'> <td><code>src</code></td> <td> <p>a postgres src created with <code>src_postgres</code>.</p> </td> </tr> <tr valign='top'> <td><code>from</code></td> <td> <p>Either a string giving the name of table in database, or <code>sql</code> described a derived table or compound join.</p> </td> </tr> </table> "	FALSE
"src_sqlite"	"dplyr"	"Connect to a sqlite database."	"<p>Use <code>src_sqlite</code> to connect to an existing sqlite database, and <code>tbl</code> to connect to tables within that database. If you are running a local sqliteql database, leave all parameters set as their defaults to connect. If you're connecting to a remote database, ask your database administrator for the values of these variables. <code>src_memdb</code> is an easy way to use an in-memory SQLite database that is scoped to the current session. </p>"	"<pre>src_sqlite(path, create = FALSE)<br />## S3 method for class 'src_sqlite' tbl(src, from, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to SQLite database</p> </td> </tr> <tr valign='top'> <td><code>create</code></td> <td> <p>if <code>FALSE</code>, <code>path</code> must already exist. If <code>TRUE</code>, will create a new SQlite3 database at <code>path</code> if <code>path</code> does not exist and connect to the existing database if <code>path</code> does exist.</p> </td> </tr> <tr valign='top'> <td><code>src</code></td> <td> <p>a sqlite src created with <code>src_sqlite</code>.</p> </td> </tr> <tr valign='top'> <td><code>from</code></td> <td> <p>Either a string giving the name of table in database, or <code>sql</code> described a derived table or compound join.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Included for compatibility with the generic, but otherwise ignored.</p> </td> </tr> </table> "	FALSE
"tbl_cube"	"dplyr"	"A data cube tbl."	"<p>A cube tbl stores data in a compact array format where dimension names are not needlessly repeated. They are particularly appropriate for experimental data where all combinations of factors are tried (e.g. complete factorial designs), or for storing the result of aggregations. Compared to data frames, they will occupy much less memory when variables are crossed, not nested. </p>"	"<pre>tbl_cube(dimensions, measures) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>dimensions</code></td> <td> <p>A named list of vectors. A dimension is a variable whose values are known before the experiement is conducted; they are fixed by design (in <span class='pkg'>reshape2</span> they are known as id variables). <code>tbl_cubes</code> are dense which means that almost every combination of the dimensions should have associated measurements: missing values require an explicit NA, so if the variables are nested, not crossed, the majority of the data structure will be empty. Dimensions are typically, but not always, categorical variables.</p> </td> </tr> <tr valign='top'> <td><code>measures</code></td> <td> <p>A named list of arrays. A measure is something that is actually measured, and is not known in advance. The dimension of each array should be the same as the length of the dimensions. Measures are typically, but not always, continuous values.</p> </td> </tr> </table> "	FALSE
"tbl_df"	"dplyr"	"Create a data frame tbl."	"<p>Forwards the argument to <code>as_data_frame</code>, see tibble-package for more details. </p>"	"<pre>tbl_df(data) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>data</code></td> <td> <p>a data frame</p> </td> </tr></table> "	FALSE
"tbl_vars"	"dplyr"	"List variables provided by a tbl."	"<p>List variables provided by a tbl. </p>"	"<pre>tbl_vars(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A tbl object</p> </td> </tr></table>"	FALSE
"top_n"	"dplyr"	"Select top (or bottom) n rows (by value)."	"<p>This is a convenient wrapper that uses <code>filter</code> and <code>min_rank</code> to select the top or bottom entries in each group, ordered by <code>wt</code>. </p>"	"<pre>top_n(x, n, wt) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a <code>tbl</code> to filter</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of rows to return. If <code>x</code> is grouped, this is the number of rows per group. Will include more than <code>n</code> rows if there are ties. </p> <p>If <code>n</code> is positive, selects the top <code>n</code> rows. If negative, selects the bottom <code>n</code> rows.</p> </td> </tr> <tr valign='top'> <td><code>wt</code></td> <td> <p>(Optional). The variable to use for ordering. If not specified, defaults to the last variable in the tbl.</p> </td> </tr> </table> "	FALSE
"translate_sql"	"dplyr"	"Translate an expression to sql."	"<p>Translate an expression to sql. </p>"	"<pre>translate_sql(..., con = NULL, vars = character(), vars_group = NULL,<br />   vars_order = NULL, window = TRUE)<br />translate_sql_(dots, con = NULL, vars = character(), vars_group = NULL,<br />   vars_order = NULL, window = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>..., dots</code></td> <td> <p>Expressions to translate. <code>sql_translate</code> automatically quotes them for you.  <code>sql_translate_</code> expects a list of already quoted objects.</p> </td> </tr> <tr valign='top'> <td><code>con</code></td> <td> <p>An optional database connection to control the details of the translation. The default, <code>NULL</code>, generates ANSI SQL.</p> </td> </tr> <tr valign='top'> <td><code>vars</code></td> <td> <p>A character vector giving variable names in the remote data source. If this is supplied, <code>translate_sql</code> will call <code>partial_eval</code> to interpolate in the values from local variables.</p> </td> </tr> <tr valign='top'> <td><code>vars_group, vars_order</code></td> <td> <p>Grouping and ordering variables used for windowed functions.</p> </td> </tr> <tr valign='top'> <td><code>window</code></td> <td> <p>Use <code>FALSE</code> to suppress generation of the <code>OVER</code> statement used for window functions. This is necessary when generating SQL for a grouped summary.</p> </td> </tr> </table> "	FALSE
"translate_sql"	"dplyr"	"Translate an expression to sql."	"<p>Translate an expression to sql. </p>"	"<pre>translate_sql(..., con = NULL, vars = character(), vars_group = NULL,<br />   vars_order = NULL, window = TRUE)<br />translate_sql_(dots, con = NULL, vars = character(), vars_group = NULL,<br />   vars_order = NULL, window = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>..., dots</code></td> <td> <p>Expressions to translate. <code>sql_translate</code> automatically quotes them for you.  <code>sql_translate_</code> expects a list of already quoted objects.</p> </td> </tr> <tr valign='top'> <td><code>con</code></td> <td> <p>An optional database connection to control the details of the translation. The default, <code>NULL</code>, generates ANSI SQL.</p> </td> </tr> <tr valign='top'> <td><code>vars</code></td> <td> <p>A character vector giving variable names in the remote data source. If this is supplied, <code>translate_sql</code> will call <code>partial_eval</code> to interpolate in the values from local variables.</p> </td> </tr> <tr valign='top'> <td><code>vars_group, vars_order</code></td> <td> <p>Grouping and ordering variables used for windowed functions.</p> </td> </tr> <tr valign='top'> <td><code>window</code></td> <td> <p>Use <code>FALSE</code> to suppress generation of the <code>OVER</code> statement used for window functions. This is necessary when generating SQL for a grouped summary.</p> </td> </tr> </table> "	FALSE
"mutate"	"dplyr"	"Add new variables."	"<p>Mutate adds new variables and preserves existing; transmute drops existing variables. </p>"	"<pre>mutate(.data, ...)<br />mutate_(.data, ..., .dots)<br />transmute(.data, ...)<br />transmute_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Name-value pairs of expressions. Use <code>NULL</code> to drop a variable.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"mutate"	"dplyr"	"Add new variables."	"<p>Mutate adds new variables and preserves existing; transmute drops existing variables. </p>"	"<pre>mutate(.data, ...)<br />mutate_(.data, ..., .dots)<br />transmute(.data, ...)<br />transmute_(.data, ..., .dots) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>A tbl. All main verbs are S3 generics and provide methods for <code>tbl_df</code>, <code>tbl_dt</code> and <code>tbl_sql</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Name-value pairs of expressions. Use <code>NULL</code> to drop a variable.</p> </td> </tr> <tr valign='top'> <td><code>.dots</code></td> <td> <p>Used to work around non-standard evaluation. See <code>vignette('nse')</code> for details.</p> </td> </tr> </table> "	FALSE
"groups"	"dplyr"	"Get/set the grouping variables for tbl."	"<p>These functions do not perform non-standard evaluation, and so are useful when programming against <code>tbl</code> objects. <code>ungroup</code> is a convenient inline way of removing existing grouping. </p>"	"<pre>groups(x)<br />ungroup(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>data <code>tbl</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments that maybe used by methods.</p> </td> </tr> </table> "	FALSE
"setops"	"dplyr"	"Set operations."	"<p>These functions override the set functions provided in base to make them generic so that efficient versions for data frames and other tables can be provided. The default methods call the base versions. </p>"	"<pre>intersect(x, y, ...)<br />union(x, y, ...)<br />union_all(x, y, ...)<br />setdiff(x, y, ...)<br />setequal(x, y, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>objects to perform set function on (ignoring order)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to methods</p> </td> </tr> </table> "	FALSE
"setops"	"dplyr"	"Set operations."	"<p>These functions override the set functions provided in base to make them generic so that efficient versions for data frames and other tables can be provided. The default methods call the base versions. </p>"	"<pre>intersect(x, y, ...)<br />union(x, y, ...)<br />union_all(x, y, ...)<br />setdiff(x, y, ...)<br />setequal(x, y, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>objects to perform set function on (ignoring order)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to methods</p> </td> </tr> </table> "	FALSE
"vars"	"dplyr"	"Select columns"	"<p>This helper has equivalent semantics to <code>select()</code>. Its purpose is to provide <code>select()</code> semantics to the colwise summarising and mutating verbs. </p>"	"<pre>vars(...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>...</code></td> <td> <p>Variables to include/exclude in mutate/summarise. You can use same specifications as in <code>select</code>. If missing, defaults to all non-grouping variables.</p> </td> </tr></table> "	FALSE
"feather"	"feather"	"Access a feather store like a data frame"	"<p>These functions permit using a feather dataset much like a regular (read-only) data frame. </p>"	"<pre>feather(path) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>path</code></td> <td> <p>Path to feather file</p> </td> </tr></table> "	FALSE
"feather_metadata"	"feather"	"Retrieve metadata about a feather file"	"<p>Returns the dimensions, field names, and types; and optional dataset description. </p>"	"<pre>feather_metadata(path) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>path</code></td> <td> <p>Path to feather file</p> </td> </tr></table> "	FALSE
"read_feather"	"feather"	"Read and write feather files."	"<p>Read and write feather files. </p>"	"<pre>read_feather(path, columns = NULL)<br />write_feather(x, path) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to feather file</p> </td> </tr> <tr valign='top'> <td><code>columns</code></td> <td> <p>Columns to read (names or indexes). Default: Read all columns.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> </table> "	FALSE
"read_feather"	"feather"	"Read and write feather files."	"<p>Read and write feather files. </p>"	"<pre>read_feather(path, columns = NULL)<br />write_feather(x, path) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to feather file</p> </td> </tr> <tr valign='top'> <td><code>columns</code></td> <td> <p>Columns to read (names or indexes). Default: Read all columns.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> </table> "	FALSE
"fct_anon"	"forcats"	"Anonymise factor levels"	"<p>Replaces factor levels with arbitary numeric identifiers. Neither the values nor the order of the levels are preserved. </p>"	"<pre>fct_anon(f, prefix = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>A character prefix to insert in front of the random labels.</p> </td> </tr> </table> "	FALSE
"fct_c"	"forcats"	"Concatenate factors, unioning levels."	"<p>This is useful way of patching together factors from multiple sources that really should have the same levels but don't. </p>"	"<pre>fct_c(fs) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>fs</code></td> <td> <p>A list of factors</p> </td> </tr></table> "	FALSE
"fct_collapse"	"forcats"	"Collapse factors into groups."	"<p>Collapse factors into groups. </p>"	"<pre>fct_collapse(f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>A series of named character vectors. The levels in each vector will be replaced with the name.</p> </td> </tr> </table> "	FALSE
"fct_count"	"forcats"	"Count entries in a factor"	"<p>Count entries in a factor </p>"	"<pre>fct_count(f, sort = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr> <tr valign='top'> <td><code>sort</code></td> <td> <p>If <code>TRUE</code>, sort the result so that most common values float to the top.</p> </td> </tr> </table> "	FALSE
"fct_drop"	"forcats"	"Drop unnused levels"	"<p>Same as <code>droplevels()</code>, but with consistent name scheme. </p>"	"<pre>fct_drop(f) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr></table> "	FALSE
"fct_expand"	"forcats"	"Add additional levels to a factor"	"<p>Add additional levels to a factor </p>"	"<pre>fct_expand(f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional levels to add to the factor.  Levels that already exist will be silently ignored.</p> </td> </tr> </table> "	FALSE
"fct_explicit_na"	"forcats"	"Make missing values explicit"	"<p>This gives missing value an explicit factor level, ensuring that they appear in summaries and on plots. </p>"	"<pre>fct_explicit_na(f, na_level = '(Missing)') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor.</p> </td> </tr> <tr valign='top'> <td><code>na_level</code></td> <td> <p>Level to use for missing values.</p> </td> </tr> </table> "	FALSE
"fct_inorder"	"forcats"	"Reorders levels in order of first appearance or frequency."	"<p>Reorders levels in order of first appearance or frequency. </p>"	"<pre>fct_inorder(f)<br />fct_infreq(f) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr></table> "	FALSE
"fct_inorder"	"forcats"	"Reorders levels in order of first appearance or frequency."	"<p>Reorders levels in order of first appearance or frequency. </p>"	"<pre>fct_inorder(f)<br />fct_infreq(f) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr></table> "	FALSE
"fct_lump"	"forcats"	"Lump together least/most common levels into \"other\"."	"<p>Lump together least/most common levels into 'other'. </p>"	"<pre>fct_lump(f, n, prop, other_level = 'Other', ties.method = c('min',<br />   'average', 'first', 'last', 'random', 'max')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor.</p> </td> </tr> <tr valign='top'> <td><code>n, prop</code></td> <td> <p>If both <code>n</code> and <code>prop</code> are missing, <code>fct_lump</code> lumps together the least frequent levels into 'other', while ensuring that 'other' is still the smallest level. It's particularly useful in conjunction with <code>fct_inorder()</code>. </p> <p>Positive <code>n</code> preserves the most common <code>n</code> values. Negative <code>n</code> preserves the least common <code>-n</code> values. It there are ties, you will get at least <code>abs(n)</code> values. </p> <p>Positive <code>prop</code>, preserves values that appear at least <code>prop</code> of the time. Negative <code>prop</code>, preserves values that appear at most <code>-prop</code> of the time.</p> </td> </tr> <tr valign='top'> <td><code>other_level</code></td> <td> <p>Value of level used for 'other' values. Always placed at end of levels.</p> </td> </tr> <tr valign='top'> <td><code>ties.method</code></td> <td> <p>A character string specifying how ties are treated. See <code>rank</code> for details</p> </td> </tr> </table> "	FALSE
"fct_recode"	"forcats"	"Change the levels of a factor"	"<p>Change the levels of a factor </p>"	"<pre>fct_recode(f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>A sequence of named character vectors where the name gives the new level, and the value gives the old level. Levels not otherwise mentioned will be left as is. Levels can be removed by naming them <code>NULL</code>.</p> </td> </tr> </table> "	FALSE
"fct_relevel"	"forcats"	"Change the order of levels in a factor"	"<p>This is a generalisaton of <code>relevel</code> that allows you to move any number of levels to the front. </p>"	"<pre>fct_relevel(f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Character vector of levels. Any levels not mentioned will be left in existing order, after the explicitly mentioned levels.</p> </td> </tr> </table> "	FALSE
"fct_reorder"	"forcats"	"Reorder the levels of a function according to another variable"	"<p><code>fct_reorder</code> is useful for 1d displays where the factor is mapped to position; <code>fct_reorder2</code> for 2d displays where the factor is mapped to a non-position aesthetic. </p>"	"<pre>fct_reorder(f, x, fun = median, ..., .desc = FALSE)<br />fct_reorder2(f, x, y, fun = last2, ..., .desc = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr> <tr valign='top'> <td><code>x, y</code></td> <td> <p>fun The levels of <code>f</code> will be reordered so that <code>fun</code> apply to each group is in ascending order.</p> </td> </tr> <tr valign='top'> <td><code>fun</code></td> <td> <p>An summary function. It should take one vector for <code>fct_reorder</code>, and two vectors for <code>fct_reorder2</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>fun</code>. A common argument is <code>na.rm = TRUE</code>.</p> </td> </tr> <tr valign='top'> <td><code>.desc</code></td> <td> <p>Order in descending order? Note the default is different between <code>fct_reorder</code> and <code>fct_reorder2</code>, in order to match the default ordering of factors in the legend.</p> </td> </tr> </table> "	FALSE
"fct_reorder"	"forcats"	"Reorder the levels of a function according to another variable"	"<p><code>fct_reorder</code> is useful for 1d displays where the factor is mapped to position; <code>fct_reorder2</code> for 2d displays where the factor is mapped to a non-position aesthetic. </p>"	"<pre>fct_reorder(f, x, fun = median, ..., .desc = FALSE)<br />fct_reorder2(f, x, y, fun = last2, ..., .desc = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr> <tr valign='top'> <td><code>x, y</code></td> <td> <p>fun The levels of <code>f</code> will be reordered so that <code>fun</code> apply to each group is in ascending order.</p> </td> </tr> <tr valign='top'> <td><code>fun</code></td> <td> <p>An summary function. It should take one vector for <code>fct_reorder</code>, and two vectors for <code>fct_reorder2</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>fun</code>. A common argument is <code>na.rm = TRUE</code>.</p> </td> </tr> <tr valign='top'> <td><code>.desc</code></td> <td> <p>Order in descending order? Note the default is different between <code>fct_reorder</code> and <code>fct_reorder2</code>, in order to match the default ordering of factors in the legend.</p> </td> </tr> </table> "	FALSE
"fct_rev"	"forcats"	"Reverse the levels of a factor"	"<p>This is sometimes useful when plotting a factor </p>"	"<pre>fct_rev(f) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr></table> "	FALSE
"fct_shift"	"forcats"	"Shift the order of levels of a factor"	"<p>This is useful when the levels of an ordered factor are actually cyclical, with different conventions on the starting point. </p>"	"<pre>fct_shift(f, n = 1L) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Positive values shift to the left; negative values shift to the right.</p> </td> </tr> </table> "	FALSE
"fct_shuffle"	"forcats"	"Randomly permute the levels of a factor"	"<p>Randomly permute the levels of a factor </p>"	"<pre>fct_shuffle(f) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr></table> "	FALSE
"fct_unify"	"forcats"	"Unify the levels in a list of factors"	"<p>Unify the levels in a list of factors </p>"	"<pre>fct_unify(fs, levels = lvls_union(fs)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>fs</code></td> <td> <p>A list of factors</p> </td> </tr> <tr valign='top'> <td><code>levels</code></td> <td> <p>Set of levels to apply to every factor. Default to union of all factor levels</p> </td> </tr> </table> "	FALSE
"fct_unique"	"forcats"	"Unique values of a factor"	"<p>Unique values of a factor </p>"	"<pre>fct_unique(f) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr></table> "	FALSE
"gss_cat"	"forcats"	"A sample of categorical variables from the General Social survey"	"<p>A sample of categorical variables from the General Social survey </p>"	"<pre>gss_cat </pre>"	NA	FALSE
"lvls"	"forcats"	"Low-level functions for manipulating levels"	"<p><code>lvls_reorder</code> leaves values as is, but changes the order. <code>lvls_revalue</code> changes the values of existing levels; there must be one new level for each old level. <code>lvls_extend</code> extends the set of levels; the new level must include the old levels. </p>"	"<pre>lvls_reorder(f, idx)<br />lvls_revalue(f, new_levels)<br />lvls_expand(f, new_levels) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr> <tr valign='top'> <td><code>idx</code></td> <td> <p>A integer index, with one integer for each existing level</p> </td> </tr> <tr valign='top'> <td><code>new_levels</code></td> <td> <p>A character vector of new levels</p> </td> </tr> </table> "	FALSE
"lvls"	"forcats"	"Low-level functions for manipulating levels"	"<p><code>lvls_reorder</code> leaves values as is, but changes the order. <code>lvls_revalue</code> changes the values of existing levels; there must be one new level for each old level. <code>lvls_extend</code> extends the set of levels; the new level must include the old levels. </p>"	"<pre>lvls_reorder(f, idx)<br />lvls_revalue(f, new_levels)<br />lvls_expand(f, new_levels) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr> <tr valign='top'> <td><code>idx</code></td> <td> <p>A integer index, with one integer for each existing level</p> </td> </tr> <tr valign='top'> <td><code>new_levels</code></td> <td> <p>A character vector of new levels</p> </td> </tr> </table> "	FALSE
"lvls"	"forcats"	"Low-level functions for manipulating levels"	"<p><code>lvls_reorder</code> leaves values as is, but changes the order. <code>lvls_revalue</code> changes the values of existing levels; there must be one new level for each old level. <code>lvls_extend</code> extends the set of levels; the new level must include the old levels. </p>"	"<pre>lvls_reorder(f, idx)<br />lvls_revalue(f, new_levels)<br />lvls_expand(f, new_levels) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr> <tr valign='top'> <td><code>idx</code></td> <td> <p>A integer index, with one integer for each existing level</p> </td> </tr> <tr valign='top'> <td><code>new_levels</code></td> <td> <p>A character vector of new levels</p> </td> </tr> </table> "	FALSE
"lvls"	"forcats"	"Low-level functions for manipulating levels"	"<p><code>lvls_reorder</code> leaves values as is, but changes the order. <code>lvls_revalue</code> changes the values of existing levels; there must be one new level for each old level. <code>lvls_extend</code> extends the set of levels; the new level must include the old levels. </p>"	"<pre>lvls_reorder(f, idx)<br />lvls_revalue(f, new_levels)<br />lvls_expand(f, new_levels) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A factor</p> </td> </tr> <tr valign='top'> <td><code>idx</code></td> <td> <p>A integer index, with one integer for each existing level</p> </td> </tr> <tr valign='top'> <td><code>new_levels</code></td> <td> <p>A character vector of new levels</p> </td> </tr> </table> "	FALSE
"lvls_union"	"forcats"	"Find all levels in a list of factors"	"<p>Find all levels in a list of factors </p>"	"<pre>lvls_union(fs) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>fs</code></td> <td> <p>A list of factors.</p> </td> </tr></table> "	FALSE
"aes"	"ggplot2"	"Construct aesthetic mappings"	"<p>Aesthetic mappings describe how variables in the data are mapped to visual properties (aesthetics) of geoms. Aesthetic mappings can be set in <code>ggplot2</code> and in individual layers. </p>"	"<pre>aes(x, y, ...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x, y, ...</code></td> <td> <p>List of name value pairs giving aesthetics to map to variables. The names for x and y aesthetics are typically omitted because they are so common; all other aesthetics must be named.</p> </td> </tr></table> "	FALSE
"aes_"	"ggplot2"	"Define aesthetic mappings programatically"	"<p>Aesthetic mappings describe how variables in the data are mapped to visual properties (aesthetics) of geoms. <code>aes</code> uses non-standard evaluation to capture the variable names. <code>aes_</code> and <code>aes_string</code> require you to explicitly quote the inputs either with <code>''</code> for <code>aes_string()</code>, or with <code>quote</code> or <code>~</code> for <code>aes_()</code>. (<code>aes_q</code> is an alias to <code>aes_</code>). This makes <code>aes_</code> and <code>aes_string</code> easy to program with. </p>"	"<pre>aes_(x, y, ...)<br />aes_string(x, y, ...)<br />aes_q(x, y, ...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x, y, ...</code></td> <td> <p>List of name value pairs. Elements must be either quoted calls, strings, one-sided formulas or constants.</p> </td> </tr></table> "	FALSE
"aes_colour_fill_alpha"	"ggplot2"	"Colour related aesthetics: colour, fill and alpha"	"<p>This page demonstrates the usage of a sub-group of aesthetics; colour, fill and alpha. </p>"	NA	NA	FALSE
"aes_group_order"	"ggplot2"	"Aesthetics: grouping"	"<p>Aesthetics: grouping </p>"	NA	NA	FALSE
"aes_linetype_size_shape"	"ggplot2"	"Differentiation related aesthetics: linetype, size, shape"	"<p>This page demonstrates the usage of a sub-group of aesthetics; linetype, size and shape. </p>"	NA	NA	FALSE
"aes_position"	"ggplot2"	"Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend"	"<p>This page demonstrates the usage of a sub-group of aesthetics; x, y, xmin, xmax, ymin, ymax, xend, and yend. </p>"	NA	NA	FALSE
"aes_"	"ggplot2"	"Define aesthetic mappings programatically"	"<p>Aesthetic mappings describe how variables in the data are mapped to visual properties (aesthetics) of geoms. <code>aes</code> uses non-standard evaluation to capture the variable names. <code>aes_</code> and <code>aes_string</code> require you to explicitly quote the inputs either with <code>''</code> for <code>aes_string()</code>, or with <code>quote</code> or <code>~</code> for <code>aes_()</code>. (<code>aes_q</code> is an alias to <code>aes_</code>). This makes <code>aes_</code> and <code>aes_string</code> easy to program with. </p>"	"<pre>aes_(x, y, ...)<br />aes_string(x, y, ...)<br />aes_q(x, y, ...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x, y, ...</code></td> <td> <p>List of name value pairs. Elements must be either quoted calls, strings, one-sided formulas or constants.</p> </td> </tr></table> "	FALSE
"aes_"	"ggplot2"	"Define aesthetic mappings programatically"	"<p>Aesthetic mappings describe how variables in the data are mapped to visual properties (aesthetics) of geoms. <code>aes</code> uses non-standard evaluation to capture the variable names. <code>aes_</code> and <code>aes_string</code> require you to explicitly quote the inputs either with <code>''</code> for <code>aes_string()</code>, or with <code>quote</code> or <code>~</code> for <code>aes_()</code>. (<code>aes_q</code> is an alias to <code>aes_</code>). This makes <code>aes_</code> and <code>aes_string</code> easy to program with. </p>"	"<pre>aes_(x, y, ...)<br />aes_string(x, y, ...)<br />aes_q(x, y, ...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x, y, ...</code></td> <td> <p>List of name value pairs. Elements must be either quoted calls, strings, one-sided formulas or constants.</p> </td> </tr></table> "	FALSE
"annotate"	"ggplot2"	"Create an annotation layer"	"<p>This function adds geoms to a plot, but unlike typical a geom function, the properties of the geoms are not mapped from variables of a data frame, but are instead passed in as vectors. This is useful for adding small annotations (such as text labels) or if you have your data in vectors, and for some reason don't want to put them in a data frame. </p>"	"<pre>annotate(geom, x = NULL, y = NULL, xmin = NULL, xmax = NULL,<br />   ymin = NULL, ymax = NULL, xend = NULL, yend = NULL, ...,<br />   na.rm = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>geom</code></td> <td> <p>name of geom to use for annotation</p> </td> </tr> <tr valign='top'> <td><code>x, y, xmin, ymin, xmax, ymax, xend, yend</code></td> <td> <p>positioning aesthetics - you must specify at least one of these.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> </table> "	FALSE
"annotation_custom"	"ggplot2"	"Annotation: Custom grob"	"<p>This is a special geom intended for use as static annotations that are the same in every panel. These annotations will not affect scales (i.e. the x and y axes will not grow to cover the range of the grob, and the grob will not be modified by any ggplot settings or mappings). </p>"	"<pre>annotation_custom(grob, xmin = -Inf, xmax = Inf, ymin = -Inf,<br />   ymax = Inf) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>grob</code></td> <td> <p>grob to display</p> </td> </tr> <tr valign='top'> <td><code>xmin, xmax</code></td> <td> <p>x location (in data coordinates) giving horizontal location of raster</p> </td> </tr> <tr valign='top'> <td><code>ymin, ymax</code></td> <td> <p>y location (in data coordinates) giving vertical location of raster</p> </td> </tr> </table> "	FALSE
"annotation_logticks"	"ggplot2"	"Annotation: log tick marks"	"<p>This annotation adds log tick marks with diminishing spacing. These tick marks probably make sense only for base 10. </p>"	"<pre>annotation_logticks(base = 10, sides = 'bl', scaled = TRUE,<br />   short = unit(0.1, 'cm'), mid = unit(0.2, 'cm'), long = unit(0.3, 'cm'),<br />   colour = 'black', size = 0.5, linetype = 1, alpha = 1, color = NULL,<br />   ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>base</code></td> <td> <p>the base of the log (default 10)</p> </td> </tr> <tr valign='top'> <td><code>sides</code></td> <td> <p>a string that controls which sides of the plot the log ticks appear on. It can be set to a string containing any of <code>'trbl'</code>, for top, right, bottom, and left.</p> </td> </tr> <tr valign='top'> <td><code>scaled</code></td> <td> <p>is the data already log-scaled? This should be <code>TRUE</code> (default) when the data is already transformed with <code>log10()</code> or when using <code>scale_y_log10</code>. It should be <code>FALSE</code> when using <code>coord_trans(y = 'log10')</code>.</p> </td> </tr> <tr valign='top'> <td><code>short</code></td> <td> <p>a <code>unit</code> object specifying the length of the short tick marks</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>a <code>unit</code> object specifying the length of the middle tick marks. In base 10, these are the '5' ticks.</p> </td> </tr> <tr valign='top'> <td><code>long</code></td> <td> <p>a <code>unit</code> object specifying the length of the long tick marks. In base 10, these are the '1' (or '10') ticks.</p> </td> </tr> <tr valign='top'> <td><code>colour</code></td> <td> <p>Colour of the tick marks.</p> </td> </tr> <tr valign='top'> <td><code>size</code></td> <td> <p>Thickness of tick marks, in mm.</p> </td> </tr> <tr valign='top'> <td><code>linetype</code></td> <td> <p>Linetype of tick marks (<code>solid</code>, <code>dashed</code>, etc.)</p> </td> </tr> <tr valign='top'> <td><code>alpha</code></td> <td> <p>The transparency of the tick marks.</p> </td> </tr> <tr valign='top'> <td><code>color</code></td> <td> <p>An alias for <code>colour</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other parameters passed on to the layer</p> </td> </tr> </table> "	FALSE
"annotation_map"	"ggplot2"	"Annotation: a maps"	"<p>Display a fixed map on a plot. </p>"	"<pre>annotation_map(map, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>map</code></td> <td> <p>data frame representing a map.  Most map objects can be converted into the right format by using <code>fortify</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments used to modify aesthetics</p> </td> </tr> </table> "	FALSE
"annotation_raster"	"ggplot2"	"Annotation: high-performance rectangular tiling"	"<p>This is a special version of <code>geom_raster</code> optimised for static annotations that are the same in every panel. These annotations will not affect scales (i.e. the x and y axes will not grow to cover the range of the raster, and the raster must already have its own colours). This is useful for adding bitmap images. </p>"	"<pre>annotation_raster(raster, xmin, xmax, ymin, ymax, interpolate = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>raster</code></td> <td> <p>raster object to display</p> </td> </tr> <tr valign='top'> <td><code>xmin, xmax</code></td> <td> <p>x location (in data coordinates) giving horizontal location of raster</p> </td> </tr> <tr valign='top'> <td><code>ymin, ymax</code></td> <td> <p>y location (in data coordinates) giving vertical location of raster</p> </td> </tr> <tr valign='top'> <td><code>interpolate</code></td> <td> <p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code> (the default) don't interpolate.</p> </td> </tr> </table> "	FALSE
"autoplot"	"ggplot2"	"Create a complete ggplot appropriate to a particular data type"	"<p><code>autoplot</code> uses ggplot2 to draw a particular plot for an object of a particular class in a single command. This defines the S3 generic that other classes and packages can extend. </p>"	"<pre>autoplot(object, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>object</code></td> <td> <p>an object, whose class will determine the behaviour of autoplot</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed to specific methods</p> </td> </tr> </table> "	FALSE
"borders"	"ggplot2"	"Create a layer of map borders"	"<p>This is a quick and dirty way to get map data (from the maps package) on to your plot. This is a good place to start if you need some crude reference lines, but you'll typically want something more sophisticated for communication graphics. </p>"	"<pre>borders(database = 'world', regions = '.', fill = NA, colour = 'grey50',<br />   xlim = NULL, ylim = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>database</code></td> <td> <p>map data, see <code>map</code> for details</p> </td> </tr> <tr valign='top'> <td><code>regions</code></td> <td> <p>map region</p> </td> </tr> <tr valign='top'> <td><code>fill</code></td> <td> <p>fill colour</p> </td> </tr> <tr valign='top'> <td><code>colour</code></td> <td> <p>border colour</p> </td> </tr> <tr valign='top'> <td><code>xlim, ylim</code></td> <td> <p>latitudinal and logitudinal range for extracting map polygons, see <code>map</code> for details.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed onto <code>geom_polygon</code></p> </td> </tr> </table> "	FALSE
"aes_colour_fill_alpha"	"ggplot2"	"Colour related aesthetics: colour, fill and alpha"	"<p>This page demonstrates the usage of a sub-group of aesthetics; colour, fill and alpha. </p>"	NA	NA	FALSE
"aes_colour_fill_alpha"	"ggplot2"	"Colour related aesthetics: colour, fill and alpha"	"<p>This page demonstrates the usage of a sub-group of aesthetics; colour, fill and alpha. </p>"	NA	NA	FALSE
"coord_cartesian"	"ggplot2"	"Cartesian coordinates"	"<p>The Cartesian coordinate system is the most familiar, and common, type of coordinate system. Setting limits on the coordinate system will zoom the plot (like you're looking at it with a magnifying glass), and will not change the underlying data like setting limits on a scale will. </p>"	"<pre>coord_cartesian(xlim = NULL, ylim = NULL, expand = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>xlim, ylim</code></td> <td> <p>Limits for the x and y axes.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>If <code>TRUE</code>, the default, adds a small expansion factor to the limits to ensure that data and axes don't overlap. If <code>FALSE</code>, limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p> </td> </tr> </table> "	FALSE
"coord_fixed"	"ggplot2"	"Cartesian coordinates with fixed \"aspect ratio\""	"<p>A fixed scale coordinate system forces a specified ratio between the physical representation of data units on the axes. The ratio represents the number of units on the y-axis equivalent to one unit on the x-axis. The default, <code>ratio = 1</code>, ensures that one unit on the x-axis is the same length as one unit on the y-axis. Ratios higher than one make units on the y axis longer than units on the x-axis, and vice versa. This is similar to <code>eqscplot</code>, but it works for all types of graphics. </p>"	"<pre>coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>ratio</code></td> <td> <p>aspect ratio, expressed as <code>y / x</code></p> </td> </tr> <tr valign='top'> <td><code>xlim</code></td> <td> <p>Limits for the x and y axes.</p> </td> </tr> <tr valign='top'> <td><code>ylim</code></td> <td> <p>Limits for the x and y axes.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>If <code>TRUE</code>, the default, adds a small expansion factor to the limits to ensure that data and axes don't overlap. If <code>FALSE</code>, limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p> </td> </tr> </table> "	FALSE
"coord_fixed"	"ggplot2"	"Cartesian coordinates with fixed \"aspect ratio\""	"<p>A fixed scale coordinate system forces a specified ratio between the physical representation of data units on the axes. The ratio represents the number of units on the y-axis equivalent to one unit on the x-axis. The default, <code>ratio = 1</code>, ensures that one unit on the x-axis is the same length as one unit on the y-axis. Ratios higher than one make units on the y axis longer than units on the x-axis, and vice versa. This is similar to <code>eqscplot</code>, but it works for all types of graphics. </p>"	"<pre>coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>ratio</code></td> <td> <p>aspect ratio, expressed as <code>y / x</code></p> </td> </tr> <tr valign='top'> <td><code>xlim</code></td> <td> <p>Limits for the x and y axes.</p> </td> </tr> <tr valign='top'> <td><code>ylim</code></td> <td> <p>Limits for the x and y axes.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>If <code>TRUE</code>, the default, adds a small expansion factor to the limits to ensure that data and axes don't overlap. If <code>FALSE</code>, limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p> </td> </tr> </table> "	FALSE
"coord_flip"	"ggplot2"	"Cartesian coordinates with x and y flipped"	"<p>Flip cartesian coordinates so that horizontal becomes vertical, and vertical, horizontal. This is primarily useful for converting geoms and statistics which display y conditional on x, to x conditional on y. </p>"	"<pre>coord_flip(xlim = NULL, ylim = NULL, expand = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>xlim</code></td> <td> <p>Limits for the x and y axes.</p> </td> </tr> <tr valign='top'> <td><code>ylim</code></td> <td> <p>Limits for the x and y axes.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>If <code>TRUE</code>, the default, adds a small expansion factor to the limits to ensure that data and axes don't overlap. If <code>FALSE</code>, limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p> </td> </tr> </table> "	FALSE
"coord_map"	"ggplot2"	"Map projections"	"<p><code>coord_map</code> projects a portion of the earth, which is approximately spherical, onto a flat 2D plane using any projection defined by the <code>mapproj</code> package. Map projections do not, in general, preserve straight lines, so this requires considerable computation. <code>coord_quickmap</code> is a quick approximation that does preserve straight lines. It works best for smaller areas closer to the equator. </p>"	"<pre>coord_map(projection = 'mercator', ..., parameters = NULL,<br />   orientation = NULL, xlim = NULL, ylim = NULL)<br />coord_quickmap(xlim = NULL, ylim = NULL, expand = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>projection</code></td> <td> <p>projection to use, see <code>mapproject</code> for list</p> </td> </tr> <tr valign='top'> <td><code>..., parameters</code></td> <td> <p>Other arguments passed on to <code>mapproject</code>. Use <code>...</code> for named parameters to the projection, and <code>parameters</code> for unnamed parameters. <code>...</code> is ignored if the <code>parameters</code> argument is present.</p> </td> </tr> <tr valign='top'> <td><code>orientation</code></td> <td> <p>projection orientation, which defaults to <code>c(90, 0, mean(range(x)))</code>.  This is not optimal for many projections, so you will have to supply your own. See <code>mapproject</code> for more information.</p> </td> </tr> <tr valign='top'> <td><code>xlim, ylim</code></td> <td> <p>Manually specific x/y limits (in degrees of longitude/latitude)</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>If <code>TRUE</code>, the default, adds a small expansion factor to the limits to ensure that data and axes don't overlap. If <code>FALSE</code>, limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p> </td> </tr> </table> "	FALSE
"coord_polar"	"ggplot2"	"Polar coordinates"	"<p>The polar coordinate system is most commonly used for pie charts, which are a stacked bar chart in polar coordinates. </p>"	"<pre>coord_polar(theta = 'x', start = 0, direction = 1) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>theta</code></td> <td> <p>variable to map angle to (<code>x</code> or <code>y</code>)</p> </td> </tr> <tr valign='top'> <td><code>start</code></td> <td> <p>offset of starting point from 12 o'clock in radians</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>1, clockwise; -1, anticlockwise</p> </td> </tr> </table> "	FALSE
"coord_map"	"ggplot2"	"Map projections"	"<p><code>coord_map</code> projects a portion of the earth, which is approximately spherical, onto a flat 2D plane using any projection defined by the <code>mapproj</code> package. Map projections do not, in general, preserve straight lines, so this requires considerable computation. <code>coord_quickmap</code> is a quick approximation that does preserve straight lines. It works best for smaller areas closer to the equator. </p>"	"<pre>coord_map(projection = 'mercator', ..., parameters = NULL,<br />   orientation = NULL, xlim = NULL, ylim = NULL)<br />coord_quickmap(xlim = NULL, ylim = NULL, expand = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>projection</code></td> <td> <p>projection to use, see <code>mapproject</code> for list</p> </td> </tr> <tr valign='top'> <td><code>..., parameters</code></td> <td> <p>Other arguments passed on to <code>mapproject</code>. Use <code>...</code> for named parameters to the projection, and <code>parameters</code> for unnamed parameters. <code>...</code> is ignored if the <code>parameters</code> argument is present.</p> </td> </tr> <tr valign='top'> <td><code>orientation</code></td> <td> <p>projection orientation, which defaults to <code>c(90, 0, mean(range(x)))</code>.  This is not optimal for many projections, so you will have to supply your own. See <code>mapproject</code> for more information.</p> </td> </tr> <tr valign='top'> <td><code>xlim, ylim</code></td> <td> <p>Manually specific x/y limits (in degrees of longitude/latitude)</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>If <code>TRUE</code>, the default, adds a small expansion factor to the limits to ensure that data and axes don't overlap. If <code>FALSE</code>, limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p> </td> </tr> </table> "	FALSE
"coord_trans"	"ggplot2"	"Transformed Cartesian coordinate system"	"<p><code>coord_trans</code> is different to scale transformations in that it occurs after statistical transformation and will affect the visual appearance of geoms - there is no guarantee that straight lines will continue to be straight. </p>"	"<pre>coord_trans(x = 'identity', y = 'identity', limx = NULL, limy = NULL,<br />   xtrans, ytrans) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y</code></td> <td> <p>transformers for x and y axes</p> </td> </tr> <tr valign='top'> <td><code>limx, limy</code></td> <td> <p>limits for x and y axes. (Named so for backward compatibility)</p> </td> </tr> <tr valign='top'> <td><code>xtrans, ytrans</code></td> <td> <p>Deprecated; use <code>x</code> and <code>y</code> instead.</p> </td> </tr> </table> "	FALSE
"cut_interval"	"ggplot2"	"Discretise numeric data into categorical"	"<p><code>cut_interval</code> makes <code>n</code> groups with equal range, <code>cut_number</code> makes <code>n</code> groups with (approximately) equal numbers of observations; <code>cut_width</code> makes groups of width <code>width</code>. </p>"	"<pre>cut_interval(x, n = NULL, length = NULL, ...)<br />cut_number(x, n = NULL, ...)<br />cut_width(x, width, center = NULL, boundary = NULL, closed = c('right',<br />   'left')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric vector</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of intervals to create, OR</p> </td> </tr> <tr valign='top'> <td><code>length</code></td> <td> <p>length of each interval</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>cut</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>The bin width.</p> </td> </tr> <tr valign='top'> <td><code>center, boundary</code></td> <td> <p>Specify either the position of edge or the center of a bin. Since all bins are aligned, specifying the position of a single bin (which doesn't need to be in the range of the data) affects the location of all bins. If not specified, uses the 'tile layers algorithm', and sets the boundary to half of the binwidth. </p> <p>To center on integers, <code>width = 1</code> and <code>center = 0</code>. <code>boundary = 0.5</code>.</p> </td> </tr> <tr valign='top'> <td><code>closed</code></td> <td> <p>One of <code>'right'</code> or <code>'left'</code> indicating whether right or left edges of bins are included in the bin.</p> </td> </tr> </table> "	FALSE
"cut_interval"	"ggplot2"	"Discretise numeric data into categorical"	"<p><code>cut_interval</code> makes <code>n</code> groups with equal range, <code>cut_number</code> makes <code>n</code> groups with (approximately) equal numbers of observations; <code>cut_width</code> makes groups of width <code>width</code>. </p>"	"<pre>cut_interval(x, n = NULL, length = NULL, ...)<br />cut_number(x, n = NULL, ...)<br />cut_width(x, width, center = NULL, boundary = NULL, closed = c('right',<br />   'left')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric vector</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of intervals to create, OR</p> </td> </tr> <tr valign='top'> <td><code>length</code></td> <td> <p>length of each interval</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>cut</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>The bin width.</p> </td> </tr> <tr valign='top'> <td><code>center, boundary</code></td> <td> <p>Specify either the position of edge or the center of a bin. Since all bins are aligned, specifying the position of a single bin (which doesn't need to be in the range of the data) affects the location of all bins. If not specified, uses the 'tile layers algorithm', and sets the boundary to half of the binwidth. </p> <p>To center on integers, <code>width = 1</code> and <code>center = 0</code>. <code>boundary = 0.5</code>.</p> </td> </tr> <tr valign='top'> <td><code>closed</code></td> <td> <p>One of <code>'right'</code> or <code>'left'</code> indicating whether right or left edges of bins are included in the bin.</p> </td> </tr> </table> "	FALSE
"cut_interval"	"ggplot2"	"Discretise numeric data into categorical"	"<p><code>cut_interval</code> makes <code>n</code> groups with equal range, <code>cut_number</code> makes <code>n</code> groups with (approximately) equal numbers of observations; <code>cut_width</code> makes groups of width <code>width</code>. </p>"	"<pre>cut_interval(x, n = NULL, length = NULL, ...)<br />cut_number(x, n = NULL, ...)<br />cut_width(x, width, center = NULL, boundary = NULL, closed = c('right',<br />   'left')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric vector</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of intervals to create, OR</p> </td> </tr> <tr valign='top'> <td><code>length</code></td> <td> <p>length of each interval</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>cut</code></p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>The bin width.</p> </td> </tr> <tr valign='top'> <td><code>center, boundary</code></td> <td> <p>Specify either the position of edge or the center of a bin. Since all bins are aligned, specifying the position of a single bin (which doesn't need to be in the range of the data) affects the location of all bins. If not specified, uses the 'tile layers algorithm', and sets the boundary to half of the binwidth. </p> <p>To center on integers, <code>width = 1</code> and <code>center = 0</code>. <code>boundary = 0.5</code>.</p> </td> </tr> <tr valign='top'> <td><code>closed</code></td> <td> <p>One of <code>'right'</code> or <code>'left'</code> indicating whether right or left edges of bins are included in the bin.</p> </td> </tr> </table> "	FALSE
"sec_axis"	"ggplot2"	"Specify a secondary axis"	"<p>This function is used in conjunction with a position scale to create a secondary axis, positioned opposite of the primary axis. All secondary axes must be based on a one-to-one transformation of the primary axes. </p>"	"<pre>sec_axis(trans = NULL, name = waiver(), breaks = waiver(),<br />   labels = waiver())<br />dup_axis(trans = ~., name = derive(), breaks = derive(),<br />   labels = derive())<br />derive() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>trans</code></td> <td> <p>A transformation formula</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the secondary axis</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p>A numeric vector of positions </p> </li> <li> <p>A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p>A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p>A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> </table> "	FALSE
"diamonds"	"ggplot2"	"Prices of 50,000 round cut diamonds"	"<p>A dataset containing the prices and other attributes of almost 54,000 diamonds. The variables are as follows: </p>"	"<pre>diamonds </pre>"	NA	FALSE
"sec_axis"	"ggplot2"	"Specify a secondary axis"	"<p>This function is used in conjunction with a position scale to create a secondary axis, positioned opposite of the primary axis. All secondary axes must be based on a one-to-one transformation of the primary axes. </p>"	"<pre>sec_axis(trans = NULL, name = waiver(), breaks = waiver(),<br />   labels = waiver())<br />dup_axis(trans = ~., name = derive(), breaks = derive(),<br />   labels = derive())<br />derive() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>trans</code></td> <td> <p>A transformation formula</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the secondary axis</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p>A numeric vector of positions </p> </li> <li> <p>A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p>A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p>A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> </table> "	FALSE
"economics"	"ggplot2"	"US economic time series"	"<p>This dataset was produced from US economic time series data available from <a href='http://research.stlouisfed.org/fred2'>http://research.stlouisfed.org/fred2</a>. <code>economics</code> is in 'wide' format, <code>economics_long</code> is in 'long' format. </p>"	"<pre>economics<br />economics_long </pre>"	NA	FALSE
"economics"	"ggplot2"	"US economic time series"	"<p>This dataset was produced from US economic time series data available from <a href='http://research.stlouisfed.org/fred2'>http://research.stlouisfed.org/fred2</a>. <code>economics</code> is in 'wide' format, <code>economics_long</code> is in 'long' format. </p>"	"<pre>economics<br />economics_long </pre>"	NA	FALSE
"element"	"ggplot2"	"Theme elements"	"<p>In conjunction with the theme system, the <code>element_</code> functions specify the display of how non-data components of the plot are a drawn. </p> <ul> <li> <p><code>element_blank</code>: draws nothing, and assigns no space. </p> </li> <li> <p><code>element_rect</code>: borders and backgrounds. </p> </li> <li> <p><code>element_line</code>: lines. </p> </li> <li> <p><code>element_text</code>: text. </p> </li> </ul>  <p><code>rel()</code> is used to specify sizes relative to the parent, <code>margins()</code> is used to specify the margins of elements. </p>"	"<pre>margin(t = 0, r = 0, b = 0, l = 0, unit = 'pt')<br />element_blank()<br />element_rect(fill = NULL, colour = NULL, size = NULL, linetype = NULL,<br />   color = NULL, inherit.blank = FALSE)<br />element_line(colour = NULL, size = NULL, linetype = NULL,<br />   lineend = NULL, color = NULL, arrow = NULL, inherit.blank = FALSE)<br />element_text(family = NULL, face = NULL, colour = NULL, size = NULL,<br />   hjust = NULL, vjust = NULL, angle = NULL, lineheight = NULL,<br />   color = NULL, margin = NULL, debug = NULL, inherit.blank = FALSE)<br />rel(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>t, r, b, l</code></td> <td> <p>Dimensions of each margin. (To remember order, think trouble).</p> </td> </tr> <tr valign='top'> <td><code>unit</code></td> <td> <p>Default units of dimensions. Defaults to 'pt' so it can be most easily scaled with the text.</p> </td> </tr> <tr valign='top'> <td><code>fill</code></td> <td> <p>Fill colour.</p> </td> </tr> <tr valign='top'> <td><code>colour, color</code></td> <td> <p>Line/border colour. Color is an alias for colour.</p> </td> </tr> <tr valign='top'> <td><code>size</code></td> <td> <p>Line/border size in mm; text size in pts.</p> </td> </tr> <tr valign='top'> <td><code>linetype</code></td> <td> <p>Line type. An integer (0:8), a name (blank, solid, dashed, dotted, dotdash, longdash, twodash), or a string with an even number (up to eight) of hexadecimal digits which give the lengths in consecutive positions in the string.</p> </td> </tr> <tr valign='top'> <td><code>inherit.blank</code></td> <td> <p>Should this element inherit the existence of an <code>element_blank</code> among its parents? If <code>TRUE</code> the existence of a blank element among its parents will cause this element to be blank as well. If <code>FALSE</code> any blank parent element will be ignored when calculating final element state.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>arrow</code></td> <td> <p>Arrow specification, as created by <code>arrow</code></p> </td> </tr> <tr valign='top'> <td><code>family</code></td> <td> <p>Font family</p> </td> </tr> <tr valign='top'> <td><code>face</code></td> <td> <p>Font face ('plain', 'italic', 'bold', 'bold.italic')</p> </td> </tr> <tr valign='top'> <td><code>hjust</code></td> <td> <p>Horizontal justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>vjust</code></td> <td> <p>Vertical justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>angle</code></td> <td> <p>Angle (in [0, 360])</p> </td> </tr> <tr valign='top'> <td><code>lineheight</code></td> <td> <p>Line height</p> </td> </tr> <tr valign='top'> <td><code>margin</code></td> <td> <p>Margins around the text. See <code>margin</code> for more details. When creating a theme, the margins should be placed on the side of the text facing towards the center of the plot.</p> </td> </tr> <tr valign='top'> <td><code>debug</code></td> <td> <p>If <code>TRUE</code>, aids visual debugging by drawing a solid rectangle behind the complete text area, and a point where each label is anchored.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A single number specifying size relative to parent element.</p> </td> </tr> </table> "	FALSE
"element"	"ggplot2"	"Theme elements"	"<p>In conjunction with the theme system, the <code>element_</code> functions specify the display of how non-data components of the plot are a drawn. </p> <ul> <li> <p><code>element_blank</code>: draws nothing, and assigns no space. </p> </li> <li> <p><code>element_rect</code>: borders and backgrounds. </p> </li> <li> <p><code>element_line</code>: lines. </p> </li> <li> <p><code>element_text</code>: text. </p> </li> </ul>  <p><code>rel()</code> is used to specify sizes relative to the parent, <code>margins()</code> is used to specify the margins of elements. </p>"	"<pre>margin(t = 0, r = 0, b = 0, l = 0, unit = 'pt')<br />element_blank()<br />element_rect(fill = NULL, colour = NULL, size = NULL, linetype = NULL,<br />   color = NULL, inherit.blank = FALSE)<br />element_line(colour = NULL, size = NULL, linetype = NULL,<br />   lineend = NULL, color = NULL, arrow = NULL, inherit.blank = FALSE)<br />element_text(family = NULL, face = NULL, colour = NULL, size = NULL,<br />   hjust = NULL, vjust = NULL, angle = NULL, lineheight = NULL,<br />   color = NULL, margin = NULL, debug = NULL, inherit.blank = FALSE)<br />rel(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>t, r, b, l</code></td> <td> <p>Dimensions of each margin. (To remember order, think trouble).</p> </td> </tr> <tr valign='top'> <td><code>unit</code></td> <td> <p>Default units of dimensions. Defaults to 'pt' so it can be most easily scaled with the text.</p> </td> </tr> <tr valign='top'> <td><code>fill</code></td> <td> <p>Fill colour.</p> </td> </tr> <tr valign='top'> <td><code>colour, color</code></td> <td> <p>Line/border colour. Color is an alias for colour.</p> </td> </tr> <tr valign='top'> <td><code>size</code></td> <td> <p>Line/border size in mm; text size in pts.</p> </td> </tr> <tr valign='top'> <td><code>linetype</code></td> <td> <p>Line type. An integer (0:8), a name (blank, solid, dashed, dotted, dotdash, longdash, twodash), or a string with an even number (up to eight) of hexadecimal digits which give the lengths in consecutive positions in the string.</p> </td> </tr> <tr valign='top'> <td><code>inherit.blank</code></td> <td> <p>Should this element inherit the existence of an <code>element_blank</code> among its parents? If <code>TRUE</code> the existence of a blank element among its parents will cause this element to be blank as well. If <code>FALSE</code> any blank parent element will be ignored when calculating final element state.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>arrow</code></td> <td> <p>Arrow specification, as created by <code>arrow</code></p> </td> </tr> <tr valign='top'> <td><code>family</code></td> <td> <p>Font family</p> </td> </tr> <tr valign='top'> <td><code>face</code></td> <td> <p>Font face ('plain', 'italic', 'bold', 'bold.italic')</p> </td> </tr> <tr valign='top'> <td><code>hjust</code></td> <td> <p>Horizontal justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>vjust</code></td> <td> <p>Vertical justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>angle</code></td> <td> <p>Angle (in [0, 360])</p> </td> </tr> <tr valign='top'> <td><code>lineheight</code></td> <td> <p>Line height</p> </td> </tr> <tr valign='top'> <td><code>margin</code></td> <td> <p>Margins around the text. See <code>margin</code> for more details. When creating a theme, the margins should be placed on the side of the text facing towards the center of the plot.</p> </td> </tr> <tr valign='top'> <td><code>debug</code></td> <td> <p>If <code>TRUE</code>, aids visual debugging by drawing a solid rectangle behind the complete text area, and a point where each label is anchored.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A single number specifying size relative to parent element.</p> </td> </tr> </table> "	FALSE
"element"	"ggplot2"	"Theme elements"	"<p>In conjunction with the theme system, the <code>element_</code> functions specify the display of how non-data components of the plot are a drawn. </p> <ul> <li> <p><code>element_blank</code>: draws nothing, and assigns no space. </p> </li> <li> <p><code>element_rect</code>: borders and backgrounds. </p> </li> <li> <p><code>element_line</code>: lines. </p> </li> <li> <p><code>element_text</code>: text. </p> </li> </ul>  <p><code>rel()</code> is used to specify sizes relative to the parent, <code>margins()</code> is used to specify the margins of elements. </p>"	"<pre>margin(t = 0, r = 0, b = 0, l = 0, unit = 'pt')<br />element_blank()<br />element_rect(fill = NULL, colour = NULL, size = NULL, linetype = NULL,<br />   color = NULL, inherit.blank = FALSE)<br />element_line(colour = NULL, size = NULL, linetype = NULL,<br />   lineend = NULL, color = NULL, arrow = NULL, inherit.blank = FALSE)<br />element_text(family = NULL, face = NULL, colour = NULL, size = NULL,<br />   hjust = NULL, vjust = NULL, angle = NULL, lineheight = NULL,<br />   color = NULL, margin = NULL, debug = NULL, inherit.blank = FALSE)<br />rel(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>t, r, b, l</code></td> <td> <p>Dimensions of each margin. (To remember order, think trouble).</p> </td> </tr> <tr valign='top'> <td><code>unit</code></td> <td> <p>Default units of dimensions. Defaults to 'pt' so it can be most easily scaled with the text.</p> </td> </tr> <tr valign='top'> <td><code>fill</code></td> <td> <p>Fill colour.</p> </td> </tr> <tr valign='top'> <td><code>colour, color</code></td> <td> <p>Line/border colour. Color is an alias for colour.</p> </td> </tr> <tr valign='top'> <td><code>size</code></td> <td> <p>Line/border size in mm; text size in pts.</p> </td> </tr> <tr valign='top'> <td><code>linetype</code></td> <td> <p>Line type. An integer (0:8), a name (blank, solid, dashed, dotted, dotdash, longdash, twodash), or a string with an even number (up to eight) of hexadecimal digits which give the lengths in consecutive positions in the string.</p> </td> </tr> <tr valign='top'> <td><code>inherit.blank</code></td> <td> <p>Should this element inherit the existence of an <code>element_blank</code> among its parents? If <code>TRUE</code> the existence of a blank element among its parents will cause this element to be blank as well. If <code>FALSE</code> any blank parent element will be ignored when calculating final element state.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>arrow</code></td> <td> <p>Arrow specification, as created by <code>arrow</code></p> </td> </tr> <tr valign='top'> <td><code>family</code></td> <td> <p>Font family</p> </td> </tr> <tr valign='top'> <td><code>face</code></td> <td> <p>Font face ('plain', 'italic', 'bold', 'bold.italic')</p> </td> </tr> <tr valign='top'> <td><code>hjust</code></td> <td> <p>Horizontal justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>vjust</code></td> <td> <p>Vertical justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>angle</code></td> <td> <p>Angle (in [0, 360])</p> </td> </tr> <tr valign='top'> <td><code>lineheight</code></td> <td> <p>Line height</p> </td> </tr> <tr valign='top'> <td><code>margin</code></td> <td> <p>Margins around the text. See <code>margin</code> for more details. When creating a theme, the margins should be placed on the side of the text facing towards the center of the plot.</p> </td> </tr> <tr valign='top'> <td><code>debug</code></td> <td> <p>If <code>TRUE</code>, aids visual debugging by drawing a solid rectangle behind the complete text area, and a point where each label is anchored.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A single number specifying size relative to parent element.</p> </td> </tr> </table> "	FALSE
"element"	"ggplot2"	"Theme elements"	"<p>In conjunction with the theme system, the <code>element_</code> functions specify the display of how non-data components of the plot are a drawn. </p> <ul> <li> <p><code>element_blank</code>: draws nothing, and assigns no space. </p> </li> <li> <p><code>element_rect</code>: borders and backgrounds. </p> </li> <li> <p><code>element_line</code>: lines. </p> </li> <li> <p><code>element_text</code>: text. </p> </li> </ul>  <p><code>rel()</code> is used to specify sizes relative to the parent, <code>margins()</code> is used to specify the margins of elements. </p>"	"<pre>margin(t = 0, r = 0, b = 0, l = 0, unit = 'pt')<br />element_blank()<br />element_rect(fill = NULL, colour = NULL, size = NULL, linetype = NULL,<br />   color = NULL, inherit.blank = FALSE)<br />element_line(colour = NULL, size = NULL, linetype = NULL,<br />   lineend = NULL, color = NULL, arrow = NULL, inherit.blank = FALSE)<br />element_text(family = NULL, face = NULL, colour = NULL, size = NULL,<br />   hjust = NULL, vjust = NULL, angle = NULL, lineheight = NULL,<br />   color = NULL, margin = NULL, debug = NULL, inherit.blank = FALSE)<br />rel(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>t, r, b, l</code></td> <td> <p>Dimensions of each margin. (To remember order, think trouble).</p> </td> </tr> <tr valign='top'> <td><code>unit</code></td> <td> <p>Default units of dimensions. Defaults to 'pt' so it can be most easily scaled with the text.</p> </td> </tr> <tr valign='top'> <td><code>fill</code></td> <td> <p>Fill colour.</p> </td> </tr> <tr valign='top'> <td><code>colour, color</code></td> <td> <p>Line/border colour. Color is an alias for colour.</p> </td> </tr> <tr valign='top'> <td><code>size</code></td> <td> <p>Line/border size in mm; text size in pts.</p> </td> </tr> <tr valign='top'> <td><code>linetype</code></td> <td> <p>Line type. An integer (0:8), a name (blank, solid, dashed, dotted, dotdash, longdash, twodash), or a string with an even number (up to eight) of hexadecimal digits which give the lengths in consecutive positions in the string.</p> </td> </tr> <tr valign='top'> <td><code>inherit.blank</code></td> <td> <p>Should this element inherit the existence of an <code>element_blank</code> among its parents? If <code>TRUE</code> the existence of a blank element among its parents will cause this element to be blank as well. If <code>FALSE</code> any blank parent element will be ignored when calculating final element state.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>arrow</code></td> <td> <p>Arrow specification, as created by <code>arrow</code></p> </td> </tr> <tr valign='top'> <td><code>family</code></td> <td> <p>Font family</p> </td> </tr> <tr valign='top'> <td><code>face</code></td> <td> <p>Font face ('plain', 'italic', 'bold', 'bold.italic')</p> </td> </tr> <tr valign='top'> <td><code>hjust</code></td> <td> <p>Horizontal justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>vjust</code></td> <td> <p>Vertical justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>angle</code></td> <td> <p>Angle (in [0, 360])</p> </td> </tr> <tr valign='top'> <td><code>lineheight</code></td> <td> <p>Line height</p> </td> </tr> <tr valign='top'> <td><code>margin</code></td> <td> <p>Margins around the text. See <code>margin</code> for more details. When creating a theme, the margins should be placed on the side of the text facing towards the center of the plot.</p> </td> </tr> <tr valign='top'> <td><code>debug</code></td> <td> <p>If <code>TRUE</code>, aids visual debugging by drawing a solid rectangle behind the complete text area, and a point where each label is anchored.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A single number specifying size relative to parent element.</p> </td> </tr> </table> "	FALSE
"expand_limits"	"ggplot2"	"Expand the plot limits, using data"	"<p>Sometimes you may want to ensure limits include a single value, for all panels or all plots.  This function is a thin wrapper around <code>geom_blank</code> that makes it easy to add such values. </p>"	"<pre>expand_limits(...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>...</code></td> <td> <p>named list of aesthetics specifying the value (or values) that should be included in each scale.</p> </td> </tr></table> "	FALSE
"facet_grid"	"ggplot2"	"Lay out panels in a grid"	"<p><code>facet_grid</code> forms a matrix of panels defined by row and column facetting variables. It is most useful when you have two discrete variables, and all combinations of the variables exist in the data. </p>"	"<pre>facet_grid(facets, margins = FALSE, scales = 'fixed', space = 'fixed',<br />   shrink = TRUE, labeller = 'label_value', as.table = TRUE,<br />   switch = NULL, drop = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>facets</code></td> <td> <p>a formula with the rows (of the tabular display) on the LHS and the columns (of the tabular display) on the RHS; the dot in the formula is used to indicate there should be no faceting on this dimension (either row or column). The formula can also be provided as a string instead of a classical formula object</p> </td> </tr> <tr valign='top'> <td><code>margins</code></td> <td> <p>either a logical value or a character vector. Margins are additional facets which contain all the data for each of the possible values of the faceting variables. If <code>FALSE</code>, no additional facets are included (the default). If <code>TRUE</code>, margins are included for all faceting variables. If specified as a character vector, it is the names of variables for which margins are to be created.</p> </td> </tr> <tr valign='top'> <td><code>scales</code></td> <td> <p>Are scales shared across all facets (the default, <code>'fixed'</code>), or do they vary across rows (<code>'free_x'</code>), columns (<code>'free_y'</code>), or both rows and columns (<code>'free'</code>)</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>If <code>'fixed'</code>, the default, all panels have the same size. If <code>'free_y'</code> their height will be proportional to the length of the y scale; if <code>'free_x'</code> their width will be proportional to the length of the x scale; or if <code>'free'</code> both height and width will vary.  This setting has no effect unless the appropriate scales also vary.</p> </td> </tr> <tr valign='top'> <td><code>shrink</code></td> <td> <p>If <code>TRUE</code>, will shrink scales to fit output of statistics, not raw data. If <code>FALSE</code>, will be range of raw data before statistical summary.</p> </td> </tr> <tr valign='top'> <td><code>labeller</code></td> <td> <p>A function that takes one data frame of labels and returns a list or data frame of character vectors. Each input column corresponds to one factor. Thus there will be more than one with formulae of the type <code>~cyl + am</code>. Each output column gets displayed as one separate line in the strip label. This function should inherit from the 'labeller' S3 class for compatibility with <code>labeller()</code>. See <code>label_value</code> for more details and pointers to other options.</p> </td> </tr> <tr valign='top'> <td><code>as.table</code></td> <td> <p>If <code>TRUE</code>, the default, the facets are laid out like a table with highest values at the bottom-right. If <code>FALSE</code>, the facets are laid out like a plot with the highest value at the top-right.</p> </td> </tr> <tr valign='top'> <td><code>switch</code></td> <td> <p>By default, the labels are displayed on the top and right of the plot. If <code>'x'</code>, the top labels will be displayed to the bottom. If <code>'y'</code>, the right-hand side labels will be displayed to the left. Can also be set to <code>'both'</code>.</p> </td> </tr> <tr valign='top'> <td><code>drop</code></td> <td> <p>If <code>TRUE</code>, the default, all factor levels not used in the data will automatically be dropped. If <code>FALSE</code>, all factor levels will be shown, regardless of whether or not they appear in the data.</p> </td> </tr> </table> "	FALSE
"facet_wrap"	"ggplot2"	"Wrap a 1d ribbon of panels into 2d"	"<p><code>facet_wrap</code> wraps a 1d sequence of panels into 2d. This is generally a better use of screen space than <code>facet_grid</code> because most displays are roughly rectangular. </p>"	"<pre>facet_wrap(facets, nrow = NULL, ncol = NULL, scales = 'fixed',<br />   shrink = TRUE, labeller = 'label_value', as.table = TRUE,<br />   switch = NULL, drop = TRUE, dir = 'h', strip.position = 'top') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>facets</code></td> <td> <p>Either a formula or character vector. Use either a one sided formula, <code>~a + b</code>, or a character vector, <code>c('a', 'b')</code>.</p> </td> </tr> <tr valign='top'> <td><code>nrow, ncol</code></td> <td> <p>Number of rows and columns.</p> </td> </tr> <tr valign='top'> <td><code>scales</code></td> <td> <p>should Scales be fixed (<code>'fixed'</code>, the default), free (<code>'free'</code>), or free in one dimension (<code>'free_x'</code>, <code>'free_y'</code>).</p> </td> </tr> <tr valign='top'> <td><code>shrink</code></td> <td> <p>If <code>TRUE</code>, will shrink scales to fit output of statistics, not raw data. If <code>FALSE</code>, will be range of raw data before statistical summary.</p> </td> </tr> <tr valign='top'> <td><code>labeller</code></td> <td> <p>A function that takes one data frame of labels and returns a list or data frame of character vectors. Each input column corresponds to one factor. Thus there will be more than one with formulae of the type <code>~cyl + am</code>. Each output column gets displayed as one separate line in the strip label. This function should inherit from the 'labeller' S3 class for compatibility with <code>labeller()</code>. See <code>label_value</code> for more details and pointers to other options.</p> </td> </tr> <tr valign='top'> <td><code>as.table</code></td> <td> <p>If <code>TRUE</code>, the default, the facets are laid out like a table with highest values at the bottom-right. If <code>FALSE</code>, the facets are laid out like a plot with the highest value at the top-right.</p> </td> </tr> <tr valign='top'> <td><code>switch</code></td> <td> <p>By default, the labels are displayed on the top and right of the plot. If <code>'x'</code>, the top labels will be displayed to the bottom. If <code>'y'</code>, the right-hand side labels will be displayed to the left. Can also be set to <code>'both'</code>.</p> </td> </tr> <tr valign='top'> <td><code>drop</code></td> <td> <p>If <code>TRUE</code>, the default, all factor levels not used in the data will automatically be dropped. If <code>FALSE</code>, all factor levels will be shown, regardless of whether or not they appear in the data.</p> </td> </tr> <tr valign='top'> <td><code>dir</code></td> <td> <p>Direction: either 'h' for horizontal, the default, or 'v', for vertical.</p> </td> </tr> <tr valign='top'> <td><code>strip.position</code></td> <td> <p>By default, the labels are displayed on the top of the plot. Using <code>strip.position</code> it is possible to place the labels on either of the four sides by setting <code>strip.position = c('top', 'bottom', 'left', 'right')</code></p> </td> </tr> </table> "	FALSE
"faithfuld"	"ggplot2"	"2d density estimate of Old Faithful data"	"<p>A 2d density estimate of the waiting and eruptions variables data faithful. </p>"	"<pre>faithfuld </pre>"	NA	FALSE
"aes_colour_fill_alpha"	"ggplot2"	"Colour related aesthetics: colour, fill and alpha"	"<p>This page demonstrates the usage of a sub-group of aesthetics; colour, fill and alpha. </p>"	NA	NA	FALSE
"print.ggproto"	"ggplot2"	"Format or print a ggproto object"	"<p>If a ggproto object has a <code>$print</code> method, this will call that method. Otherwise, it will print out the members of the object, and optionally, the members of the inherited objects. </p>"	"<pre>## S3 method for class 'ggproto' print(x, ..., flat = TRUE)<br />## S3 method for class 'ggproto' format(x, ..., flat = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A ggproto object to print.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If the ggproto object has a <code>print</code> method, further arguments will be passed to it. Otherwise, these arguments are unused.</p> </td> </tr> <tr valign='top'> <td><code>flat</code></td> <td> <p>If <code>TRUE</code> (the default), show a flattened list of all local and inherited members. If <code>FALSE</code>, show the inheritance hierarchy.</p> </td> </tr> </table> "	FALSE
"fortify"	"ggplot2"	"Fortify a model with data."	"<p>Rather than using this function, I now recommend using the <span class='pkg'>broom</span> package, which implements a much wider range of methods. <code>fortify</code> may be deprecated in the future. </p>"	"<pre>fortify(model, data, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>model</code></td> <td> <p>model or other R object to convert to data frame</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>original dataset, if needed</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed to methods</p> </td> </tr> </table> "	FALSE
"geom_abline"	"ggplot2"	"Reference lines: horizontal, vertical, and diagonal"	"<p>These geoms add reference lines (sometimes called rules) to a plot, either horizontal, vertical, or diagonal (specified by slope and intercept). These are useful for annotating plots. </p>"	"<pre>geom_abline(mapping = NULL, data = NULL, ..., slope, intercept,<br />   na.rm = FALSE, show.legend = NA)<br />geom_hline(mapping = NULL, data = NULL, ..., yintercept, na.rm = FALSE,<br />   show.legend = NA)<br />geom_vline(mapping = NULL, data = NULL, ..., xintercept, na.rm = FALSE,<br />   show.legend = NA) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>xintercept, yintercept, slope, intercept</code></td> <td> <p>Parameters that control the position of the line. If these are set, <code>data</code>, <code>mapping</code> and <code>show.legend</code> are overridden</p> </td> </tr> </table> "	FALSE
"geom_ribbon"	"ggplot2"	"Ribbons and area plots"	"<p>For each x value, <code>geom_ribbon</code> displays a y interval defined by <code>ymin</code> and <code>ymax</code>. <code>geom_area</code> is a special case of <code>geom_ribbon</code>, where the <code>ymin</code> is fixed to 0. </p>"	"<pre>geom_ribbon(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_area(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'stack', na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_bar"	"ggplot2"	"Bars charts"	"<p>There are two types of bar charts: <code>geom_bar</code> makes the height of the bar proportional to the number of cases in each group (or if the <code>weight</code> aethetic is supplied, the sum of the weights). If you want the heights of the bars to represent values in the data, use geom_col instead. <code>geom_bar</code> uses <code>stat_count</code> by default: it counts the  number of cases at each x position. <code>geom_col</code> uses <code>stat_identity</code>: it leaves the data as is. </p>"	"<pre>geom_bar(mapping = NULL, data = NULL, stat = 'count',<br />   position = 'stack', ..., width = NULL, binwidth = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />geom_col(mapping = NULL, data = NULL, position = 'stack', ...,<br />   width = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_count(mapping = NULL, data = NULL, geom = 'bar',<br />   position = 'stack', ..., width = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Bar width. By default, set to 90% of the resolution of the data.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p><code>geom_bar</code> no longer has a binwidth argument - if you use it you'll get an warning telling to you use <code>geom_histogram</code> instead.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Override the default connection between <code>geom_bar</code> and <code>stat_count</code>.</p> </td> </tr> </table> "	FALSE
"geom_bin2d"	"ggplot2"	"Heatmap of 2d bin counts"	"<p>Divides the plane into rectangles, counts the number of cases in each rectangle, and then (by default) maps the number of cases to the rectangle's fill. This is a useful alternative to <code>geom_point</code> in the presence of overplotting. </p>"	"<pre>geom_bin2d(mapping = NULL, data = NULL, stat = 'bin2d',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_bin_2d(mapping = NULL, data = NULL, geom = 'tile',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, drop = TRUE,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_bin2d</code> and <code>stat_bin2d</code>.</p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>numeric vector giving number of bins in both vertical and horizontal directions. Set to 30 by default.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>Numeric vector giving bin width in both vertical and horizontal directions. Overrides <code>bins</code> if both set.</p> </td> </tr> <tr valign='top'> <td><code>drop</code></td> <td> <p>if <code>TRUE</code> removes all cells with 0 counts.</p> </td> </tr> </table> "	FALSE
"geom_blank"	"ggplot2"	"Draw nothing"	"<p>The blank geom draws nothing, but can be a useful way of ensuring common scales between different plots. See <code>expand_limits</code> for more details. </p>"	"<pre>geom_blank(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_boxplot"	"ggplot2"	"A box and whiskers plot (in the style of Tukey)"	"<p>The boxplot compactly displays the distribution of a continuous variable. It visualises five summary statistics (the median, two hinges and two whiskers), and all 'outlying' points individually. </p>"	"<pre>geom_boxplot(mapping = NULL, data = NULL, stat = 'boxplot',<br />   position = 'dodge', ..., outlier.colour = NULL, outlier.color = NULL,<br />   outlier.fill = NULL, outlier.shape = 19, outlier.size = 1.5,<br />   outlier.stroke = 0.5, outlier.alpha = NULL, notch = FALSE,<br />   notchwidth = 0.5, varwidth = FALSE, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_boxplot(mapping = NULL, data = NULL, geom = 'boxplot',<br />   position = 'dodge', ..., coef = 1.5, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>outlier.colour, outlier.color, outlier.fill, outlier.shape, outlier.size, outlier.stroke, outlier.alpha</code></td> <td> <p>Default aesthetics for outliers. Set to <code>NULL</code> to inherit from the aesthetics used for the box. </p> <p>In the unlikely event you specify both US and UK spellings of colour, the US spelling will take precedence.</p> </td> </tr> <tr valign='top'> <td><code>notch</code></td> <td> <p>if <code>FALSE</code> (default) make a standard box plot. If <code>TRUE</code>, make a notched box plot. Notches are used to compare groups; if the notches of two boxes do not overlap, this suggests that the medians are significantly different.</p> </td> </tr> <tr valign='top'> <td><code>notchwidth</code></td> <td> <p>for a notched box plot, width of the notch relative to the body (default 0.5)</p> </td> </tr> <tr valign='top'> <td><code>varwidth</code></td> <td> <p>if <code>FALSE</code> (default) make a standard box plot. If <code>TRUE</code>, boxes are drawn with widths proportional to the square-roots of the number of observations in the groups (possibly weighted, using the <code>weight</code> aesthetic).</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_boxplot</code> and <code>stat_boxplot</code>.</p> </td> </tr> <tr valign='top'> <td><code>coef</code></td> <td> <p>length of the whiskers as multiple of IQR.  Defaults to 1.5</p> </td> </tr> </table> "	FALSE
"geom_bar"	"ggplot2"	"Bars charts"	"<p>There are two types of bar charts: <code>geom_bar</code> makes the height of the bar proportional to the number of cases in each group (or if the <code>weight</code> aethetic is supplied, the sum of the weights). If you want the heights of the bars to represent values in the data, use geom_col instead. <code>geom_bar</code> uses <code>stat_count</code> by default: it counts the  number of cases at each x position. <code>geom_col</code> uses <code>stat_identity</code>: it leaves the data as is. </p>"	"<pre>geom_bar(mapping = NULL, data = NULL, stat = 'count',<br />   position = 'stack', ..., width = NULL, binwidth = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />geom_col(mapping = NULL, data = NULL, position = 'stack', ...,<br />   width = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_count(mapping = NULL, data = NULL, geom = 'bar',<br />   position = 'stack', ..., width = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Bar width. By default, set to 90% of the resolution of the data.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p><code>geom_bar</code> no longer has a binwidth argument - if you use it you'll get an warning telling to you use <code>geom_histogram</code> instead.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Override the default connection between <code>geom_bar</code> and <code>stat_count</code>.</p> </td> </tr> </table> "	FALSE
"geom_contour"	"ggplot2"	"2d contours of a 3d surface"	"<p>ggplot2 can not draw true 3d surfaces, but you can use <code>geom_contour</code> and <code>geom_tile</code> to visualise 3d surfaces in 2d. To be a valid surface, the data must contain only a single row for each unique combination of the variables mapped to the <code>x</code> and <code>y</code> aesthetics. Contouring tends to work best when <code>x</code> and <code>y</code> form a (roughly) evenly spaced grid. If you data is not evenly spaced, you may want to interpolate to a grid before visualising. </p>"	"<pre>geom_contour(mapping = NULL, data = NULL, stat = 'contour',<br />   position = 'identity', ..., lineend = 'butt', linejoin = 'round',<br />   linemitre = 1, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_contour(mapping = NULL, data = NULL, geom = 'contour',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>linejoin</code></td> <td> <p>Line join style (round, mitre, bevel)</p> </td> </tr> <tr valign='top'> <td><code>linemitre</code></td> <td> <p>Line mitre limit (number greater than 1)</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> </table> "	FALSE
"geom_count"	"ggplot2"	"Count overlapping points"	"<p>This is a variant <code>geom_point</code> that counts the number of observations at each location, then maps the count to point area. It useful when you have discrete data and overplotting. </p>"	"<pre>geom_count(mapping = NULL, data = NULL, stat = 'sum',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_sum(mapping = NULL, data = NULL, geom = 'point',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_count</code> and <code>stat_sum</code>.</p> </td> </tr> </table> "	FALSE
"geom_linerange"	"ggplot2"	"Vertical intervals: lines, crossbars & errorbars"	"<p>Various ways of representing a vertical interval defined by <code>x</code>, <code>ymin</code> and <code>ymax</code>. Each case draws a single graphical object. </p>"	"<pre>geom_crossbar(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., fatten = 2.5, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />geom_errorbar(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_linerange(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_pointrange(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., fatten = 4, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>fatten</code></td> <td> <p>A multiplicative factor used to increase the size of the middle bar in <code>geom_crossbar()</code> and the middle point in <code>geom_pointrange()</code>.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_segment"	"ggplot2"	"Line segments and curves"	"<p><code>geom_segment</code> draws a straight line between points (x, y) and (xend, yend). <code>geom_curve</code> draws a curved line. See the underlying drawing function <code>curveGrob</code> for the parameters that control the curve. </p>"	"<pre>geom_segment(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., arrow = NULL, lineend = 'butt',<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />geom_curve(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., curvature = 0.5, angle = 90, ncp = 5,<br />   arrow = NULL, lineend = 'butt', na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>arrow</code></td> <td> <p>specification for arrow heads, as created by arrow().</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square).</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>curvature</code></td> <td> <p>A numeric value giving the amount of curvature. Negative values produce left-hand curves, positive values produce right-hand curves, and zero produces a straight line.</p> </td> </tr> <tr valign='top'> <td><code>angle</code></td> <td> <p>A numeric value between 0 and 180, giving an amount to skew the control points of the curve.  Values less than 90 skew the curve towards the start point and values greater than 90 skew the curve towards the end point.</p> </td> </tr> <tr valign='top'> <td><code>ncp</code></td> <td> <p>The number of control points used to draw the curve. More control points creates a smoother curve.</p> </td> </tr> </table> "	FALSE
"geom_density"	"ggplot2"	"Smoothed density estimates"	"<p>Computes and draws kernel density estimate, which is a smoothed version of the histogram. This is a useful alternative to the histogram if for continuous data that comes from an underlying smooth distribution. </p>"	"<pre>geom_density(mapping = NULL, data = NULL, stat = 'density',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_density(mapping = NULL, data = NULL, geom = 'area',<br />   position = 'stack', ..., bw = 'nrd0', adjust = 1, kernel = 'gaussian',<br />   n = 512, trim = FALSE, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_density</code> and <code>stat_density</code>.</p> </td> </tr> <tr valign='top'> <td><code>bw</code></td> <td> <p>The smoothing bandwidth to be used. If numeric, the standard deviation of the smoothing kernel. If character, a rule to choose the bandwidth, as listed in <code>bw.nrd</code>.</p> </td> </tr> <tr valign='top'> <td><code>adjust</code></td> <td> <p>A multiplicate bandwidth adjustment. This makes it possible to adjust the bandwidth while still using the a bandwidth estimator. For exampe, <code>adjust = 1/2</code> means use half of the default bandwidth.</p> </td> </tr> <tr valign='top'> <td><code>kernel</code></td> <td> <p>Kernel. See list of available kernels in <code>density</code>.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of equally spaced points at which the density is to be estimated, should be a power of two, see <code>density</code> for details</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>This parameter only matters if you are displaying multiple densities in one plot. If <code>FALSE</code>, the default, each density is computed on the full range of the data. If <code>TRUE</code>, each density is computed over the range of that group: this typically means the estimated x values will not line-up, and hence you won't be able to stack density values.</p> </td> </tr> </table> "	FALSE
"geom_density_2d"	"ggplot2"	"Contours of a 2d density estimate"	"<p>Perform a 2D kernel density estimation using <code>kde2d</code> and display the results with contours. This can be useful for dealing with overplotting. This is a 2d version of <code>geom_density</code>. </p>"	"<pre>geom_density_2d(mapping = NULL, data = NULL, stat = 'density2d',<br />   position = 'identity', ..., lineend = 'butt', linejoin = 'round',<br />   linemitre = 1, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_density_2d(mapping = NULL, data = NULL, geom = 'density_2d',<br />   position = 'identity', ..., contour = TRUE, n = 100, h = NULL,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>linejoin</code></td> <td> <p>Line join style (round, mitre, bevel)</p> </td> </tr> <tr valign='top'> <td><code>linemitre</code></td> <td> <p>Line mitre limit (number greater than 1)</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_density_2d</code> and <code>stat_density_2d</code>.</p> </td> </tr> <tr valign='top'> <td><code>contour</code></td> <td> <p>If <code>TRUE</code>, contour the results of the 2d density estimation</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of grid points in each direction</p> </td> </tr> <tr valign='top'> <td><code>h</code></td> <td> <p>Bandwidth (vector of length two). If <code>NULL</code>, estimated using <code>bandwidth.nrd</code>.</p> </td> </tr> </table> "	FALSE
"geom_density_2d"	"ggplot2"	"Contours of a 2d density estimate"	"<p>Perform a 2D kernel density estimation using <code>kde2d</code> and display the results with contours. This can be useful for dealing with overplotting. This is a 2d version of <code>geom_density</code>. </p>"	"<pre>geom_density_2d(mapping = NULL, data = NULL, stat = 'density2d',<br />   position = 'identity', ..., lineend = 'butt', linejoin = 'round',<br />   linemitre = 1, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_density_2d(mapping = NULL, data = NULL, geom = 'density_2d',<br />   position = 'identity', ..., contour = TRUE, n = 100, h = NULL,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>linejoin</code></td> <td> <p>Line join style (round, mitre, bevel)</p> </td> </tr> <tr valign='top'> <td><code>linemitre</code></td> <td> <p>Line mitre limit (number greater than 1)</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_density_2d</code> and <code>stat_density_2d</code>.</p> </td> </tr> <tr valign='top'> <td><code>contour</code></td> <td> <p>If <code>TRUE</code>, contour the results of the 2d density estimation</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of grid points in each direction</p> </td> </tr> <tr valign='top'> <td><code>h</code></td> <td> <p>Bandwidth (vector of length two). If <code>NULL</code>, estimated using <code>bandwidth.nrd</code>.</p> </td> </tr> </table> "	FALSE
"geom_dotplot"	"ggplot2"	"Dot plot"	"<p>In a dot plot, the width of a dot corresponds to the bin width (or maximum width, depending on the binning algorithm), and dots are stacked, with each dot representing one observation. </p>"	"<pre>geom_dotplot(mapping = NULL, data = NULL, position = 'identity', ...,<br />   binwidth = NULL, binaxis = 'x', method = 'dotdensity',<br />   binpositions = 'bygroup', stackdir = 'up', stackratio = 1,<br />   dotsize = 1, stackgroups = FALSE, origin = NULL, right = TRUE,<br />   width = 0.9, drop = FALSE, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>When <code>method</code> is 'dotdensity', this specifies maximum bin width. When <code>method</code> is 'histodot', this specifies bin width. Defaults to 1/30 of the range of the data</p> </td> </tr> <tr valign='top'> <td><code>binaxis</code></td> <td> <p>The axis to bin along, 'x' (default) or 'y'</p> </td> </tr> <tr valign='top'> <td><code>method</code></td> <td> <p>'dotdensity' (default) for dot-density binning, or 'histodot' for fixed bin widths (like stat_bin)</p> </td> </tr> <tr valign='top'> <td><code>binpositions</code></td> <td> <p>When <code>method</code> is 'dotdensity', 'bygroup' (default) determines positions of the bins for each group separately. 'all' determines positions of the bins with all the data taken together; this is used for aligning dot stacks across multiple groups.</p> </td> </tr> <tr valign='top'> <td><code>stackdir</code></td> <td> <p>which direction to stack the dots. 'up' (default), 'down', 'center', 'centerwhole' (centered, but with dots aligned)</p> </td> </tr> <tr valign='top'> <td><code>stackratio</code></td> <td> <p>how close to stack the dots. Default is 1, where dots just just touch. Use smaller values for closer, overlapping dots.</p> </td> </tr> <tr valign='top'> <td><code>dotsize</code></td> <td> <p>The diameter of the dots relative to <code>binwidth</code>, default 1.</p> </td> </tr> <tr valign='top'> <td><code>stackgroups</code></td> <td> <p>should dots be stacked across groups? This has the effect that <code>position = 'stack'</code> should have, but can't (because this geom has some odd properties).</p> </td> </tr> <tr valign='top'> <td><code>origin</code></td> <td> <p>When <code>method</code> is 'histodot', origin of first bin</p> </td> </tr> <tr valign='top'> <td><code>right</code></td> <td> <p>When <code>method</code> is 'histodot', should intervals be closed on the right (a, b], or not [a, b)</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>When <code>binaxis</code> is 'y', the spacing of the dot stacks for dodging.</p> </td> </tr> <tr valign='top'> <td><code>drop</code></td> <td> <p>If TRUE, remove all bins with zero counts</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_linerange"	"ggplot2"	"Vertical intervals: lines, crossbars & errorbars"	"<p>Various ways of representing a vertical interval defined by <code>x</code>, <code>ymin</code> and <code>ymax</code>. Each case draws a single graphical object. </p>"	"<pre>geom_crossbar(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., fatten = 2.5, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />geom_errorbar(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_linerange(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_pointrange(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., fatten = 4, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>fatten</code></td> <td> <p>A multiplicative factor used to increase the size of the middle bar in <code>geom_crossbar()</code> and the middle point in <code>geom_pointrange()</code>.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_errorbarh"	"ggplot2"	"Horizontal error bars"	"<p>A rotated version of <code>geom_errorbar</code>. </p>"	"<pre>geom_errorbarh(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_histogram"	"ggplot2"	"Histograms and frequency polygons"	"<p>Visualise the distribution of a single continuous variable by dividing the x axis into bins and counting the number of observations in each bin. Histograms (<code>geom_histogram</code>) display the count with bars; frequency polygons (<code>geom_freqpoly</code>), display the counts with lines. Frequency polygons are more suitable when you want to compare the distribution across a the levels of a categorical variable. </p> <p><code>stat_bin</code> is suitable only for continuous x data. If your x data is discrete, you probably want to use <code>stat_count</code>. </p>"	"<pre>geom_freqpoly(mapping = NULL, data = NULL, stat = 'bin',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_histogram(mapping = NULL, data = NULL, stat = 'bin',<br />   position = 'stack', ..., binwidth = NULL, bins = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />stat_bin(mapping = NULL, data = NULL, geom = 'bar', position = 'stack',<br />   ..., binwidth = NULL, bins = NULL, center = NULL, boundary = NULL,<br />   breaks = NULL, closed = c('right', 'left'), pad = FALSE,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>The width of the bins. The default is to use <code>bins</code> bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data. </p> <p>The bin width of a date variable is the number of days in each time; the bin width of a time variable is the number of seconds.</p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>Number of bins. Overridden by <code>binwidth</code>. Defaults to 30</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_histogram</code>/<code>geom_freqpoly</code> and <code>stat_bin</code>.</p> </td> </tr> <tr valign='top'> <td><code>center</code></td> <td> <p>The center of one of the bins.  Note that if center is above or below the range of the data, things will be shifted by an appropriate number of <code>width</code>s. To center on integers, for example, use <code>width = 1</code> and <code>center = 0</code>, even if <code>0</code> is outside the range of the data.  At most one of <code>center</code> and <code>boundary</code> may be specified.</p> </td> </tr> <tr valign='top'> <td><code>boundary</code></td> <td> <p>A boundary between two bins. As with <code>center</code>, things are shifted when <code>boundary</code> is outside the range of the data. For example, to center on integers, use <code>width = 1</code> and <code>boundary = 0.5</code>, even if <code>0.5</code> is outside the range of the data.  At most one of <code>center</code> and <code>boundary</code> may be specified.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>Alternatively, you can supply a numeric vector giving the bin boundaries. Overrides <code>binwidth</code>, <code>bins</code>, <code>center</code>, and <code>boundary</code>.</p> </td> </tr> <tr valign='top'> <td><code>closed</code></td> <td> <p>One of <code>'right'</code> or <code>'left'</code> indicating whether right or left edges of bins are included in the bin.</p> </td> </tr> <tr valign='top'> <td><code>pad</code></td> <td> <p>If <code>TRUE</code>, adds empty bins at either end of x. This ensures frequency polygons touch 0. Defaults to <code>FALSE</code>.</p> </td> </tr> </table> "	FALSE
"geom_hex"	"ggplot2"	"Hexagonal heatmap of 2d bin counts"	"<p>Divides the plane into regular hexagons, counts the number of cases in each hexagon, and then (by default) maps the number of cases to the hexagon fill.  Hexagon bins avoid the visual artefacts sometimes generated by the very regular alignment of <code>geom_bin2d</code>. </p>"	"<pre>geom_hex(mapping = NULL, data = NULL, stat = 'binhex',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_bin_hex(mapping = NULL, data = NULL, geom = 'hex',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Override the default connection between <code>geom_hex</code> and <code>stat_binhex.</code></p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>numeric vector giving number of bins in both vertical and horizontal directions. Set to 30 by default.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>Numeric vector giving bin width in both vertical and horizontal directions. Overrides <code>bins</code> if both set.</p> </td> </tr> </table> "	FALSE
"geom_histogram"	"ggplot2"	"Histograms and frequency polygons"	"<p>Visualise the distribution of a single continuous variable by dividing the x axis into bins and counting the number of observations in each bin. Histograms (<code>geom_histogram</code>) display the count with bars; frequency polygons (<code>geom_freqpoly</code>), display the counts with lines. Frequency polygons are more suitable when you want to compare the distribution across a the levels of a categorical variable. </p> <p><code>stat_bin</code> is suitable only for continuous x data. If your x data is discrete, you probably want to use <code>stat_count</code>. </p>"	"<pre>geom_freqpoly(mapping = NULL, data = NULL, stat = 'bin',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_histogram(mapping = NULL, data = NULL, stat = 'bin',<br />   position = 'stack', ..., binwidth = NULL, bins = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />stat_bin(mapping = NULL, data = NULL, geom = 'bar', position = 'stack',<br />   ..., binwidth = NULL, bins = NULL, center = NULL, boundary = NULL,<br />   breaks = NULL, closed = c('right', 'left'), pad = FALSE,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>The width of the bins. The default is to use <code>bins</code> bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data. </p> <p>The bin width of a date variable is the number of days in each time; the bin width of a time variable is the number of seconds.</p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>Number of bins. Overridden by <code>binwidth</code>. Defaults to 30</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_histogram</code>/<code>geom_freqpoly</code> and <code>stat_bin</code>.</p> </td> </tr> <tr valign='top'> <td><code>center</code></td> <td> <p>The center of one of the bins.  Note that if center is above or below the range of the data, things will be shifted by an appropriate number of <code>width</code>s. To center on integers, for example, use <code>width = 1</code> and <code>center = 0</code>, even if <code>0</code> is outside the range of the data.  At most one of <code>center</code> and <code>boundary</code> may be specified.</p> </td> </tr> <tr valign='top'> <td><code>boundary</code></td> <td> <p>A boundary between two bins. As with <code>center</code>, things are shifted when <code>boundary</code> is outside the range of the data. For example, to center on integers, use <code>width = 1</code> and <code>boundary = 0.5</code>, even if <code>0.5</code> is outside the range of the data.  At most one of <code>center</code> and <code>boundary</code> may be specified.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>Alternatively, you can supply a numeric vector giving the bin boundaries. Overrides <code>binwidth</code>, <code>bins</code>, <code>center</code>, and <code>boundary</code>.</p> </td> </tr> <tr valign='top'> <td><code>closed</code></td> <td> <p>One of <code>'right'</code> or <code>'left'</code> indicating whether right or left edges of bins are included in the bin.</p> </td> </tr> <tr valign='top'> <td><code>pad</code></td> <td> <p>If <code>TRUE</code>, adds empty bins at either end of x. This ensures frequency polygons touch 0. Defaults to <code>FALSE</code>.</p> </td> </tr> </table> "	FALSE
"geom_abline"	"ggplot2"	"Reference lines: horizontal, vertical, and diagonal"	"<p>These geoms add reference lines (sometimes called rules) to a plot, either horizontal, vertical, or diagonal (specified by slope and intercept). These are useful for annotating plots. </p>"	"<pre>geom_abline(mapping = NULL, data = NULL, ..., slope, intercept,<br />   na.rm = FALSE, show.legend = NA)<br />geom_hline(mapping = NULL, data = NULL, ..., yintercept, na.rm = FALSE,<br />   show.legend = NA)<br />geom_vline(mapping = NULL, data = NULL, ..., xintercept, na.rm = FALSE,<br />   show.legend = NA) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>xintercept, yintercept, slope, intercept</code></td> <td> <p>Parameters that control the position of the line. If these are set, <code>data</code>, <code>mapping</code> and <code>show.legend</code> are overridden</p> </td> </tr> </table> "	FALSE
"geom_jitter"	"ggplot2"	"Jittered points"	"<p>The jitter geom is a convenient shortcut for <code>geom_point(position = 'jitter')</code>. It adds a small amount of random variation to the location of each point, and is a useful way of handling overplotting caused by discreteness in smaller datasets. </p>"	"<pre>geom_jitter(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'jitter', ..., width = NULL, height = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Amount of vertical and horizontal jitter. The jitter is added in both positive and negative directions, so the total spread is twice the value specified here. </p> <p>If omitted, defaults to 40% of the resolution of the data: this means the jitter values will occupy 80% of the implied bins. Categorical data is aligned on the integers, so a width or height of 0.5 will spread the data so it's not possible to see the distinction between the categories.</p> </td> </tr> <tr valign='top'> <td><code>height</code></td> <td> <p>Amount of vertical and horizontal jitter. The jitter is added in both positive and negative directions, so the total spread is twice the value specified here. </p> <p>If omitted, defaults to 40% of the resolution of the data: this means the jitter values will occupy 80% of the implied bins. Categorical data is aligned on the integers, so a width or height of 0.5 will spread the data so it's not possible to see the distinction between the categories.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_text"	"ggplot2"	"Text"	"<p><code>geom_text</code> adds text directly to the plot. <code>geom_label</code> draws a rectangle behind the text, making it easier to read. </p>"	"<pre>geom_label(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., parse = FALSE, nudge_x = 0, nudge_y = 0,<br />   label.padding = unit(0.25, 'lines'), label.r = unit(0.15, 'lines'),<br />   label.size = 0.25, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_text(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., parse = FALSE, nudge_x = 0, nudge_y = 0,<br />   check_overlap = FALSE, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>parse</code></td> <td> <p>If TRUE, the labels will be parsed into expressions and displayed as described in ?plotmath</p> </td> </tr> <tr valign='top'> <td><code>nudge_x, nudge_y</code></td> <td> <p>Horizontal and vertical adjustment to nudge labels by. Useful for offsetting text from points, particularly on discrete scales.</p> </td> </tr> <tr valign='top'> <td><code>label.padding</code></td> <td> <p>Amount of padding around label. Defaults to 0.25 lines.</p> </td> </tr> <tr valign='top'> <td><code>label.r</code></td> <td> <p>Radius of rounded corners. Defaults to 0.15 lines.</p> </td> </tr> <tr valign='top'> <td><code>label.size</code></td> <td> <p>Size of label border, in mm.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>check_overlap</code></td> <td> <p>If <code>TRUE</code>, text that overlaps previous text in the same layer will not be plotted.</p> </td> </tr> </table> "	FALSE
"geom_path"	"ggplot2"	"Connect observations"	"<p><code>geom_path()</code> connects the observations in the order in which they appear in the data. <code>geom_line()</code> connects them in order of the variable on the x axis. <code>geom_step()</code> creates a stairstep plot, highlighting exactly when changes occur. The <code>group</code> aesthetic determines which cases are connected together. </p>"	"<pre>geom_path(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., lineend = 'butt', linejoin = 'round',<br />   linemitre = 1, arrow = NULL, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_line(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE, ...)<br />geom_step(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', direction = 'hv', na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>linejoin</code></td> <td> <p>Line join style (round, mitre, bevel)</p> </td> </tr> <tr valign='top'> <td><code>linemitre</code></td> <td> <p>Line mitre limit (number greater than 1)</p> </td> </tr> <tr valign='top'> <td><code>arrow</code></td> <td> <p>Arrow specification, as created by <code>arrow</code></p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>direction of stairs: 'vh' for vertical then horizontal, or 'hv' for horizontal then vertical</p> </td> </tr> </table> "	FALSE
"geom_linerange"	"ggplot2"	"Vertical intervals: lines, crossbars & errorbars"	"<p>Various ways of representing a vertical interval defined by <code>x</code>, <code>ymin</code> and <code>ymax</code>. Each case draws a single graphical object. </p>"	"<pre>geom_crossbar(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., fatten = 2.5, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />geom_errorbar(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_linerange(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_pointrange(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., fatten = 4, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>fatten</code></td> <td> <p>A multiplicative factor used to increase the size of the middle bar in <code>geom_crossbar()</code> and the middle point in <code>geom_pointrange()</code>.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_map"	"ggplot2"	"Polygons from a reference map"	"<p>This is pure annotation, so does not affect position scales. </p>"	"<pre>geom_map(mapping = NULL, data = NULL, stat = 'identity', ..., map,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>map</code></td> <td> <p>Data frame that contains the map coordinates.  This will typically be created using <code>fortify</code> on a spatial object. It must contain columns <code>x</code> or <code>long</code>, <code>y</code> or <code>lat</code>, and <code>region</code> or <code>id</code>.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_path"	"ggplot2"	"Connect observations"	"<p><code>geom_path()</code> connects the observations in the order in which they appear in the data. <code>geom_line()</code> connects them in order of the variable on the x axis. <code>geom_step()</code> creates a stairstep plot, highlighting exactly when changes occur. The <code>group</code> aesthetic determines which cases are connected together. </p>"	"<pre>geom_path(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., lineend = 'butt', linejoin = 'round',<br />   linemitre = 1, arrow = NULL, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_line(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE, ...)<br />geom_step(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', direction = 'hv', na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>linejoin</code></td> <td> <p>Line join style (round, mitre, bevel)</p> </td> </tr> <tr valign='top'> <td><code>linemitre</code></td> <td> <p>Line mitre limit (number greater than 1)</p> </td> </tr> <tr valign='top'> <td><code>arrow</code></td> <td> <p>Arrow specification, as created by <code>arrow</code></p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>direction of stairs: 'vh' for vertical then horizontal, or 'hv' for horizontal then vertical</p> </td> </tr> </table> "	FALSE
"geom_point"	"ggplot2"	"Points"	"<p>The point geom is used to create scatterplots. The scatterplot is most useful for displaying the relationship between two continuous variables. It can be used to compare one continuous and one categorical variable, or two categorical variables, but a variation like <code>geom_jitter</code>, <code>geom_count</code>, or <code>geom_bin2d</code> is usually more appropriate. </p>"	"<pre>geom_point(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_linerange"	"ggplot2"	"Vertical intervals: lines, crossbars & errorbars"	"<p>Various ways of representing a vertical interval defined by <code>x</code>, <code>ymin</code> and <code>ymax</code>. Each case draws a single graphical object. </p>"	"<pre>geom_crossbar(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., fatten = 2.5, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />geom_errorbar(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_linerange(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_pointrange(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., fatten = 4, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>fatten</code></td> <td> <p>A multiplicative factor used to increase the size of the middle bar in <code>geom_crossbar()</code> and the middle point in <code>geom_pointrange()</code>.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_polygon"	"ggplot2"	"Polygons"	"<p>Polygons are very similar to paths (as drawn by <code>geom_path</code>) except that the start and end points are connected and the inside is coloured by <code>fill</code>. The <code>group</code> aesthetic determines which cases are connected together into a polygon. </p>"	"<pre>geom_polygon(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_qq"	"ggplot2"	"A quantile-quantile plot"	"<p>A quantile-quantile plot </p>"	"<pre>geom_qq(mapping = NULL, data = NULL, geom = 'point',<br />   position = 'identity', ..., distribution = stats::qnorm,<br />   dparams = list(), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_qq(mapping = NULL, data = NULL, geom = 'point',<br />   position = 'identity', ..., distribution = stats::qnorm,<br />   dparams = list(), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>distribution</code></td> <td> <p>Distribution function to use, if x not specified</p> </td> </tr> <tr valign='top'> <td><code>dparams</code></td> <td> <p>Additional parameters passed on to <code>distribution</code> function.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_quantile"	"ggplot2"	"Quantile regression"	"<p>This fits a quantile regression to the data and draws the fitted quantiles with lines. This is as a continuous analogue to <code>geom_boxplot</code>. </p>"	"<pre>geom_quantile(mapping = NULL, data = NULL, stat = 'quantile',<br />   position = 'identity', ..., lineend = 'butt', linejoin = 'round',<br />   linemitre = 1, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_quantile(mapping = NULL, data = NULL, geom = 'quantile',<br />   position = 'identity', ..., quantiles = c(0.25, 0.5, 0.75),<br />   formula = NULL, method = 'rq', method.args = list(), na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>linejoin</code></td> <td> <p>Line join style (round, mitre, bevel)</p> </td> </tr> <tr valign='top'> <td><code>linemitre</code></td> <td> <p>Line mitre limit (number greater than 1)</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_quantile</code> and <code>stat_quantile</code>.</p> </td> </tr> <tr valign='top'> <td><code>quantiles</code></td> <td> <p>conditional quantiles of y to calculate and display</p> </td> </tr> <tr valign='top'> <td><code>formula</code></td> <td> <p>formula relating y variables to x variables</p> </td> </tr> <tr valign='top'> <td><code>method</code></td> <td> <p>Quantile regression method to use.  Currently only supports <code>rq</code>.</p> </td> </tr> <tr valign='top'> <td><code>method.args</code></td> <td> <p>List of additional arguments passed on to the modelling function defined by <code>method</code>.</p> </td> </tr> </table> "	FALSE
"geom_tile"	"ggplot2"	"Rectangles"	"<p><code>geom_rect</code> and <code>geom_tile</code> do the same thing, but are parameterised differently: <code>geom_rect</code> uses the locations of the four corners (<code>xmin</code>, <code>xmax</code>, <code>ymin</code> and <code>ymax</code>), while <code>geom_tile</code> uses the center of the tile and its size (<code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>). <code>geom_raster</code> is a high performance special case for when all the tiles are the same size. </p>"	"<pre>geom_raster(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., hjust = 0.5, vjust = 0.5,<br />   interpolate = FALSE, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_rect(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_tile(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>hjust, vjust</code></td> <td> <p>horizontal and vertical justification of the grob.  Each justification value should be a number between 0 and 1.  Defaults to 0.5 for both, centering each pixel over its data location.</p> </td> </tr> <tr valign='top'> <td><code>interpolate</code></td> <td> <p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code> (the default) don't interpolate.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_tile"	"ggplot2"	"Rectangles"	"<p><code>geom_rect</code> and <code>geom_tile</code> do the same thing, but are parameterised differently: <code>geom_rect</code> uses the locations of the four corners (<code>xmin</code>, <code>xmax</code>, <code>ymin</code> and <code>ymax</code>), while <code>geom_tile</code> uses the center of the tile and its size (<code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>). <code>geom_raster</code> is a high performance special case for when all the tiles are the same size. </p>"	"<pre>geom_raster(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., hjust = 0.5, vjust = 0.5,<br />   interpolate = FALSE, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_rect(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_tile(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>hjust, vjust</code></td> <td> <p>horizontal and vertical justification of the grob.  Each justification value should be a number between 0 and 1.  Defaults to 0.5 for both, centering each pixel over its data location.</p> </td> </tr> <tr valign='top'> <td><code>interpolate</code></td> <td> <p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code> (the default) don't interpolate.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_ribbon"	"ggplot2"	"Ribbons and area plots"	"<p>For each x value, <code>geom_ribbon</code> displays a y interval defined by <code>ymin</code> and <code>ymax</code>. <code>geom_area</code> is a special case of <code>geom_ribbon</code>, where the <code>ymin</code> is fixed to 0. </p>"	"<pre>geom_ribbon(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_area(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'stack', na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_rug"	"ggplot2"	"Rug plots in the margins"	"<p>A rug plot is a compact visualisation designed to supplement a 2d display with the two 1d marginal distributions. Rug plots display individual cases so are best used with smaller datasets. </p>"	"<pre>geom_rug(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., sides = 'bl', na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>sides</code></td> <td> <p>A string that controls which sides of the plot the rugs appear on. It can be set to a string containing any of <code>'trbl'</code>, for top, right, bottom, and left.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_segment"	"ggplot2"	"Line segments and curves"	"<p><code>geom_segment</code> draws a straight line between points (x, y) and (xend, yend). <code>geom_curve</code> draws a curved line. See the underlying drawing function <code>curveGrob</code> for the parameters that control the curve. </p>"	"<pre>geom_segment(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., arrow = NULL, lineend = 'butt',<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />geom_curve(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., curvature = 0.5, angle = 90, ncp = 5,<br />   arrow = NULL, lineend = 'butt', na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>arrow</code></td> <td> <p>specification for arrow heads, as created by arrow().</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square).</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>curvature</code></td> <td> <p>A numeric value giving the amount of curvature. Negative values produce left-hand curves, positive values produce right-hand curves, and zero produces a straight line.</p> </td> </tr> <tr valign='top'> <td><code>angle</code></td> <td> <p>A numeric value between 0 and 180, giving an amount to skew the control points of the curve.  Values less than 90 skew the curve towards the start point and values greater than 90 skew the curve towards the end point.</p> </td> </tr> <tr valign='top'> <td><code>ncp</code></td> <td> <p>The number of control points used to draw the curve. More control points creates a smoother curve.</p> </td> </tr> </table> "	FALSE
"geom_smooth"	"ggplot2"	"Smoothed conditional means"	"<p>Aids the eye in seeing patterns in the presence of overplotting. <code>geom_smooth</code> and <code>stat_smooth</code> are effectively aliases: they both use the same arguments. Use <code>geom_smooth</code> unless you want to display the results with a non-standard geom. </p>"	"<pre>geom_smooth(mapping = NULL, data = NULL, stat = 'smooth',<br />   position = 'identity', ..., method = 'auto', formula = y ~ x,<br />   se = TRUE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_smooth(mapping = NULL, data = NULL, geom = 'smooth',<br />   position = 'identity', ..., method = 'auto', formula = y ~ x,<br />   se = TRUE, n = 80, span = 0.75, fullrange = FALSE, level = 0.95,<br />   method.args = list(), na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>method</code></td> <td> <p>smoothing method (function) to use, eg. 'lm', 'glm', 'gam', 'loess', 'rlm'. </p> <p>For <code>method = 'auto'</code> the smoothing method is chosen based on the size of the largest group (across all panels). <code>loess</code> is used for than 1,000 observations; otherwise <code>gam</code> is used with <code>formula = y ~ s(x, bs = 'cs')</code>. Somewhat anecdotally, <code>loess</code> gives a better appearance, but is O(n^2) in memory, so does not work for larger datasets.</p> </td> </tr> <tr valign='top'> <td><code>formula</code></td> <td> <p>formula to use in smoothing function, eg. <code>y ~ x</code>, <code>y ~ poly(x, 2)</code>, <code>y ~ log(x)</code></p> </td> </tr> <tr valign='top'> <td><code>se</code></td> <td> <p>display confidence interval around smooth? (TRUE by default, see level to control</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_smooth</code> and <code>stat_smooth</code>.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of points to evaluate smoother at</p> </td> </tr> <tr valign='top'> <td><code>span</code></td> <td> <p>Controls the amount of smoothing for the default loess smoother. Smaller numbers produce wigglier lines, larger numbers produce smoother lines.</p> </td> </tr> <tr valign='top'> <td><code>fullrange</code></td> <td> <p>should the fit span the full range of the plot, or just the data</p> </td> </tr> <tr valign='top'> <td><code>level</code></td> <td> <p>level of confidence interval to use (0.95 by default)</p> </td> </tr> <tr valign='top'> <td><code>method.args</code></td> <td> <p>List of additional arguments passed on to the modelling function defined by <code>method</code>.</p> </td> </tr> </table> "	FALSE
"geom_spoke"	"ggplot2"	"Line segments parameterised by location, direction and distance"	"<p>This is a polar parameterisation of <code>geom_segment</code>. It is useful when you have variables that describe direction and distance. </p>"	"<pre>geom_spoke(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_path"	"ggplot2"	"Connect observations"	"<p><code>geom_path()</code> connects the observations in the order in which they appear in the data. <code>geom_line()</code> connects them in order of the variable on the x axis. <code>geom_step()</code> creates a stairstep plot, highlighting exactly when changes occur. The <code>group</code> aesthetic determines which cases are connected together. </p>"	"<pre>geom_path(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., lineend = 'butt', linejoin = 'round',<br />   linemitre = 1, arrow = NULL, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_line(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE, ...)<br />geom_step(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', direction = 'hv', na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>linejoin</code></td> <td> <p>Line join style (round, mitre, bevel)</p> </td> </tr> <tr valign='top'> <td><code>linemitre</code></td> <td> <p>Line mitre limit (number greater than 1)</p> </td> </tr> <tr valign='top'> <td><code>arrow</code></td> <td> <p>Arrow specification, as created by <code>arrow</code></p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>direction of stairs: 'vh' for vertical then horizontal, or 'hv' for horizontal then vertical</p> </td> </tr> </table> "	FALSE
"geom_text"	"ggplot2"	"Text"	"<p><code>geom_text</code> adds text directly to the plot. <code>geom_label</code> draws a rectangle behind the text, making it easier to read. </p>"	"<pre>geom_label(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., parse = FALSE, nudge_x = 0, nudge_y = 0,<br />   label.padding = unit(0.25, 'lines'), label.r = unit(0.15, 'lines'),<br />   label.size = 0.25, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_text(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., parse = FALSE, nudge_x = 0, nudge_y = 0,<br />   check_overlap = FALSE, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>parse</code></td> <td> <p>If TRUE, the labels will be parsed into expressions and displayed as described in ?plotmath</p> </td> </tr> <tr valign='top'> <td><code>nudge_x, nudge_y</code></td> <td> <p>Horizontal and vertical adjustment to nudge labels by. Useful for offsetting text from points, particularly on discrete scales.</p> </td> </tr> <tr valign='top'> <td><code>label.padding</code></td> <td> <p>Amount of padding around label. Defaults to 0.25 lines.</p> </td> </tr> <tr valign='top'> <td><code>label.r</code></td> <td> <p>Radius of rounded corners. Defaults to 0.15 lines.</p> </td> </tr> <tr valign='top'> <td><code>label.size</code></td> <td> <p>Size of label border, in mm.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>check_overlap</code></td> <td> <p>If <code>TRUE</code>, text that overlaps previous text in the same layer will not be plotted.</p> </td> </tr> </table> "	FALSE
"geom_tile"	"ggplot2"	"Rectangles"	"<p><code>geom_rect</code> and <code>geom_tile</code> do the same thing, but are parameterised differently: <code>geom_rect</code> uses the locations of the four corners (<code>xmin</code>, <code>xmax</code>, <code>ymin</code> and <code>ymax</code>), while <code>geom_tile</code> uses the center of the tile and its size (<code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>). <code>geom_raster</code> is a high performance special case for when all the tiles are the same size. </p>"	"<pre>geom_raster(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., hjust = 0.5, vjust = 0.5,<br />   interpolate = FALSE, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_rect(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_tile(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>hjust, vjust</code></td> <td> <p>horizontal and vertical justification of the grob.  Each justification value should be a number between 0 and 1.  Defaults to 0.5 for both, centering each pixel over its data location.</p> </td> </tr> <tr valign='top'> <td><code>interpolate</code></td> <td> <p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code> (the default) don't interpolate.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_violin"	"ggplot2"	"Violin plot"	"<p>A violin plot is a compact display of a continuous distribution. It is a blend of <code>geom_boxplot</code> and <code>geom_density</code>: a violin plot is a mirrored density plot displayed in the same way as a boxplot. </p>"	"<pre>geom_violin(mapping = NULL, data = NULL, stat = 'ydensity',<br />   position = 'dodge', ..., draw_quantiles = NULL, trim = TRUE,<br />   scale = 'area', na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_ydensity(mapping = NULL, data = NULL, geom = 'violin',<br />   position = 'dodge', ..., bw = 'nrd0', adjust = 1, kernel = 'gaussian',<br />   trim = TRUE, scale = 'area', na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>draw_quantiles</code></td> <td> <p>If <code>not(NULL)</code> (default), draw horizontal lines at the given quantiles of the density estimate.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> (default), trim the tails of the violins to the range of the data. If <code>FALSE</code>, don't trim the tails.</p> </td> </tr> <tr valign='top'> <td><code>scale</code></td> <td> <p>if 'area' (default), all violins have the same area (before trimming the tails). If 'count', areas are scaled proportionally to the number of observations. If 'width', all violins have the same maximum width.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_violin</code> and <code>stat_ydensity</code>.</p> </td> </tr> <tr valign='top'> <td><code>bw</code></td> <td> <p>The smoothing bandwidth to be used. If numeric, the standard deviation of the smoothing kernel. If character, a rule to choose the bandwidth, as listed in <code>bw.nrd</code>.</p> </td> </tr> <tr valign='top'> <td><code>adjust</code></td> <td> <p>A multiplicate bandwidth adjustment. This makes it possible to adjust the bandwidth while still using the a bandwidth estimator. For exampe, <code>adjust = 1/2</code> means use half of the default bandwidth.</p> </td> </tr> <tr valign='top'> <td><code>kernel</code></td> <td> <p>Kernel. See list of available kernels in <code>density</code>.</p> </td> </tr> </table> "	FALSE
"geom_abline"	"ggplot2"	"Reference lines: horizontal, vertical, and diagonal"	"<p>These geoms add reference lines (sometimes called rules) to a plot, either horizontal, vertical, or diagonal (specified by slope and intercept). These are useful for annotating plots. </p>"	"<pre>geom_abline(mapping = NULL, data = NULL, ..., slope, intercept,<br />   na.rm = FALSE, show.legend = NA)<br />geom_hline(mapping = NULL, data = NULL, ..., yintercept, na.rm = FALSE,<br />   show.legend = NA)<br />geom_vline(mapping = NULL, data = NULL, ..., xintercept, na.rm = FALSE,<br />   show.legend = NA) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>xintercept, yintercept, slope, intercept</code></td> <td> <p>Parameters that control the position of the line. If these are set, <code>data</code>, <code>mapping</code> and <code>show.legend</code> are overridden</p> </td> </tr> </table> "	FALSE
"ggplot"	"ggplot2"	"Create a new ggplot"	"<p><code>ggplot()</code> initializes a ggplot object. It can be used to declare the input data frame for a graphic and to specify the set of plot aesthetics intended to be common throughout all subsequent layers unless specifically overridden. </p>"	"<pre>ggplot(data = NULL, mapping = aes(), ..., environment = parent.frame()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>Default dataset to use for plot. If not already a data.frame, will be converted to one by <code>fortify</code>. If not specified, must be suppled in each layer added to the plot.</p> </td> </tr> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Default list of aesthetic mappings to use for plot. If not specified, must be suppled in each layer added to the plot.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to methods. Not currently used.</p> </td> </tr> <tr valign='top'> <td><code>environment</code></td> <td> <p>If an variable defined in the aesthetic mapping is not found in the data, ggplot will look for it in this environment. It defaults to using the environment in which <code>ggplot()</code> is called.</p> </td> </tr> </table> "	FALSE
"ggproto"	"ggplot2"	"Create a new ggproto object"	"<p>Construct a new object with <code>ggproto</code>, test with <code>is.proto</code>, and access parent methods/fields with <code>ggproto_parent</code>. </p>"	"<pre>ggproto(`_class` = NULL, `_inherit` = NULL, ...)<br />ggproto_parent(parent, self)<br />is.ggproto(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>_class</code></td> <td> <p>Class name to assign to the object. This is stored as the class attribute of the object. This is optional: if <code>NULL</code> (the default), no class name will be added to the object.</p> </td> </tr> <tr valign='top'> <td><code>_inherit</code></td> <td> <p>ggproto object to inherit from. If <code>NULL</code>, don't inherit from any object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>A list of members in the ggproto object.</p> </td> </tr> <tr valign='top'> <td><code>parent, self</code></td> <td> <p>Access parent class <code>parent</code> of object <code>self</code>.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object to test.</p> </td> </tr> </table> "	FALSE
"ggproto"	"ggplot2"	"Create a new ggproto object"	"<p>Construct a new object with <code>ggproto</code>, test with <code>is.proto</code>, and access parent methods/fields with <code>ggproto_parent</code>. </p>"	"<pre>ggproto(`_class` = NULL, `_inherit` = NULL, ...)<br />ggproto_parent(parent, self)<br />is.ggproto(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>_class</code></td> <td> <p>Class name to assign to the object. This is stored as the class attribute of the object. This is optional: if <code>NULL</code> (the default), no class name will be added to the object.</p> </td> </tr> <tr valign='top'> <td><code>_inherit</code></td> <td> <p>ggproto object to inherit from. If <code>NULL</code>, don't inherit from any object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>A list of members in the ggproto object.</p> </td> </tr> <tr valign='top'> <td><code>parent, self</code></td> <td> <p>Access parent class <code>parent</code> of object <code>self</code>.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object to test.</p> </td> </tr> </table> "	FALSE
"ggsave"	"ggplot2"	"Save a ggplot (or other grid object) with sensible defaults"	"<p><code>ggsave()</code> is a convenient function for saving a plot. It defaults to saving the last plot that you displayed, using the size of the current graphics device. It also guesses the type of graphics device from the extension. </p>"	"<pre>ggsave(filename, plot = last_plot(), device = NULL, path = NULL,<br />   scale = 1, width = NA, height = NA, units = c('in', 'cm', 'mm'),<br />   dpi = 300, limitsize = TRUE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>filename</code></td> <td> <p>File name to create on disk.</p> </td> </tr> <tr valign='top'> <td><code>plot</code></td> <td> <p>Plot to save, defaults to last plot displayed.</p> </td> </tr> <tr valign='top'> <td><code>device</code></td> <td> <p>Device to use. Can be either be a device function (e.g. <code>png</code>), or one of 'eps', 'ps', 'tex' (pictex), 'pdf', 'jpeg', 'tiff', 'png', 'bmp', 'svg' or 'wmf' (windows only).</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to save plot to (combined with filename).</p> </td> </tr> <tr valign='top'> <td><code>scale</code></td> <td> <p>Multiplicative scaling factor.</p> </td> </tr> <tr valign='top'> <td><code>width, height, units</code></td> <td> <p>Plot size in <code>units</code> ('in', 'cm', or 'mm'). If not supplied, uses the size of current graphics device.</p> </td> </tr> <tr valign='top'> <td><code>dpi</code></td> <td> <p>Plot resolution. Applies only to raster output types.</p> </td> </tr> <tr valign='top'> <td><code>limitsize</code></td> <td> <p>When <code>TRUE</code> (the default), <code>ggsave</code> will not save images larger than 50x50 inches, to prevent the common error of specifying dimensions in pixels.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to graphics <code>device</code>.</p> </td> </tr> </table> "	FALSE
"labs"	"ggplot2"	"Modify axis, legend, and plot labels"	"<p>Good labels are critical for making your plots accessible to a wider audience. Ensure the axis and legend labels display the full variable name. Use the plot <code>title</code> and <code>subtitle</code> to explain the main findings. It's common to use the <code>caption</code> to provide information about the data source. </p>"	"<pre>labs(...)<br />xlab(label)<br />ylab(label)<br />ggtitle(label, subtitle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A list of new name-value pairs. The name should either be an aesthetic, or one of 'title', 'subtitle', or 'caption'.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>The text for the axis, plot title or caption below the plot.</p> </td> </tr> <tr valign='top'> <td><code>subtitle</code></td> <td> <p>the text for the subtitle for the plot which will be displayed below the title. Leave <code>NULL</code> for no subtitle.</p> </td> </tr> </table> "	FALSE
"aes_group_order"	"ggplot2"	"Aesthetics: grouping"	"<p>Aesthetics: grouping </p>"	NA	NA	FALSE
"guides"	"ggplot2"	"Set guides for each scale"	"<p>Guides for each scale can be set scale-by-scale with the <code>guide</code> argument, or en masse with <code>guides()</code>. </p>"	"<pre>guides(...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>...</code></td> <td> <p>List of scale name-guide pairs.  The guide can either be a string (i.e. 'colorbar' or 'legend'), or a call to a guide function (i.e. <code>guide_colourbar</code> or <code>guide_legend</code>) specifying additional arguments.</p> </td> </tr></table> "	FALSE
"guide_colourbar"	"ggplot2"	"Continuous colour bar guide"	"<p>Colour bar guide shows continuous color scales mapped onto values. Colour bar is available with <code>scale_fill</code> and <code>scale_colour</code>. For more information, see the inspiration for this function: <a href='http://www.mathworks.com/help/techdoc/ref/colorbar.html'>Matlab's colorbar function</a>. </p>"	"<pre>guide_colourbar(title = waiver(), title.position = NULL,<br />   title.theme = NULL, title.hjust = NULL, title.vjust = NULL,<br />   label = TRUE, label.position = NULL, label.theme = NULL,<br />   label.hjust = NULL, label.vjust = NULL, barwidth = NULL,<br />   barheight = NULL, nbin = 20, raster = TRUE, ticks = TRUE,<br />   draw.ulim = TRUE, draw.llim = TRUE, direction = NULL,<br />   default.unit = 'line', reverse = FALSE, order = 0, ...)<br />guide_colorbar(title = waiver(), title.position = NULL,<br />   title.theme = NULL, title.hjust = NULL, title.vjust = NULL,<br />   label = TRUE, label.position = NULL, label.theme = NULL,<br />   label.hjust = NULL, label.vjust = NULL, barwidth = NULL,<br />   barheight = NULL, nbin = 20, raster = TRUE, ticks = TRUE,<br />   draw.ulim = TRUE, draw.llim = TRUE, direction = NULL,<br />   default.unit = 'line', reverse = FALSE, order = 0, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>title</code></td> <td> <p>A character string or expression indicating a title of guide. If <code>NULL</code>, the title is not shown. By default (<code>waiver</code>), the name of the scale object or the name specified in <code>labs</code> is used for the title.</p> </td> </tr> <tr valign='top'> <td><code>title.position</code></td> <td> <p>A character string indicating the position of a title. One of 'top' (default for a vertical guide), 'bottom', 'left' (default for a horizontal guide), or 'right.'</p> </td> </tr> <tr valign='top'> <td><code>title.theme</code></td> <td> <p>A theme object for rendering the title text. Usually the object of <code>element_text</code> is expected. By default, the theme is specified by <code>legend.title</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>title.hjust</code></td> <td> <p>A number specifying horizontal justification of the title text.</p> </td> </tr> <tr valign='top'> <td><code>title.vjust</code></td> <td> <p>A number specifying vertical justification of the title text.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. If <code>TRUE</code> then the labels are drawn. If <code>FALSE</code> then the labels are invisible.</p> </td> </tr> <tr valign='top'> <td><code>label.position</code></td> <td> <p>A character string indicating the position of a label. One of 'top', 'bottom' (default for horizontal guide), 'left', or 'right' (default for vertical guide).</p> </td> </tr> <tr valign='top'> <td><code>label.theme</code></td> <td> <p>A theme object for rendering the label text. Usually the object of <code>element_text</code> is expected. By default, the theme is specified by <code>legend.text</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>label.hjust</code></td> <td> <p>A numeric specifying horizontal justification of the label text.</p> </td> </tr> <tr valign='top'> <td><code>label.vjust</code></td> <td> <p>A numeric specifying vertical justification of the label text.</p> </td> </tr> <tr valign='top'> <td><code>barwidth</code></td> <td> <p>A numeric or a <code>unit</code> object specifying the width of the colorbar. Default value is <code>legend.key.width</code> or <code>legend.key.size</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>barheight</code></td> <td> <p>A numeric or a <code>unit</code> object specifying the height of the colorbar. Default value is <code>legend.key.height</code> or <code>legend.key.size</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>nbin</code></td> <td> <p>A numeric specifying the number of bins for drawing colorbar. A smoother colorbar for a larger value.</p> </td> </tr> <tr valign='top'> <td><code>raster</code></td> <td> <p>A logical. If <code>TRUE</code> then the colorbar is rendered as a raster object. If <code>FALSE</code> then the colorbar is rendered as a set of rectangles. Note that not all graphics devices are capable of rendering raster image.</p> </td> </tr> <tr valign='top'> <td><code>ticks</code></td> <td> <p>A logical specifying if tick marks on colorbar should be visible.</p> </td> </tr> <tr valign='top'> <td><code>draw.ulim</code></td> <td> <p>A logical specifying if the upper limit tick marks should be visible.</p> </td> </tr> <tr valign='top'> <td><code>draw.llim</code></td> <td> <p>A logical specifying if the lower limit tick marks should be visible.</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>A character string indicating the direction of the guide. One of 'horizontal' or 'vertical.'</p> </td> </tr> <tr valign='top'> <td><code>default.unit</code></td> <td> <p>A character string indicating <code>unit</code> for <code>barwidth</code> and <code>barheight</code>.</p> </td> </tr> <tr valign='top'> <td><code>reverse</code></td> <td> <p>logical. If <code>TRUE</code> the colorbar is reversed. By default, the highest value is on the top and the lowest value is on the bottom</p> </td> </tr> <tr valign='top'> <td><code>order</code></td> <td> <p>positive integer less that 99 that specifies the order of this guide among multiple guides. This controls the order in which multiple guides are displayed, not the contents of the guide itself. If 0 (default), the order is determined by a secret algorithm.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>ignored.</p> </td> </tr> </table> "	FALSE
"guide_colourbar"	"ggplot2"	"Continuous colour bar guide"	"<p>Colour bar guide shows continuous color scales mapped onto values. Colour bar is available with <code>scale_fill</code> and <code>scale_colour</code>. For more information, see the inspiration for this function: <a href='http://www.mathworks.com/help/techdoc/ref/colorbar.html'>Matlab's colorbar function</a>. </p>"	"<pre>guide_colourbar(title = waiver(), title.position = NULL,<br />   title.theme = NULL, title.hjust = NULL, title.vjust = NULL,<br />   label = TRUE, label.position = NULL, label.theme = NULL,<br />   label.hjust = NULL, label.vjust = NULL, barwidth = NULL,<br />   barheight = NULL, nbin = 20, raster = TRUE, ticks = TRUE,<br />   draw.ulim = TRUE, draw.llim = TRUE, direction = NULL,<br />   default.unit = 'line', reverse = FALSE, order = 0, ...)<br />guide_colorbar(title = waiver(), title.position = NULL,<br />   title.theme = NULL, title.hjust = NULL, title.vjust = NULL,<br />   label = TRUE, label.position = NULL, label.theme = NULL,<br />   label.hjust = NULL, label.vjust = NULL, barwidth = NULL,<br />   barheight = NULL, nbin = 20, raster = TRUE, ticks = TRUE,<br />   draw.ulim = TRUE, draw.llim = TRUE, direction = NULL,<br />   default.unit = 'line', reverse = FALSE, order = 0, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>title</code></td> <td> <p>A character string or expression indicating a title of guide. If <code>NULL</code>, the title is not shown. By default (<code>waiver</code>), the name of the scale object or the name specified in <code>labs</code> is used for the title.</p> </td> </tr> <tr valign='top'> <td><code>title.position</code></td> <td> <p>A character string indicating the position of a title. One of 'top' (default for a vertical guide), 'bottom', 'left' (default for a horizontal guide), or 'right.'</p> </td> </tr> <tr valign='top'> <td><code>title.theme</code></td> <td> <p>A theme object for rendering the title text. Usually the object of <code>element_text</code> is expected. By default, the theme is specified by <code>legend.title</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>title.hjust</code></td> <td> <p>A number specifying horizontal justification of the title text.</p> </td> </tr> <tr valign='top'> <td><code>title.vjust</code></td> <td> <p>A number specifying vertical justification of the title text.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. If <code>TRUE</code> then the labels are drawn. If <code>FALSE</code> then the labels are invisible.</p> </td> </tr> <tr valign='top'> <td><code>label.position</code></td> <td> <p>A character string indicating the position of a label. One of 'top', 'bottom' (default for horizontal guide), 'left', or 'right' (default for vertical guide).</p> </td> </tr> <tr valign='top'> <td><code>label.theme</code></td> <td> <p>A theme object for rendering the label text. Usually the object of <code>element_text</code> is expected. By default, the theme is specified by <code>legend.text</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>label.hjust</code></td> <td> <p>A numeric specifying horizontal justification of the label text.</p> </td> </tr> <tr valign='top'> <td><code>label.vjust</code></td> <td> <p>A numeric specifying vertical justification of the label text.</p> </td> </tr> <tr valign='top'> <td><code>barwidth</code></td> <td> <p>A numeric or a <code>unit</code> object specifying the width of the colorbar. Default value is <code>legend.key.width</code> or <code>legend.key.size</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>barheight</code></td> <td> <p>A numeric or a <code>unit</code> object specifying the height of the colorbar. Default value is <code>legend.key.height</code> or <code>legend.key.size</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>nbin</code></td> <td> <p>A numeric specifying the number of bins for drawing colorbar. A smoother colorbar for a larger value.</p> </td> </tr> <tr valign='top'> <td><code>raster</code></td> <td> <p>A logical. If <code>TRUE</code> then the colorbar is rendered as a raster object. If <code>FALSE</code> then the colorbar is rendered as a set of rectangles. Note that not all graphics devices are capable of rendering raster image.</p> </td> </tr> <tr valign='top'> <td><code>ticks</code></td> <td> <p>A logical specifying if tick marks on colorbar should be visible.</p> </td> </tr> <tr valign='top'> <td><code>draw.ulim</code></td> <td> <p>A logical specifying if the upper limit tick marks should be visible.</p> </td> </tr> <tr valign='top'> <td><code>draw.llim</code></td> <td> <p>A logical specifying if the lower limit tick marks should be visible.</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>A character string indicating the direction of the guide. One of 'horizontal' or 'vertical.'</p> </td> </tr> <tr valign='top'> <td><code>default.unit</code></td> <td> <p>A character string indicating <code>unit</code> for <code>barwidth</code> and <code>barheight</code>.</p> </td> </tr> <tr valign='top'> <td><code>reverse</code></td> <td> <p>logical. If <code>TRUE</code> the colorbar is reversed. By default, the highest value is on the top and the lowest value is on the bottom</p> </td> </tr> <tr valign='top'> <td><code>order</code></td> <td> <p>positive integer less that 99 that specifies the order of this guide among multiple guides. This controls the order in which multiple guides are displayed, not the contents of the guide itself. If 0 (default), the order is determined by a secret algorithm.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>ignored.</p> </td> </tr> </table> "	FALSE
"guide_legend"	"ggplot2"	"Legend guide"	"<p>Legend type guide shows key (i.e., geoms) mapped onto values. Legend guides for various scales are integrated if possible. </p>"	"<pre>guide_legend(title = waiver(), title.position = NULL, title.theme = NULL,<br />   title.hjust = NULL, title.vjust = NULL, label = TRUE,<br />   label.position = NULL, label.theme = NULL, label.hjust = NULL,<br />   label.vjust = NULL, keywidth = NULL, keyheight = NULL,<br />   direction = NULL, default.unit = 'line', override.aes = list(),<br />   nrow = NULL, ncol = NULL, byrow = FALSE, reverse = FALSE, order = 0,<br />   ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>title</code></td> <td> <p>A character string or expression indicating a title of guide. If <code>NULL</code>, the title is not shown. By default (<code>waiver</code>), the name of the scale object or the name specified in <code>labs</code> is used for the title.</p> </td> </tr> <tr valign='top'> <td><code>title.position</code></td> <td> <p>A character string indicating the position of a title. One of 'top' (default for a vertical guide), 'bottom', 'left' (default for a horizontal guide), or 'right.'</p> </td> </tr> <tr valign='top'> <td><code>title.theme</code></td> <td> <p>A theme object for rendering the title text. Usually the object of <code>element_text</code> is expected. By default, the theme is specified by <code>legend.title</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>title.hjust</code></td> <td> <p>A number specifying horizontal justification of the title text.</p> </td> </tr> <tr valign='top'> <td><code>title.vjust</code></td> <td> <p>A number specifying vertical justification of the title text.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. If <code>TRUE</code> then the labels are drawn. If <code>FALSE</code> then the labels are invisible.</p> </td> </tr> <tr valign='top'> <td><code>label.position</code></td> <td> <p>A character string indicating the position of a label. One of 'top', 'bottom' (default for horizontal guide), 'left', or 'right' (default for vertical guide).</p> </td> </tr> <tr valign='top'> <td><code>label.theme</code></td> <td> <p>A theme object for rendering the label text. Usually the object of <code>element_text</code> is expected. By default, the theme is specified by <code>legend.text</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>label.hjust</code></td> <td> <p>A numeric specifying horizontal justification of the label text.</p> </td> </tr> <tr valign='top'> <td><code>label.vjust</code></td> <td> <p>A numeric specifying vertical justification of the label text.</p> </td> </tr> <tr valign='top'> <td><code>keywidth</code></td> <td> <p>A numeric or a <code>unit</code> object specifying the width of the legend key. Default value is <code>legend.key.width</code> or <code>legend.key.size</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>keyheight</code></td> <td> <p>A numeric or a <code>unit</code> object specifying the height of the legend key. Default value is <code>legend.key.height</code> or <code>legend.key.size</code> in <code>theme</code> or theme.</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>A character string indicating the direction of the guide. One of 'horizontal' or 'vertical.'</p> </td> </tr> <tr valign='top'> <td><code>default.unit</code></td> <td> <p>A character string indicating <code>unit</code> for <code>keywidth</code> and <code>keyheight</code>.</p> </td> </tr> <tr valign='top'> <td><code>override.aes</code></td> <td> <p>A list specifying aesthetic parameters of legend key. See details and examples.</p> </td> </tr> <tr valign='top'> <td><code>nrow</code></td> <td> <p>The desired number of rows of legends.</p> </td> </tr> <tr valign='top'> <td><code>ncol</code></td> <td> <p>The desired number of column of legends.</p> </td> </tr> <tr valign='top'> <td><code>byrow</code></td> <td> <p>logical. If <code>FALSE</code> (the default) the legend-matrix is filled by columns, otherwise the legend-matrix is filled by rows.</p> </td> </tr> <tr valign='top'> <td><code>reverse</code></td> <td> <p>logical. If <code>TRUE</code> the order of legends is reversed.</p> </td> </tr> <tr valign='top'> <td><code>order</code></td> <td> <p>positive integer less that 99 that specifies the order of this guide among multiple guides. This controls the order in which multiple guides are displayed, not the contents of the guide itself. If 0 (default), the order is determined by a secret algorithm.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>ignored.</p> </td> </tr> </table> "	FALSE
"hmisc"	"ggplot2"	"A selection of summary functions from Hmisc"	"<p>These are wrappers around functions from <span class='pkg'>Hmsic</span> designed to make them easier to use with <code>stat_summary</code>. See the Hmisc documentation for more details: </p> <ul> <li> <p><code>smean.cl.boot</code> </p> </li> <li> <p><code>smean.cl.normal</code> </p> </li> <li> <p><code>smean.sdl</code> </p> </li> <li> <p><code>smedian.hilow</code> </p> </li> </ul> "	"<pre>mean_cl_boot(x, ...)<br />mean_cl_normal(x, ...)<br />mean_sdl(x, ...)<br />median_hilow(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a numeric vector</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to the respective Hmisc function.</p> </td> </tr> </table> "	FALSE
"ggproto"	"ggplot2"	"Create a new ggproto object"	"<p>Construct a new object with <code>ggproto</code>, test with <code>is.proto</code>, and access parent methods/fields with <code>ggproto_parent</code>. </p>"	"<pre>ggproto(`_class` = NULL, `_inherit` = NULL, ...)<br />ggproto_parent(parent, self)<br />is.ggproto(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>_class</code></td> <td> <p>Class name to assign to the object. This is stored as the class attribute of the object. This is optional: if <code>NULL</code> (the default), no class name will be added to the object.</p> </td> </tr> <tr valign='top'> <td><code>_inherit</code></td> <td> <p>ggproto object to inherit from. If <code>NULL</code>, don't inherit from any object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>A list of members in the ggproto object.</p> </td> </tr> <tr valign='top'> <td><code>parent, self</code></td> <td> <p>Access parent class <code>parent</code> of object <code>self</code>.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object to test.</p> </td> </tr> </table> "	FALSE
"labeller"	"ggplot2"	"Construct labelling specification"	"<p>This function makes it easy to assign different labellers to different factors. The labeller can be a function or it can be a named character vectors that will serve as a lookup table. </p>"	"<pre>labeller(..., .rows = NULL, .cols = NULL, keep.as.numeric = NULL,<br />   .multi_line = TRUE, .default = label_value) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Named arguments of the form <code>variable = labeller</code>. Each labeller is passed to <code>as_labeller()</code> and can be a lookup table, a function taking and returning character vectors, or simply a labeller function.</p> </td> </tr> <tr valign='top'> <td><code>.rows, .cols</code></td> <td> <p>Labeller for a whole margin (either the rows or the columns). It is passed to <code>as_labeller()</code>. When a margin-wide labeller is set, make sure you don't mention in <code>...</code> any variable belonging to the margin.</p> </td> </tr> <tr valign='top'> <td><code>keep.as.numeric</code></td> <td> <p>Deprecated. All supplied labellers and on-labeller functions should be able to work with character labels.</p> </td> </tr> <tr valign='top'> <td><code>.multi_line</code></td> <td> <p>Whether to display the labels of multiple factors on separate lines. This is passed to the labeller function.</p> </td> </tr> <tr valign='top'> <td><code>.default</code></td> <td> <p>Default labeller for variables not specified. Also used with lookup tables or non-labeller functions.</p> </td> </tr> </table> "	FALSE
"labellers"	"ggplot2"	"Useful labeller functions"	"<p>Labeller functions are in charge of formatting the strip labels of facet grids and wraps. Most of them accept a <code>multi_line</code> argument to control whether multiple factors (defined in formulae such as <code>~first + second</code>) should be displayed on a single line separated with commas, or each on their own line. </p>"	"<pre>label_value(labels, multi_line = TRUE)<br />label_both(labels, multi_line = TRUE, sep = ': ')<br />label_context(labels, multi_line = TRUE, sep = ': ')<br />label_parsed(labels, multi_line = TRUE)<br />label_wrap_gen(width = 25, multi_line = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>labels</code></td> <td> <p>Data frame of labels. Usually contains only one element, but facetting over multiple factors entails multiple label variables.</p> </td> </tr> <tr valign='top'> <td><code>multi_line</code></td> <td> <p>Whether to display the labels of multiple factors on separate lines.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>String separating variables and values.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Maximum number of characters before wrapping the strip.</p> </td> </tr> </table> "	FALSE
"labellers"	"ggplot2"	"Useful labeller functions"	"<p>Labeller functions are in charge of formatting the strip labels of facet grids and wraps. Most of them accept a <code>multi_line</code> argument to control whether multiple factors (defined in formulae such as <code>~first + second</code>) should be displayed on a single line separated with commas, or each on their own line. </p>"	"<pre>label_value(labels, multi_line = TRUE)<br />label_both(labels, multi_line = TRUE, sep = ': ')<br />label_context(labels, multi_line = TRUE, sep = ': ')<br />label_parsed(labels, multi_line = TRUE)<br />label_wrap_gen(width = 25, multi_line = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>labels</code></td> <td> <p>Data frame of labels. Usually contains only one element, but facetting over multiple factors entails multiple label variables.</p> </td> </tr> <tr valign='top'> <td><code>multi_line</code></td> <td> <p>Whether to display the labels of multiple factors on separate lines.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>String separating variables and values.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Maximum number of characters before wrapping the strip.</p> </td> </tr> </table> "	FALSE
"label_bquote"	"ggplot2"	"Label with mathematical expressions"	"<p><code>label_bquote()</code> offers a flexible way of labelling facet rows or columns with plotmath expressions. Backquoted variables will be replaced with their value in the facet. </p>"	"<pre>label_bquote(rows = NULL, cols = NULL, default = label_value) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>rows</code></td> <td> <p>Backquoted labelling expression for rows.</p> </td> </tr> <tr valign='top'> <td><code>cols</code></td> <td> <p>Backquoted labelling expression for columns.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>Default labeller function for the rows or the columns when no plotmath expression is provided.</p> </td> </tr> </table> "	FALSE
"labellers"	"ggplot2"	"Useful labeller functions"	"<p>Labeller functions are in charge of formatting the strip labels of facet grids and wraps. Most of them accept a <code>multi_line</code> argument to control whether multiple factors (defined in formulae such as <code>~first + second</code>) should be displayed on a single line separated with commas, or each on their own line. </p>"	"<pre>label_value(labels, multi_line = TRUE)<br />label_both(labels, multi_line = TRUE, sep = ': ')<br />label_context(labels, multi_line = TRUE, sep = ': ')<br />label_parsed(labels, multi_line = TRUE)<br />label_wrap_gen(width = 25, multi_line = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>labels</code></td> <td> <p>Data frame of labels. Usually contains only one element, but facetting over multiple factors entails multiple label variables.</p> </td> </tr> <tr valign='top'> <td><code>multi_line</code></td> <td> <p>Whether to display the labels of multiple factors on separate lines.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>String separating variables and values.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Maximum number of characters before wrapping the strip.</p> </td> </tr> </table> "	FALSE
"labellers"	"ggplot2"	"Useful labeller functions"	"<p>Labeller functions are in charge of formatting the strip labels of facet grids and wraps. Most of them accept a <code>multi_line</code> argument to control whether multiple factors (defined in formulae such as <code>~first + second</code>) should be displayed on a single line separated with commas, or each on their own line. </p>"	"<pre>label_value(labels, multi_line = TRUE)<br />label_both(labels, multi_line = TRUE, sep = ': ')<br />label_context(labels, multi_line = TRUE, sep = ': ')<br />label_parsed(labels, multi_line = TRUE)<br />label_wrap_gen(width = 25, multi_line = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>labels</code></td> <td> <p>Data frame of labels. Usually contains only one element, but facetting over multiple factors entails multiple label variables.</p> </td> </tr> <tr valign='top'> <td><code>multi_line</code></td> <td> <p>Whether to display the labels of multiple factors on separate lines.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>String separating variables and values.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Maximum number of characters before wrapping the strip.</p> </td> </tr> </table> "	FALSE
"labellers"	"ggplot2"	"Useful labeller functions"	"<p>Labeller functions are in charge of formatting the strip labels of facet grids and wraps. Most of them accept a <code>multi_line</code> argument to control whether multiple factors (defined in formulae such as <code>~first + second</code>) should be displayed on a single line separated with commas, or each on their own line. </p>"	"<pre>label_value(labels, multi_line = TRUE)<br />label_both(labels, multi_line = TRUE, sep = ': ')<br />label_context(labels, multi_line = TRUE, sep = ': ')<br />label_parsed(labels, multi_line = TRUE)<br />label_wrap_gen(width = 25, multi_line = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>labels</code></td> <td> <p>Data frame of labels. Usually contains only one element, but facetting over multiple factors entails multiple label variables.</p> </td> </tr> <tr valign='top'> <td><code>multi_line</code></td> <td> <p>Whether to display the labels of multiple factors on separate lines.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>String separating variables and values.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Maximum number of characters before wrapping the strip.</p> </td> </tr> </table> "	FALSE
"labellers"	"ggplot2"	"Useful labeller functions"	"<p>Labeller functions are in charge of formatting the strip labels of facet grids and wraps. Most of them accept a <code>multi_line</code> argument to control whether multiple factors (defined in formulae such as <code>~first + second</code>) should be displayed on a single line separated with commas, or each on their own line. </p>"	"<pre>label_value(labels, multi_line = TRUE)<br />label_both(labels, multi_line = TRUE, sep = ': ')<br />label_context(labels, multi_line = TRUE, sep = ': ')<br />label_parsed(labels, multi_line = TRUE)<br />label_wrap_gen(width = 25, multi_line = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>labels</code></td> <td> <p>Data frame of labels. Usually contains only one element, but facetting over multiple factors entails multiple label variables.</p> </td> </tr> <tr valign='top'> <td><code>multi_line</code></td> <td> <p>Whether to display the labels of multiple factors on separate lines.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>String separating variables and values.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Maximum number of characters before wrapping the strip.</p> </td> </tr> </table> "	FALSE
"labs"	"ggplot2"	"Modify axis, legend, and plot labels"	"<p>Good labels are critical for making your plots accessible to a wider audience. Ensure the axis and legend labels display the full variable name. Use the plot <code>title</code> and <code>subtitle</code> to explain the main findings. It's common to use the <code>caption</code> to provide information about the data source. </p>"	"<pre>labs(...)<br />xlab(label)<br />ylab(label)<br />ggtitle(label, subtitle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A list of new name-value pairs. The name should either be an aesthetic, or one of 'title', 'subtitle', or 'caption'.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>The text for the axis, plot title or caption below the plot.</p> </td> </tr> <tr valign='top'> <td><code>subtitle</code></td> <td> <p>the text for the subtitle for the plot which will be displayed below the title. Leave <code>NULL</code> for no subtitle.</p> </td> </tr> </table> "	FALSE
"lims"	"ggplot2"	"Set scale limits"	"<p>This is a shortcut for supplying the <code>limits</code> argument to the individual scales. Note that, by default, any values outside the limits will be replaced with <code>NA</code>. </p>"	"<pre>lims(...)<br />xlim(...)<br />ylim(...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>...</code></td> <td> <p>A name-value pair. The name must be an aesthetic, and the value must be either a length-2 numeric, a character, a factor, or a date/time. </p> <p>A numeric value will create a continuous scale. If the larger value comes first, the scale will be reversed. You can leave one value as <code>NA</code> to compute from the range of the data. </p> <p>A character or factor value will create a discrete scale. </p> <p>A date-time value will create a continuous date/time scale.</p> </td> </tr></table> "	FALSE
"aes_linetype_size_shape"	"ggplot2"	"Differentiation related aesthetics: linetype, size, shape"	"<p>This page demonstrates the usage of a sub-group of aesthetics; linetype, size and shape. </p>"	NA	NA	FALSE
"luv_colours"	"ggplot2"	"colors() in Luv space"	"<p>All built-in <code>colors()</code> translated into Luv colour space. </p>"	"<pre>luv_colours </pre>"	NA	FALSE
"element"	"ggplot2"	"Theme elements"	"<p>In conjunction with the theme system, the <code>element_</code> functions specify the display of how non-data components of the plot are a drawn. </p> <ul> <li> <p><code>element_blank</code>: draws nothing, and assigns no space. </p> </li> <li> <p><code>element_rect</code>: borders and backgrounds. </p> </li> <li> <p><code>element_line</code>: lines. </p> </li> <li> <p><code>element_text</code>: text. </p> </li> </ul>  <p><code>rel()</code> is used to specify sizes relative to the parent, <code>margins()</code> is used to specify the margins of elements. </p>"	"<pre>margin(t = 0, r = 0, b = 0, l = 0, unit = 'pt')<br />element_blank()<br />element_rect(fill = NULL, colour = NULL, size = NULL, linetype = NULL,<br />   color = NULL, inherit.blank = FALSE)<br />element_line(colour = NULL, size = NULL, linetype = NULL,<br />   lineend = NULL, color = NULL, arrow = NULL, inherit.blank = FALSE)<br />element_text(family = NULL, face = NULL, colour = NULL, size = NULL,<br />   hjust = NULL, vjust = NULL, angle = NULL, lineheight = NULL,<br />   color = NULL, margin = NULL, debug = NULL, inherit.blank = FALSE)<br />rel(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>t, r, b, l</code></td> <td> <p>Dimensions of each margin. (To remember order, think trouble).</p> </td> </tr> <tr valign='top'> <td><code>unit</code></td> <td> <p>Default units of dimensions. Defaults to 'pt' so it can be most easily scaled with the text.</p> </td> </tr> <tr valign='top'> <td><code>fill</code></td> <td> <p>Fill colour.</p> </td> </tr> <tr valign='top'> <td><code>colour, color</code></td> <td> <p>Line/border colour. Color is an alias for colour.</p> </td> </tr> <tr valign='top'> <td><code>size</code></td> <td> <p>Line/border size in mm; text size in pts.</p> </td> </tr> <tr valign='top'> <td><code>linetype</code></td> <td> <p>Line type. An integer (0:8), a name (blank, solid, dashed, dotted, dotdash, longdash, twodash), or a string with an even number (up to eight) of hexadecimal digits which give the lengths in consecutive positions in the string.</p> </td> </tr> <tr valign='top'> <td><code>inherit.blank</code></td> <td> <p>Should this element inherit the existence of an <code>element_blank</code> among its parents? If <code>TRUE</code> the existence of a blank element among its parents will cause this element to be blank as well. If <code>FALSE</code> any blank parent element will be ignored when calculating final element state.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>arrow</code></td> <td> <p>Arrow specification, as created by <code>arrow</code></p> </td> </tr> <tr valign='top'> <td><code>family</code></td> <td> <p>Font family</p> </td> </tr> <tr valign='top'> <td><code>face</code></td> <td> <p>Font face ('plain', 'italic', 'bold', 'bold.italic')</p> </td> </tr> <tr valign='top'> <td><code>hjust</code></td> <td> <p>Horizontal justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>vjust</code></td> <td> <p>Vertical justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>angle</code></td> <td> <p>Angle (in [0, 360])</p> </td> </tr> <tr valign='top'> <td><code>lineheight</code></td> <td> <p>Line height</p> </td> </tr> <tr valign='top'> <td><code>margin</code></td> <td> <p>Margins around the text. See <code>margin</code> for more details. When creating a theme, the margins should be placed on the side of the text facing towards the center of the plot.</p> </td> </tr> <tr valign='top'> <td><code>debug</code></td> <td> <p>If <code>TRUE</code>, aids visual debugging by drawing a solid rectangle behind the complete text area, and a point where each label is anchored.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A single number specifying size relative to parent element.</p> </td> </tr> </table> "	FALSE
"hmisc"	"ggplot2"	"A selection of summary functions from Hmisc"	"<p>These are wrappers around functions from <span class='pkg'>Hmsic</span> designed to make them easier to use with <code>stat_summary</code>. See the Hmisc documentation for more details: </p> <ul> <li> <p><code>smean.cl.boot</code> </p> </li> <li> <p><code>smean.cl.normal</code> </p> </li> <li> <p><code>smean.sdl</code> </p> </li> <li> <p><code>smedian.hilow</code> </p> </li> </ul> "	"<pre>mean_cl_boot(x, ...)<br />mean_cl_normal(x, ...)<br />mean_sdl(x, ...)<br />median_hilow(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a numeric vector</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to the respective Hmisc function.</p> </td> </tr> </table> "	FALSE
"hmisc"	"ggplot2"	"A selection of summary functions from Hmisc"	"<p>These are wrappers around functions from <span class='pkg'>Hmsic</span> designed to make them easier to use with <code>stat_summary</code>. See the Hmisc documentation for more details: </p> <ul> <li> <p><code>smean.cl.boot</code> </p> </li> <li> <p><code>smean.cl.normal</code> </p> </li> <li> <p><code>smean.sdl</code> </p> </li> <li> <p><code>smedian.hilow</code> </p> </li> </ul> "	"<pre>mean_cl_boot(x, ...)<br />mean_cl_normal(x, ...)<br />mean_sdl(x, ...)<br />median_hilow(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a numeric vector</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to the respective Hmisc function.</p> </td> </tr> </table> "	FALSE
"hmisc"	"ggplot2"	"A selection of summary functions from Hmisc"	"<p>These are wrappers around functions from <span class='pkg'>Hmsic</span> designed to make them easier to use with <code>stat_summary</code>. See the Hmisc documentation for more details: </p> <ul> <li> <p><code>smean.cl.boot</code> </p> </li> <li> <p><code>smean.cl.normal</code> </p> </li> <li> <p><code>smean.sdl</code> </p> </li> <li> <p><code>smedian.hilow</code> </p> </li> </ul> "	"<pre>mean_cl_boot(x, ...)<br />mean_cl_normal(x, ...)<br />mean_sdl(x, ...)<br />median_hilow(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a numeric vector</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to the respective Hmisc function.</p> </td> </tr> </table> "	FALSE
"mean_se"	"ggplot2"	"Calculate mean and standard error"	"<p>For use with <code>stat_summary</code> </p>"	"<pre>mean_se(x, mult = 1) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric vector</p> </td> </tr> <tr valign='top'> <td><code>mult</code></td> <td> <p>number of multiples of standard error</p> </td> </tr> </table> "	FALSE
"hmisc"	"ggplot2"	"A selection of summary functions from Hmisc"	"<p>These are wrappers around functions from <span class='pkg'>Hmsic</span> designed to make them easier to use with <code>stat_summary</code>. See the Hmisc documentation for more details: </p> <ul> <li> <p><code>smean.cl.boot</code> </p> </li> <li> <p><code>smean.cl.normal</code> </p> </li> <li> <p><code>smean.sdl</code> </p> </li> <li> <p><code>smedian.hilow</code> </p> </li> </ul> "	"<pre>mean_cl_boot(x, ...)<br />mean_cl_normal(x, ...)<br />mean_sdl(x, ...)<br />median_hilow(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a numeric vector</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to the respective Hmisc function.</p> </td> </tr> </table> "	FALSE
"midwest"	"ggplot2"	"Midwest demographics"	"<p>Demographic information of midwest counties </p>"	"<pre>midwest </pre>"	NA	FALSE
"mpg"	"ggplot2"	"Fuel economy data from 1999 and 2008 for 38 popular models of car"	"<p>This dataset contains a subset of the fuel economy data that the EPA makes available on <a href='http://fueleconomy.gov'>http://fueleconomy.gov</a>. It contains only models which had a new release every year between 1999 and 2008 - this was used as a proxy for the popularity of the car. </p>"	"<pre>mpg </pre>"	NA	FALSE
"msleep"	"ggplot2"	"An updated and expanded version of the mammals sleep dataset"	"<p>This is an updated and expanded version of the mammals sleep dataset. Updated sleep times and weights were taken from V. M. Savage and G. B. West. A quantitative, theoretical framework for understanding mammalian sleep. Proceedings of the National Academy of Sciences, 104 (3):1051-1056, 2007. </p>"	"<pre>msleep </pre>"	NA	FALSE
"print.ggplot"	"ggplot2"	"Explicitly draw plot"	"<p>Generally, you do not need to print or plot a ggplot2 plot explicitly: the default top-level print method will do it for you. You will, however, need to call <code>print()</code> explicitly if you want to draw a plot inside a function or for loop. </p>"	"<pre>## S3 method for class 'ggplot' print(x, newpage = is.null(vp), vp = NULL, ...)<br />## S3 method for class 'ggplot' plot(x, newpage = is.null(vp), vp = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>plot to display</p> </td> </tr> <tr valign='top'> <td><code>newpage</code></td> <td> <p>draw new (empty) page first?</p> </td> </tr> <tr valign='top'> <td><code>vp</code></td> <td> <p>viewport to draw plot in</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments not used by this method</p> </td> </tr> </table> "	FALSE
"position_dodge"	"ggplot2"	"Dodge overlapping objects side-to-side"	"<p>Dodging preserves the vertical position of an geom while adjusting the horizontal position. </p>"	"<pre>position_dodge(width = NULL) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>width</code></td> <td> <p>Dodging width, when different to the width of the individual elements. This is useful when you want to align narrow geoms with wider geoms. See the examples.</p> </td> </tr></table> "	FALSE
"position_stack"	"ggplot2"	"Stack overlapping objects on top of each another"	"<p><code>position_stack()</code> stacks bars on top of each other; <code>position_fill()</code> stacks bars and standardises each stack to have constant height. </p>"	"<pre>position_stack(vjust = 1, reverse = FALSE)<br />position_fill(vjust = 1, reverse = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>vjust</code></td> <td> <p>Vertical adjustment for geoms that have a position (like points or lines), not a dimension (like bars or areas). Set to <code>0</code> to align with the bottom, <code>0.5</code> for the middle, and <code>1</code> (the default) for the top.</p> </td> </tr> <tr valign='top'> <td><code>reverse</code></td> <td> <p>If <code>TRUE</code>, will reverse the default stacking order. This is useful if you're rotating both the plot and legend.</p> </td> </tr> </table> "	FALSE
"position_identity"	"ggplot2"	"Don't adjust position"	"<p>Don't adjust position </p>"	"<pre>position_identity() </pre>"	NA	FALSE
"position_jitter"	"ggplot2"	"Jitter points to avoid overplotting"	"<p>Couterintuitively adding random noise to a plot can sometimes make it easier to read. Jittering is particularly useful for small datasets with at least one discrete position. </p>"	"<pre>position_jitter(width = NULL, height = NULL) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>width, height</code></td> <td> <p>Amount of vertical and horizontal jitter. The jitter is added in both positive and negative directions, so the total spread is twice the value specified here. </p> <p>If omitted, defaults to 40% of the resolution of the data: this means the jitter values will occupy 80% of the implied bins. Categorical data is aligned on the integers, so a width or height of 0.5 will spread the data so it's not possible to see the distinction between the categories.</p> </td> </tr></table> "	FALSE
"position_jitterdodge"	"ggplot2"	"Simultaneously dodge and jitter"	"<p>This is primarily used for aligning points generated through <code>geom_point()</code> with dodged boxplots (e.g., a <code>geom_boxplot()</code> with a fill aesthetic supplied). </p>"	"<pre>position_jitterdodge(jitter.width = NULL, jitter.height = 0,<br />   dodge.width = 0.75) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>jitter.width</code></td> <td> <p>degree of jitter in x direction. Defaults to 40% of the resolution of the data.</p> </td> </tr> <tr valign='top'> <td><code>jitter.height</code></td> <td> <p>degree of jitter in y direction. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>dodge.width</code></td> <td> <p>the amount to dodge in the x direction. Defaults to 0.75, the default <code>position_dodge()</code> width.</p> </td> </tr> </table> "	FALSE
"position_nudge"	"ggplot2"	"Nudge points a fixed distance"	"<p><code>position_nudge</code> is generally useful for adjusting the position of items on discrete scales by a small amount. Nudging is built in to <code>geom_text</code> because it's so useful for moving labels a small distance from what they're labelling. </p>"	"<pre>position_nudge(x = 0, y = 0) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x, y</code></td> <td> <p>Amount of vertical and horizontal distance to move.</p> </td> </tr></table> "	FALSE
"position_stack"	"ggplot2"	"Stack overlapping objects on top of each another"	"<p><code>position_stack()</code> stacks bars on top of each other; <code>position_fill()</code> stacks bars and standardises each stack to have constant height. </p>"	"<pre>position_stack(vjust = 1, reverse = FALSE)<br />position_fill(vjust = 1, reverse = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>vjust</code></td> <td> <p>Vertical adjustment for geoms that have a position (like points or lines), not a dimension (like bars or areas). Set to <code>0</code> to align with the bottom, <code>0.5</code> for the middle, and <code>1</code> (the default) for the top.</p> </td> </tr> <tr valign='top'> <td><code>reverse</code></td> <td> <p>If <code>TRUE</code>, will reverse the default stacking order. This is useful if you're rotating both the plot and legend.</p> </td> </tr> </table> "	FALSE
"presidential"	"ggplot2"	"Terms of 11 presidents from Eisenhower to Obama"	"<p>The names of each president, the start and end date of their term, and their party of 11 US presidents from Eisenhower to Obama. </p>"	"<pre>presidential </pre>"	NA	FALSE
"print.ggplot"	"ggplot2"	"Explicitly draw plot"	"<p>Generally, you do not need to print or plot a ggplot2 plot explicitly: the default top-level print method will do it for you. You will, however, need to call <code>print()</code> explicitly if you want to draw a plot inside a function or for loop. </p>"	"<pre>## S3 method for class 'ggplot' print(x, newpage = is.null(vp), vp = NULL, ...)<br />## S3 method for class 'ggplot' plot(x, newpage = is.null(vp), vp = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>plot to display</p> </td> </tr> <tr valign='top'> <td><code>newpage</code></td> <td> <p>draw new (empty) page first?</p> </td> </tr> <tr valign='top'> <td><code>vp</code></td> <td> <p>viewport to draw plot in</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments not used by this method</p> </td> </tr> </table> "	FALSE
"print.ggproto"	"ggplot2"	"Format or print a ggproto object"	"<p>If a ggproto object has a <code>$print</code> method, this will call that method. Otherwise, it will print out the members of the object, and optionally, the members of the inherited objects. </p>"	"<pre>## S3 method for class 'ggproto' print(x, ..., flat = TRUE)<br />## S3 method for class 'ggproto' format(x, ..., flat = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A ggproto object to print.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If the ggproto object has a <code>print</code> method, further arguments will be passed to it. Otherwise, these arguments are unused.</p> </td> </tr> <tr valign='top'> <td><code>flat</code></td> <td> <p>If <code>TRUE</code> (the default), show a flattened list of all local and inherited members. If <code>FALSE</code>, show the inheritance hierarchy.</p> </td> </tr> </table> "	FALSE
"qplot"	"ggplot2"	"Quick plot"	"<p><code>qplot</code> is a shortcut designed to be familiar if you're used to base <code>plot()</code>. It's a convenient wrapper for creating a number of different types of plots using a consistent calling scheme. It's great for allowing you to produce plots quickly, but I highly recommend learning <code>ggplot()</code> as it makes it easier to create complex graphics. </p>"	"<pre>qplot(x, y = NULL, ..., data, facets = NULL, margins = FALSE,<br />   geom = 'auto', xlim = c(NA, NA), ylim = c(NA, NA), log = '',<br />   main = NULL, xlab = deparse(substitute(x)),<br />   ylab = deparse(substitute(y)), asp = NA, stat = NULL, position = NULL)<br />quickplot(x, y = NULL, ..., data, facets = NULL, margins = FALSE,<br />   geom = 'auto', xlim = c(NA, NA), ylim = c(NA, NA), log = '',<br />   main = NULL, xlab = deparse(substitute(x)),<br />   ylab = deparse(substitute(y)), asp = NA, stat = NULL, position = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y, ...</code></td> <td> <p>Aesthetics passed into each layer</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Data frame to use (optional).  If not specified, will create one, extracting vectors from the current environment.</p> </td> </tr> <tr valign='top'> <td><code>facets</code></td> <td> <p>faceting formula to use. Picks <code>facet_wrap</code> or <code>facet_grid</code> depending on whether the formula is one- or two-sided</p> </td> </tr> <tr valign='top'> <td><code>margins</code></td> <td> <p>See <code>facet_grid</code>: display marginal facets?</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>Character vector specifying geom(s) to draw. Defaults to 'point' if x and y are specified, and 'histogram' if only x is specified.</p> </td> </tr> <tr valign='top'> <td><code>xlim, ylim</code></td> <td> <p>X and y axis limits</p> </td> </tr> <tr valign='top'> <td><code>log</code></td> <td> <p>Which variables to log transform ('x', 'y', or 'xy')</p> </td> </tr> <tr valign='top'> <td><code>main, xlab, ylab</code></td> <td> <p>Character vector (or expression) giving plot title, x axis label, and y axis label respectively.</p> </td> </tr> <tr valign='top'> <td><code>asp</code></td> <td> <p>The y/x aspect ratio</p> </td> </tr> <tr valign='top'> <td><code>stat, position</code></td> <td> <p>DEPRECATED.</p> </td> </tr> </table> "	FALSE
"qplot"	"ggplot2"	"Quick plot"	"<p><code>qplot</code> is a shortcut designed to be familiar if you're used to base <code>plot()</code>. It's a convenient wrapper for creating a number of different types of plots using a consistent calling scheme. It's great for allowing you to produce plots quickly, but I highly recommend learning <code>ggplot()</code> as it makes it easier to create complex graphics. </p>"	"<pre>qplot(x, y = NULL, ..., data, facets = NULL, margins = FALSE,<br />   geom = 'auto', xlim = c(NA, NA), ylim = c(NA, NA), log = '',<br />   main = NULL, xlab = deparse(substitute(x)),<br />   ylab = deparse(substitute(y)), asp = NA, stat = NULL, position = NULL)<br />quickplot(x, y = NULL, ..., data, facets = NULL, margins = FALSE,<br />   geom = 'auto', xlim = c(NA, NA), ylim = c(NA, NA), log = '',<br />   main = NULL, xlab = deparse(substitute(x)),<br />   ylab = deparse(substitute(y)), asp = NA, stat = NULL, position = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x, y, ...</code></td> <td> <p>Aesthetics passed into each layer</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Data frame to use (optional).  If not specified, will create one, extracting vectors from the current environment.</p> </td> </tr> <tr valign='top'> <td><code>facets</code></td> <td> <p>faceting formula to use. Picks <code>facet_wrap</code> or <code>facet_grid</code> depending on whether the formula is one- or two-sided</p> </td> </tr> <tr valign='top'> <td><code>margins</code></td> <td> <p>See <code>facet_grid</code>: display marginal facets?</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>Character vector specifying geom(s) to draw. Defaults to 'point' if x and y are specified, and 'histogram' if only x is specified.</p> </td> </tr> <tr valign='top'> <td><code>xlim, ylim</code></td> <td> <p>X and y axis limits</p> </td> </tr> <tr valign='top'> <td><code>log</code></td> <td> <p>Which variables to log transform ('x', 'y', or 'xy')</p> </td> </tr> <tr valign='top'> <td><code>main, xlab, ylab</code></td> <td> <p>Character vector (or expression) giving plot title, x axis label, and y axis label respectively.</p> </td> </tr> <tr valign='top'> <td><code>asp</code></td> <td> <p>The y/x aspect ratio</p> </td> </tr> <tr valign='top'> <td><code>stat, position</code></td> <td> <p>DEPRECATED.</p> </td> </tr> </table> "	FALSE
"element"	"ggplot2"	"Theme elements"	"<p>In conjunction with the theme system, the <code>element_</code> functions specify the display of how non-data components of the plot are a drawn. </p> <ul> <li> <p><code>element_blank</code>: draws nothing, and assigns no space. </p> </li> <li> <p><code>element_rect</code>: borders and backgrounds. </p> </li> <li> <p><code>element_line</code>: lines. </p> </li> <li> <p><code>element_text</code>: text. </p> </li> </ul>  <p><code>rel()</code> is used to specify sizes relative to the parent, <code>margins()</code> is used to specify the margins of elements. </p>"	"<pre>margin(t = 0, r = 0, b = 0, l = 0, unit = 'pt')<br />element_blank()<br />element_rect(fill = NULL, colour = NULL, size = NULL, linetype = NULL,<br />   color = NULL, inherit.blank = FALSE)<br />element_line(colour = NULL, size = NULL, linetype = NULL,<br />   lineend = NULL, color = NULL, arrow = NULL, inherit.blank = FALSE)<br />element_text(family = NULL, face = NULL, colour = NULL, size = NULL,<br />   hjust = NULL, vjust = NULL, angle = NULL, lineheight = NULL,<br />   color = NULL, margin = NULL, debug = NULL, inherit.blank = FALSE)<br />rel(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>t, r, b, l</code></td> <td> <p>Dimensions of each margin. (To remember order, think trouble).</p> </td> </tr> <tr valign='top'> <td><code>unit</code></td> <td> <p>Default units of dimensions. Defaults to 'pt' so it can be most easily scaled with the text.</p> </td> </tr> <tr valign='top'> <td><code>fill</code></td> <td> <p>Fill colour.</p> </td> </tr> <tr valign='top'> <td><code>colour, color</code></td> <td> <p>Line/border colour. Color is an alias for colour.</p> </td> </tr> <tr valign='top'> <td><code>size</code></td> <td> <p>Line/border size in mm; text size in pts.</p> </td> </tr> <tr valign='top'> <td><code>linetype</code></td> <td> <p>Line type. An integer (0:8), a name (blank, solid, dashed, dotted, dotdash, longdash, twodash), or a string with an even number (up to eight) of hexadecimal digits which give the lengths in consecutive positions in the string.</p> </td> </tr> <tr valign='top'> <td><code>inherit.blank</code></td> <td> <p>Should this element inherit the existence of an <code>element_blank</code> among its parents? If <code>TRUE</code> the existence of a blank element among its parents will cause this element to be blank as well. If <code>FALSE</code> any blank parent element will be ignored when calculating final element state.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>arrow</code></td> <td> <p>Arrow specification, as created by <code>arrow</code></p> </td> </tr> <tr valign='top'> <td><code>family</code></td> <td> <p>Font family</p> </td> </tr> <tr valign='top'> <td><code>face</code></td> <td> <p>Font face ('plain', 'italic', 'bold', 'bold.italic')</p> </td> </tr> <tr valign='top'> <td><code>hjust</code></td> <td> <p>Horizontal justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>vjust</code></td> <td> <p>Vertical justification (in [0, 1])</p> </td> </tr> <tr valign='top'> <td><code>angle</code></td> <td> <p>Angle (in [0, 360])</p> </td> </tr> <tr valign='top'> <td><code>lineheight</code></td> <td> <p>Line height</p> </td> </tr> <tr valign='top'> <td><code>margin</code></td> <td> <p>Margins around the text. See <code>margin</code> for more details. When creating a theme, the margins should be placed on the side of the text facing towards the center of the plot.</p> </td> </tr> <tr valign='top'> <td><code>debug</code></td> <td> <p>If <code>TRUE</code>, aids visual debugging by drawing a solid rectangle behind the complete text area, and a point where each label is anchored.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A single number specifying size relative to parent element.</p> </td> </tr> </table> "	FALSE
"resolution"	"ggplot2"	"Compute the \"resolution\" of a numeric vector"	"<p>The resolution is the smallest non-zero distance between adjacent values.  If there is only one unique value, then the resolution is defined to be one. If x is an integer vector, then it is assumed to represent a discrete variable, and the resolution is 1. </p>"	"<pre>resolution(x, zero = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric vector</p> </td> </tr> <tr valign='top'> <td><code>zero</code></td> <td> <p>should a zero value be automatically included in the computation of resolution</p> </td> </tr> </table> "	FALSE
"scale_alpha"	"ggplot2"	"Alpha transparency scales"	"<p>Alpha-transparency scales are not tremendously useful, but can be a convenient way to visually down-weight less important observations. <code>scale_alpha</code> is an alias for <code>scale_alpha_continuous</code> since that is the most common use of alpha, and it saves a bit of typing. </p>"	"<pre>scale_alpha(..., range = c(0.1, 1))<br />scale_alpha_continuous(..., range = c(0.1, 1))<br />scale_alpha_discrete(..., range = c(0.1, 1)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> or <code>discrete_scale</code> as appropriate, to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>Output range of alpha values. Must lie between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_alpha"	"ggplot2"	"Alpha transparency scales"	"<p>Alpha-transparency scales are not tremendously useful, but can be a convenient way to visually down-weight less important observations. <code>scale_alpha</code> is an alias for <code>scale_alpha_continuous</code> since that is the most common use of alpha, and it saves a bit of typing. </p>"	"<pre>scale_alpha(..., range = c(0.1, 1))<br />scale_alpha_continuous(..., range = c(0.1, 1))<br />scale_alpha_discrete(..., range = c(0.1, 1)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> or <code>discrete_scale</code> as appropriate, to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>Output range of alpha values. Must lie between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_alpha"	"ggplot2"	"Alpha transparency scales"	"<p>Alpha-transparency scales are not tremendously useful, but can be a convenient way to visually down-weight less important observations. <code>scale_alpha</code> is an alias for <code>scale_alpha_continuous</code> since that is the most common use of alpha, and it saves a bit of typing. </p>"	"<pre>scale_alpha(..., range = c(0.1, 1))<br />scale_alpha_continuous(..., range = c(0.1, 1))<br />scale_alpha_discrete(..., range = c(0.1, 1)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> or <code>discrete_scale</code> as appropriate, to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>Output range of alpha values. Must lie between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_identity"	"ggplot2"	"Use values without scaling"	"<p>Use this set of scales when your data has already been scaled, i.e. it already represents aesthetic values that ggplot2 can handle directly This will not produce a legend unless you also supply the <code>breaks</code> and <code>labels</code>. </p>"	"<pre>scale_colour_identity(..., guide = 'none')<br />scale_fill_identity(..., guide = 'none')<br />scale_shape_identity(..., guide = 'none')<br />scale_linetype_identity(..., guide = 'none')<br />scale_alpha_identity(..., guide = 'none')<br />scale_size_identity(..., guide = 'none') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> or <code>continuous_scale</code></p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Guide to use for this scale. Defaults to <code>'none'</code>.</p> </td> </tr> </table> "	FALSE
"scale_manual"	"ggplot2"	"Create your own discrete scale"	"<p>This allows you to specify you own set of mappings from levels in the data to aesthetic values. </p>"	"<pre>scale_colour_manual(..., values)<br />scale_fill_manual(..., values)<br />scale_size_manual(..., values)<br />scale_shape_manual(..., values)<br />scale_linetype_manual(..., values)<br />scale_alpha_manual(..., values) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>a set of aesthetic values to map data values to. If this is a named vector, then the values will be matched based on the names. If unnamed, values will be matched in order (usually alphabetical) with the limits of the scale. Any data values that don't match will be given <code>na.value</code>.</p> </td> </tr> </table> "	FALSE
"scale_brewer"	"ggplot2"	"Sequential, diverging and qualitative colour scales from colorbrewer.org"	"<p>The <code>brewer</code> scales provides sequential, diverging and qualitative colour schemes from ColorBrewer. These are particularly well suited to display discrete values on a map. See <a href='http://colorbrewer2.org'>http://colorbrewer2.org</a> for more information. </p>"	"<pre>scale_colour_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_fill_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_colour_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar')<br />scale_fill_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>One of seq (sequential), div (diverging) or qual (qualitative)</p> </td> </tr> <tr valign='top'> <td><code>palette</code></td> <td> <p>If a string, will use that named palette.  If a number, will index into the list of palettes of appropriate <code>type</code></p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>Sets the order of colors in the scale. If 1, the default, colors are as output by <code>brewer.pal</code>. If -1, the order of colors is reversed.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_hue"	"ggplot2"	"Evenly spaced colours for discrete data"	"<p>This is the default colour scale for categorical variables. It maps each level to an evenly spaced hue on the colour wheel. It does not generate colour-blind safe palettes. </p>"	"<pre>scale_colour_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50')<br />scale_fill_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>h</code></td> <td> <p>range of hues to use, in [0, 360]</p> </td> </tr> <tr valign='top'> <td><code>c</code></td> <td> <p>chroma (intensity of colour), maximum value varies depending on combination of hue and luminance.</p> </td> </tr> <tr valign='top'> <td><code>l</code></td> <td> <p>luminance (lightness), in [0, 100]</p> </td> </tr> <tr valign='top'> <td><code>h.start</code></td> <td> <p>hue to start at</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>direction to travel around the colour wheel, 1 = clockwise, -1 = counter-clockwise</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> </table> "	FALSE
"scale_brewer"	"ggplot2"	"Sequential, diverging and qualitative colour scales from colorbrewer.org"	"<p>The <code>brewer</code> scales provides sequential, diverging and qualitative colour schemes from ColorBrewer. These are particularly well suited to display discrete values on a map. See <a href='http://colorbrewer2.org'>http://colorbrewer2.org</a> for more information. </p>"	"<pre>scale_colour_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_fill_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_colour_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar')<br />scale_fill_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>One of seq (sequential), div (diverging) or qual (qualitative)</p> </td> </tr> <tr valign='top'> <td><code>palette</code></td> <td> <p>If a string, will use that named palette.  If a number, will index into the list of palettes of appropriate <code>type</code></p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>Sets the order of colors in the scale. If 1, the default, colors are as output by <code>brewer.pal</code>. If -1, the order of colors is reversed.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_grey"	"ggplot2"	"Sequential grey colour scales"	"<p>Based on <code>gray.colors</code>. This is black and white equivalent of <code>scale_colour_gradient</code>. </p>"	"<pre>scale_colour_grey(..., start = 0.2, end = 0.8, na.value = 'red')<br />scale_fill_grey(..., start = 0.2, end = 0.8, na.value = 'red') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>start</code></td> <td> <p>gray value at low end of palette</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>gray value at high end of palette</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> </table> "	FALSE
"scale_hue"	"ggplot2"	"Evenly spaced colours for discrete data"	"<p>This is the default colour scale for categorical variables. It maps each level to an evenly spaced hue on the colour wheel. It does not generate colour-blind safe palettes. </p>"	"<pre>scale_colour_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50')<br />scale_fill_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>h</code></td> <td> <p>range of hues to use, in [0, 360]</p> </td> </tr> <tr valign='top'> <td><code>c</code></td> <td> <p>chroma (intensity of colour), maximum value varies depending on combination of hue and luminance.</p> </td> </tr> <tr valign='top'> <td><code>l</code></td> <td> <p>luminance (lightness), in [0, 100]</p> </td> </tr> <tr valign='top'> <td><code>h.start</code></td> <td> <p>hue to start at</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>direction to travel around the colour wheel, 1 = clockwise, -1 = counter-clockwise</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> </table> "	FALSE
"scale_identity"	"ggplot2"	"Use values without scaling"	"<p>Use this set of scales when your data has already been scaled, i.e. it already represents aesthetic values that ggplot2 can handle directly This will not produce a legend unless you also supply the <code>breaks</code> and <code>labels</code>. </p>"	"<pre>scale_colour_identity(..., guide = 'none')<br />scale_fill_identity(..., guide = 'none')<br />scale_shape_identity(..., guide = 'none')<br />scale_linetype_identity(..., guide = 'none')<br />scale_alpha_identity(..., guide = 'none')<br />scale_size_identity(..., guide = 'none') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> or <code>continuous_scale</code></p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Guide to use for this scale. Defaults to <code>'none'</code>.</p> </td> </tr> </table> "	FALSE
"scale_manual"	"ggplot2"	"Create your own discrete scale"	"<p>This allows you to specify you own set of mappings from levels in the data to aesthetic values. </p>"	"<pre>scale_colour_manual(..., values)<br />scale_fill_manual(..., values)<br />scale_size_manual(..., values)<br />scale_shape_manual(..., values)<br />scale_linetype_manual(..., values)<br />scale_alpha_manual(..., values) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>a set of aesthetic values to map data values to. If this is a named vector, then the values will be matched based on the names. If unnamed, values will be matched in order (usually alphabetical) with the limits of the scale. Any data values that don't match will be given <code>na.value</code>.</p> </td> </tr> </table> "	FALSE
"scale_brewer"	"ggplot2"	"Sequential, diverging and qualitative colour scales from colorbrewer.org"	"<p>The <code>brewer</code> scales provides sequential, diverging and qualitative colour schemes from ColorBrewer. These are particularly well suited to display discrete values on a map. See <a href='http://colorbrewer2.org'>http://colorbrewer2.org</a> for more information. </p>"	"<pre>scale_colour_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_fill_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_colour_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar')<br />scale_fill_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>One of seq (sequential), div (diverging) or qual (qualitative)</p> </td> </tr> <tr valign='top'> <td><code>palette</code></td> <td> <p>If a string, will use that named palette.  If a number, will index into the list of palettes of appropriate <code>type</code></p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>Sets the order of colors in the scale. If 1, the default, colors are as output by <code>brewer.pal</code>. If -1, the order of colors is reversed.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_hue"	"ggplot2"	"Evenly spaced colours for discrete data"	"<p>This is the default colour scale for categorical variables. It maps each level to an evenly spaced hue on the colour wheel. It does not generate colour-blind safe palettes. </p>"	"<pre>scale_colour_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50')<br />scale_fill_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>h</code></td> <td> <p>range of hues to use, in [0, 360]</p> </td> </tr> <tr valign='top'> <td><code>c</code></td> <td> <p>chroma (intensity of colour), maximum value varies depending on combination of hue and luminance.</p> </td> </tr> <tr valign='top'> <td><code>l</code></td> <td> <p>luminance (lightness), in [0, 100]</p> </td> </tr> <tr valign='top'> <td><code>h.start</code></td> <td> <p>hue to start at</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>direction to travel around the colour wheel, 1 = clockwise, -1 = counter-clockwise</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> </table> "	FALSE
"scale_brewer"	"ggplot2"	"Sequential, diverging and qualitative colour scales from colorbrewer.org"	"<p>The <code>brewer</code> scales provides sequential, diverging and qualitative colour schemes from ColorBrewer. These are particularly well suited to display discrete values on a map. See <a href='http://colorbrewer2.org'>http://colorbrewer2.org</a> for more information. </p>"	"<pre>scale_colour_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_fill_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_colour_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar')<br />scale_fill_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>One of seq (sequential), div (diverging) or qual (qualitative)</p> </td> </tr> <tr valign='top'> <td><code>palette</code></td> <td> <p>If a string, will use that named palette.  If a number, will index into the list of palettes of appropriate <code>type</code></p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>Sets the order of colors in the scale. If 1, the default, colors are as output by <code>brewer.pal</code>. If -1, the order of colors is reversed.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_grey"	"ggplot2"	"Sequential grey colour scales"	"<p>Based on <code>gray.colors</code>. This is black and white equivalent of <code>scale_colour_gradient</code>. </p>"	"<pre>scale_colour_grey(..., start = 0.2, end = 0.8, na.value = 'red')<br />scale_fill_grey(..., start = 0.2, end = 0.8, na.value = 'red') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>start</code></td> <td> <p>gray value at low end of palette</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>gray value at high end of palette</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> </table> "	FALSE
"scale_hue"	"ggplot2"	"Evenly spaced colours for discrete data"	"<p>This is the default colour scale for categorical variables. It maps each level to an evenly spaced hue on the colour wheel. It does not generate colour-blind safe palettes. </p>"	"<pre>scale_colour_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50')<br />scale_fill_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>h</code></td> <td> <p>range of hues to use, in [0, 360]</p> </td> </tr> <tr valign='top'> <td><code>c</code></td> <td> <p>chroma (intensity of colour), maximum value varies depending on combination of hue and luminance.</p> </td> </tr> <tr valign='top'> <td><code>l</code></td> <td> <p>luminance (lightness), in [0, 100]</p> </td> </tr> <tr valign='top'> <td><code>h.start</code></td> <td> <p>hue to start at</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>direction to travel around the colour wheel, 1 = clockwise, -1 = counter-clockwise</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> </table> "	FALSE
"scale_identity"	"ggplot2"	"Use values without scaling"	"<p>Use this set of scales when your data has already been scaled, i.e. it already represents aesthetic values that ggplot2 can handle directly This will not produce a legend unless you also supply the <code>breaks</code> and <code>labels</code>. </p>"	"<pre>scale_colour_identity(..., guide = 'none')<br />scale_fill_identity(..., guide = 'none')<br />scale_shape_identity(..., guide = 'none')<br />scale_linetype_identity(..., guide = 'none')<br />scale_alpha_identity(..., guide = 'none')<br />scale_size_identity(..., guide = 'none') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> or <code>continuous_scale</code></p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Guide to use for this scale. Defaults to <code>'none'</code>.</p> </td> </tr> </table> "	FALSE
"scale_manual"	"ggplot2"	"Create your own discrete scale"	"<p>This allows you to specify you own set of mappings from levels in the data to aesthetic values. </p>"	"<pre>scale_colour_manual(..., values)<br />scale_fill_manual(..., values)<br />scale_size_manual(..., values)<br />scale_shape_manual(..., values)<br />scale_linetype_manual(..., values)<br />scale_alpha_manual(..., values) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>a set of aesthetic values to map data values to. If this is a named vector, then the values will be matched based on the names. If unnamed, values will be matched in order (usually alphabetical) with the limits of the scale. Any data values that don't match will be given <code>na.value</code>.</p> </td> </tr> </table> "	FALSE
"scale_brewer"	"ggplot2"	"Sequential, diverging and qualitative colour scales from colorbrewer.org"	"<p>The <code>brewer</code> scales provides sequential, diverging and qualitative colour schemes from ColorBrewer. These are particularly well suited to display discrete values on a map. See <a href='http://colorbrewer2.org'>http://colorbrewer2.org</a> for more information. </p>"	"<pre>scale_colour_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_fill_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_colour_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar')<br />scale_fill_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>One of seq (sequential), div (diverging) or qual (qualitative)</p> </td> </tr> <tr valign='top'> <td><code>palette</code></td> <td> <p>If a string, will use that named palette.  If a number, will index into the list of palettes of appropriate <code>type</code></p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>Sets the order of colors in the scale. If 1, the default, colors are as output by <code>brewer.pal</code>. If -1, the order of colors is reversed.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_hue"	"ggplot2"	"Evenly spaced colours for discrete data"	"<p>This is the default colour scale for categorical variables. It maps each level to an evenly spaced hue on the colour wheel. It does not generate colour-blind safe palettes. </p>"	"<pre>scale_colour_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50')<br />scale_fill_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>h</code></td> <td> <p>range of hues to use, in [0, 360]</p> </td> </tr> <tr valign='top'> <td><code>c</code></td> <td> <p>chroma (intensity of colour), maximum value varies depending on combination of hue and luminance.</p> </td> </tr> <tr valign='top'> <td><code>l</code></td> <td> <p>luminance (lightness), in [0, 100]</p> </td> </tr> <tr valign='top'> <td><code>h.start</code></td> <td> <p>hue to start at</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>direction to travel around the colour wheel, 1 = clockwise, -1 = counter-clockwise</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> </table> "	FALSE
"scale_brewer"	"ggplot2"	"Sequential, diverging and qualitative colour scales from colorbrewer.org"	"<p>The <code>brewer</code> scales provides sequential, diverging and qualitative colour schemes from ColorBrewer. These are particularly well suited to display discrete values on a map. See <a href='http://colorbrewer2.org'>http://colorbrewer2.org</a> for more information. </p>"	"<pre>scale_colour_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_fill_brewer(..., type = 'seq', palette = 1, direction = 1)<br />scale_colour_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar')<br />scale_fill_distiller(..., type = 'seq', palette = 1, direction = -1,<br />   values = NULL, space = 'Lab', na.value = 'grey50',<br />   guide = 'colourbar') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>One of seq (sequential), div (diverging) or qual (qualitative)</p> </td> </tr> <tr valign='top'> <td><code>palette</code></td> <td> <p>If a string, will use that named palette.  If a number, will index into the list of palettes of appropriate <code>type</code></p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>Sets the order of colors in the scale. If 1, the default, colors are as output by <code>brewer.pal</code>. If -1, the order of colors is reversed.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_gradient"	"ggplot2"	"Gradient colour scales"	"<p><code>scale_*_gradient</code> creates a two colour gradient (low-high), <code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high), <code>scale_*_gradientn</code> creats a n-colour gradient. </p>"	"<pre>scale_colour_gradient(..., low = '#132B43', high = '#56B1F7',<br />   space = 'Lab', na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient(..., low = '#132B43', high = '#56B1F7', space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_fill_gradient2(..., low = muted('red'), mid = 'white',<br />   high = muted('blue'), midpoint = 0, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar')<br />scale_colour_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors)<br />scale_fill_gradientn(..., colours, values = NULL, space = 'Lab',<br />   na.value = 'grey50', guide = 'colourbar', colors) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>low, high</code></td> <td> <p>Colours for low and high ends of the gradient.</p> </td> </tr> <tr valign='top'> <td><code>space</code></td> <td> <p>colour space in which to calculate gradient. Must be 'Lab' - other values are deprecated.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Type of legend. Use <code>'colourbar'</code> for continuous colour bar, or <code>'legend'</code> for discrete colour legend.</p> </td> </tr> <tr valign='top'> <td><code>mid</code></td> <td> <p>colour for mid point</p> </td> </tr> <tr valign='top'> <td><code>midpoint</code></td> <td> <p>The midpoint (in data value) of the diverging scale. Defaults to 0.</p> </td> </tr> <tr valign='top'> <td><code>colours, colors</code></td> <td> <p>Vector of colours to use for n-colour gradient.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>if colours should not be evenly positioned along the gradient this vector gives the position (between 0 and 1) for each colour in the <code>colours</code> vector. See <code>rescale</code> for a convience function to map an arbitrary range to between 0 and 1.</p> </td> </tr> </table> "	FALSE
"scale_grey"	"ggplot2"	"Sequential grey colour scales"	"<p>Based on <code>gray.colors</code>. This is black and white equivalent of <code>scale_colour_gradient</code>. </p>"	"<pre>scale_colour_grey(..., start = 0.2, end = 0.8, na.value = 'red')<br />scale_fill_grey(..., start = 0.2, end = 0.8, na.value = 'red') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>start</code></td> <td> <p>gray value at low end of palette</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>gray value at high end of palette</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> </table> "	FALSE
"scale_hue"	"ggplot2"	"Evenly spaced colours for discrete data"	"<p>This is the default colour scale for categorical variables. It maps each level to an evenly spaced hue on the colour wheel. It does not generate colour-blind safe palettes. </p>"	"<pre>scale_colour_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50')<br />scale_fill_hue(..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0,<br />   direction = 1, na.value = 'grey50') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>h</code></td> <td> <p>range of hues to use, in [0, 360]</p> </td> </tr> <tr valign='top'> <td><code>c</code></td> <td> <p>chroma (intensity of colour), maximum value varies depending on combination of hue and luminance.</p> </td> </tr> <tr valign='top'> <td><code>l</code></td> <td> <p>luminance (lightness), in [0, 100]</p> </td> </tr> <tr valign='top'> <td><code>h.start</code></td> <td> <p>hue to start at</p> </td> </tr> <tr valign='top'> <td><code>direction</code></td> <td> <p>direction to travel around the colour wheel, 1 = clockwise, -1 = counter-clockwise</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Colour to use for missing values</p> </td> </tr> </table> "	FALSE
"scale_identity"	"ggplot2"	"Use values without scaling"	"<p>Use this set of scales when your data has already been scaled, i.e. it already represents aesthetic values that ggplot2 can handle directly This will not produce a legend unless you also supply the <code>breaks</code> and <code>labels</code>. </p>"	"<pre>scale_colour_identity(..., guide = 'none')<br />scale_fill_identity(..., guide = 'none')<br />scale_shape_identity(..., guide = 'none')<br />scale_linetype_identity(..., guide = 'none')<br />scale_alpha_identity(..., guide = 'none')<br />scale_size_identity(..., guide = 'none') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> or <code>continuous_scale</code></p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Guide to use for this scale. Defaults to <code>'none'</code>.</p> </td> </tr> </table> "	FALSE
"scale_manual"	"ggplot2"	"Create your own discrete scale"	"<p>This allows you to specify you own set of mappings from levels in the data to aesthetic values. </p>"	"<pre>scale_colour_manual(..., values)<br />scale_fill_manual(..., values)<br />scale_size_manual(..., values)<br />scale_shape_manual(..., values)<br />scale_linetype_manual(..., values)<br />scale_alpha_manual(..., values) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>a set of aesthetic values to map data values to. If this is a named vector, then the values will be matched based on the names. If unnamed, values will be matched in order (usually alphabetical) with the limits of the scale. Any data values that don't match will be given <code>na.value</code>.</p> </td> </tr> </table> "	FALSE
"scale_linetype"	"ggplot2"	"Scale for line patterns"	"<p>Default line types based on a set supplied by Richard Pearson, University of Manchester. Continuous values can not be mapped to line types. </p>"	"<pre>scale_linetype(..., na.value = 'blank')<br />scale_linetype_continuous(...)<br />scale_linetype_discrete(..., na.value = 'blank') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>The linetype to use for <code>NA</code> values.</p> </td> </tr> </table> "	FALSE
"scale_linetype"	"ggplot2"	"Scale for line patterns"	"<p>Default line types based on a set supplied by Richard Pearson, University of Manchester. Continuous values can not be mapped to line types. </p>"	"<pre>scale_linetype(..., na.value = 'blank')<br />scale_linetype_continuous(...)<br />scale_linetype_discrete(..., na.value = 'blank') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>The linetype to use for <code>NA</code> values.</p> </td> </tr> </table> "	FALSE
"scale_linetype"	"ggplot2"	"Scale for line patterns"	"<p>Default line types based on a set supplied by Richard Pearson, University of Manchester. Continuous values can not be mapped to line types. </p>"	"<pre>scale_linetype(..., na.value = 'blank')<br />scale_linetype_continuous(...)<br />scale_linetype_discrete(..., na.value = 'blank') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>The linetype to use for <code>NA</code> values.</p> </td> </tr> </table> "	FALSE
"scale_identity"	"ggplot2"	"Use values without scaling"	"<p>Use this set of scales when your data has already been scaled, i.e. it already represents aesthetic values that ggplot2 can handle directly This will not produce a legend unless you also supply the <code>breaks</code> and <code>labels</code>. </p>"	"<pre>scale_colour_identity(..., guide = 'none')<br />scale_fill_identity(..., guide = 'none')<br />scale_shape_identity(..., guide = 'none')<br />scale_linetype_identity(..., guide = 'none')<br />scale_alpha_identity(..., guide = 'none')<br />scale_size_identity(..., guide = 'none') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> or <code>continuous_scale</code></p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Guide to use for this scale. Defaults to <code>'none'</code>.</p> </td> </tr> </table> "	FALSE
"scale_manual"	"ggplot2"	"Create your own discrete scale"	"<p>This allows you to specify you own set of mappings from levels in the data to aesthetic values. </p>"	"<pre>scale_colour_manual(..., values)<br />scale_fill_manual(..., values)<br />scale_size_manual(..., values)<br />scale_shape_manual(..., values)<br />scale_linetype_manual(..., values)<br />scale_alpha_manual(..., values) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>a set of aesthetic values to map data values to. If this is a named vector, then the values will be matched based on the names. If unnamed, values will be matched in order (usually alphabetical) with the limits of the scale. Any data values that don't match will be given <code>na.value</code>.</p> </td> </tr> </table> "	FALSE
"scale_size"	"ggplot2"	"Scales for area or radius"	"<p><code>scale_size</code> scales area, <code>scale_radius</code> scales radius. The size aesthetic is most commonly used for points and text, and humans perceive the area of points (not their radius), so this provides for optimal perception. <code>scale_size_area</code> ensures that a value of 0 is mapped to a size of 0. </p>"	"<pre>scale_radius(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size_area(..., max_size = 6) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>a numeric vector of length 2 that specifies the minimum and maximum size of the plotting symbol after transformation.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Name of guide object, or object itself.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>max_size</code></td> <td> <p>Size of largest points.</p> </td> </tr> </table> "	FALSE
"scale_shape"	"ggplot2"	"Scales for shapes, aka glyphs"	"<p><code>scale_shape</code> maps discrete variables to six easily discernible shapes. If you have more than six levels, you will get a warning message, and the seventh and subsequence levels will not appear on the plot. Use <code>scale_shape_manual</code> to supply your own values. You can not map a continuous variable to shape. </p>"	"<pre>scale_shape(..., solid = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>solid</code></td> <td> <p>Should the shapes be solid, <code>TRUE</code>, or hollow, <code>FALSE</code>?</p> </td> </tr> </table> "	FALSE
"scale_shape"	"ggplot2"	"Scales for shapes, aka glyphs"	"<p><code>scale_shape</code> maps discrete variables to six easily discernible shapes. If you have more than six levels, you will get a warning message, and the seventh and subsequence levels will not appear on the plot. Use <code>scale_shape_manual</code> to supply your own values. You can not map a continuous variable to shape. </p>"	"<pre>scale_shape(..., solid = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>solid</code></td> <td> <p>Should the shapes be solid, <code>TRUE</code>, or hollow, <code>FALSE</code>?</p> </td> </tr> </table> "	FALSE
"scale_shape"	"ggplot2"	"Scales for shapes, aka glyphs"	"<p><code>scale_shape</code> maps discrete variables to six easily discernible shapes. If you have more than six levels, you will get a warning message, and the seventh and subsequence levels will not appear on the plot. Use <code>scale_shape_manual</code> to supply your own values. You can not map a continuous variable to shape. </p>"	"<pre>scale_shape(..., solid = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>solid</code></td> <td> <p>Should the shapes be solid, <code>TRUE</code>, or hollow, <code>FALSE</code>?</p> </td> </tr> </table> "	FALSE
"scale_identity"	"ggplot2"	"Use values without scaling"	"<p>Use this set of scales when your data has already been scaled, i.e. it already represents aesthetic values that ggplot2 can handle directly This will not produce a legend unless you also supply the <code>breaks</code> and <code>labels</code>. </p>"	"<pre>scale_colour_identity(..., guide = 'none')<br />scale_fill_identity(..., guide = 'none')<br />scale_shape_identity(..., guide = 'none')<br />scale_linetype_identity(..., guide = 'none')<br />scale_alpha_identity(..., guide = 'none')<br />scale_size_identity(..., guide = 'none') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> or <code>continuous_scale</code></p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Guide to use for this scale. Defaults to <code>'none'</code>.</p> </td> </tr> </table> "	FALSE
"scale_manual"	"ggplot2"	"Create your own discrete scale"	"<p>This allows you to specify you own set of mappings from levels in the data to aesthetic values. </p>"	"<pre>scale_colour_manual(..., values)<br />scale_fill_manual(..., values)<br />scale_size_manual(..., values)<br />scale_shape_manual(..., values)<br />scale_linetype_manual(..., values)<br />scale_alpha_manual(..., values) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>a set of aesthetic values to map data values to. If this is a named vector, then the values will be matched based on the names. If unnamed, values will be matched in order (usually alphabetical) with the limits of the scale. Any data values that don't match will be given <code>na.value</code>.</p> </td> </tr> </table> "	FALSE
"scale_size"	"ggplot2"	"Scales for area or radius"	"<p><code>scale_size</code> scales area, <code>scale_radius</code> scales radius. The size aesthetic is most commonly used for points and text, and humans perceive the area of points (not their radius), so this provides for optimal perception. <code>scale_size_area</code> ensures that a value of 0 is mapped to a size of 0. </p>"	"<pre>scale_radius(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size_area(..., max_size = 6) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>a numeric vector of length 2 that specifies the minimum and maximum size of the plotting symbol after transformation.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Name of guide object, or object itself.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>max_size</code></td> <td> <p>Size of largest points.</p> </td> </tr> </table> "	FALSE
"scale_size"	"ggplot2"	"Scales for area or radius"	"<p><code>scale_size</code> scales area, <code>scale_radius</code> scales radius. The size aesthetic is most commonly used for points and text, and humans perceive the area of points (not their radius), so this provides for optimal perception. <code>scale_size_area</code> ensures that a value of 0 is mapped to a size of 0. </p>"	"<pre>scale_radius(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size_area(..., max_size = 6) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>a numeric vector of length 2 that specifies the minimum and maximum size of the plotting symbol after transformation.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Name of guide object, or object itself.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>max_size</code></td> <td> <p>Size of largest points.</p> </td> </tr> </table> "	FALSE
"scale_size"	"ggplot2"	"Scales for area or radius"	"<p><code>scale_size</code> scales area, <code>scale_radius</code> scales radius. The size aesthetic is most commonly used for points and text, and humans perceive the area of points (not their radius), so this provides for optimal perception. <code>scale_size_area</code> ensures that a value of 0 is mapped to a size of 0. </p>"	"<pre>scale_radius(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size_area(..., max_size = 6) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>a numeric vector of length 2 that specifies the minimum and maximum size of the plotting symbol after transformation.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Name of guide object, or object itself.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>max_size</code></td> <td> <p>Size of largest points.</p> </td> </tr> </table> "	FALSE
"scale_size"	"ggplot2"	"Scales for area or radius"	"<p><code>scale_size</code> scales area, <code>scale_radius</code> scales radius. The size aesthetic is most commonly used for points and text, and humans perceive the area of points (not their radius), so this provides for optimal perception. <code>scale_size_area</code> ensures that a value of 0 is mapped to a size of 0. </p>"	"<pre>scale_radius(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size_area(..., max_size = 6) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>a numeric vector of length 2 that specifies the minimum and maximum size of the plotting symbol after transformation.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Name of guide object, or object itself.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>max_size</code></td> <td> <p>Size of largest points.</p> </td> </tr> </table> "	FALSE
"scale_size"	"ggplot2"	"Scales for area or radius"	"<p><code>scale_size</code> scales area, <code>scale_radius</code> scales radius. The size aesthetic is most commonly used for points and text, and humans perceive the area of points (not their radius), so this provides for optimal perception. <code>scale_size_area</code> ensures that a value of 0 is mapped to a size of 0. </p>"	"<pre>scale_radius(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size_area(..., max_size = 6) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>a numeric vector of length 2 that specifies the minimum and maximum size of the plotting symbol after transformation.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Name of guide object, or object itself.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>max_size</code></td> <td> <p>Size of largest points.</p> </td> </tr> </table> "	FALSE
"scale_size"	"ggplot2"	"Scales for area or radius"	"<p><code>scale_size</code> scales area, <code>scale_radius</code> scales radius. The size aesthetic is most commonly used for points and text, and humans perceive the area of points (not their radius), so this provides for optimal perception. <code>scale_size_area</code> ensures that a value of 0 is mapped to a size of 0. </p>"	"<pre>scale_radius(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size(name = waiver(), breaks = waiver(), labels = waiver(),<br />   limits = NULL, range = c(1, 6), trans = 'identity', guide = 'legend')<br />scale_size_area(..., max_size = 6) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>range</code></td> <td> <p>a numeric vector of length 2 that specifies the minimum and maximum size of the plotting symbol after transformation.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Name of guide object, or object itself.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>continuous_scale</code> to control name, limits, breaks, labels and so forth.</p> </td> </tr> <tr valign='top'> <td><code>max_size</code></td> <td> <p>Size of largest points.</p> </td> </tr> </table> "	FALSE
"scale_identity"	"ggplot2"	"Use values without scaling"	"<p>Use this set of scales when your data has already been scaled, i.e. it already represents aesthetic values that ggplot2 can handle directly This will not produce a legend unless you also supply the <code>breaks</code> and <code>labels</code>. </p>"	"<pre>scale_colour_identity(..., guide = 'none')<br />scale_fill_identity(..., guide = 'none')<br />scale_shape_identity(..., guide = 'none')<br />scale_linetype_identity(..., guide = 'none')<br />scale_alpha_identity(..., guide = 'none')<br />scale_size_identity(..., guide = 'none') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>discrete_scale</code> or <code>continuous_scale</code></p> </td> </tr> <tr valign='top'> <td><code>guide</code></td> <td> <p>Guide to use for this scale. Defaults to <code>'none'</code>.</p> </td> </tr> </table> "	FALSE
"scale_manual"	"ggplot2"	"Create your own discrete scale"	"<p>This allows you to specify you own set of mappings from levels in the data to aesthetic values. </p>"	"<pre>scale_colour_manual(..., values)<br />scale_fill_manual(..., values)<br />scale_size_manual(..., values)<br />scale_shape_manual(..., values)<br />scale_linetype_manual(..., values)<br />scale_alpha_manual(..., values) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>a set of aesthetic values to map data values to. If this is a named vector, then the values will be matched based on the names. If unnamed, values will be matched in order (usually alphabetical) with the limits of the scale. Any data values that don't match will be given <code>na.value</code>.</p> </td> </tr> </table> "	FALSE
"scale_continuous"	"ggplot2"	"Position scales for continuous data (x & y)"	"<p><code>scale_x_continuous</code> and <code>scale_y_continuous</code> are the default scales for continuous x and y aesthetics. There are three variants that set the <code>trans</code> argument for commonly used transformations: <code>scale_*_log10</code>, <code>scale_*_sqrt</code> and <code>scale_*_reverse</code>. </p>"	"<pre>scale_x_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'bottom', sec.axis = waiver())<br />scale_y_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'left', sec.axis = waiver())<br />scale_x_log10(...)<br />scale_y_log10(...)<br />scale_x_reverse(...)<br />scale_y_reverse(...)<br />scale_x_sqrt(...)<br />scale_y_sqrt(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>sec.axis</code></td> <td> <p>specifify a secondary axis</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>scale_(x|y)_continuous</code></p> </td> </tr> </table> "	FALSE
"scale_date"	"ggplot2"	"Position scales for date/time data"	"<p>These are the default scales for the three date/time class. These will usually be added automatically. To override manually, use <code>scale_*_date</code> for dates (class <code>Date</code>), <code>scale_*_datetime</code> for datetimes (class <code>POSIXct</code>), and <code>scale_*_time</code> for times (class <code>hms</code>). </p>"	"<pre>scale_x_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'bottom')<br />scale_y_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'left')<br />scale_x_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'bottom')<br />scale_y_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'left')<br />scale_x_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'bottom')<br />scale_y_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'left') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_breaks</code></td> <td> <p>A string giving the distance between breaks like '2 weeks', or '10 years'. If both <code>breaks</code> and <code>date_breaks</code> are specified, <code>date_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_labels</code></td> <td> <p>A string giving the formatting specification for the labels. Codes are defined in <code>strftime</code>. If both <code>labels</code> and <code>date_labels</code> are specified, <code>date_labels</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_minor_breaks</code></td> <td> <p>A string giving the distance between minor breaks like '2 weeks', or '10 years'. If both <code>minor_breaks</code> and <code>date_minor_breaks</code> are specified, <code>date_minor_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>timezone</code></td> <td> <p>The timezone to use for display on the axes. The default (<code>NULL</code>) uses the timezone encoded in the data.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> </table> "	FALSE
"scale_date"	"ggplot2"	"Position scales for date/time data"	"<p>These are the default scales for the three date/time class. These will usually be added automatically. To override manually, use <code>scale_*_date</code> for dates (class <code>Date</code>), <code>scale_*_datetime</code> for datetimes (class <code>POSIXct</code>), and <code>scale_*_time</code> for times (class <code>hms</code>). </p>"	"<pre>scale_x_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'bottom')<br />scale_y_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'left')<br />scale_x_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'bottom')<br />scale_y_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'left')<br />scale_x_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'bottom')<br />scale_y_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'left') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_breaks</code></td> <td> <p>A string giving the distance between breaks like '2 weeks', or '10 years'. If both <code>breaks</code> and <code>date_breaks</code> are specified, <code>date_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_labels</code></td> <td> <p>A string giving the formatting specification for the labels. Codes are defined in <code>strftime</code>. If both <code>labels</code> and <code>date_labels</code> are specified, <code>date_labels</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_minor_breaks</code></td> <td> <p>A string giving the distance between minor breaks like '2 weeks', or '10 years'. If both <code>minor_breaks</code> and <code>date_minor_breaks</code> are specified, <code>date_minor_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>timezone</code></td> <td> <p>The timezone to use for display on the axes. The default (<code>NULL</code>) uses the timezone encoded in the data.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> </table> "	FALSE
"scale_discrete"	"ggplot2"	"Position scales for discrete data"	"<p>You can use continuous positions even with a discrete position scale - this allows you (e.g.) to place labels between bars in a bar chart. Continuous positions are numeric values starting at one for the first level, and increasing by one for each level (i.e. the labels are placed at integer positions).  This is what allows jittering to work. </p>"	"<pre>scale_x_discrete(..., expand = waiver(), position = 'bottom')<br />scale_y_discrete(..., expand = waiver(), position = 'left') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>a numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. <code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes</p> </td> </tr> </table> "	FALSE
"scale_continuous"	"ggplot2"	"Position scales for continuous data (x & y)"	"<p><code>scale_x_continuous</code> and <code>scale_y_continuous</code> are the default scales for continuous x and y aesthetics. There are three variants that set the <code>trans</code> argument for commonly used transformations: <code>scale_*_log10</code>, <code>scale_*_sqrt</code> and <code>scale_*_reverse</code>. </p>"	"<pre>scale_x_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'bottom', sec.axis = waiver())<br />scale_y_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'left', sec.axis = waiver())<br />scale_x_log10(...)<br />scale_y_log10(...)<br />scale_x_reverse(...)<br />scale_y_reverse(...)<br />scale_x_sqrt(...)<br />scale_y_sqrt(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>sec.axis</code></td> <td> <p>specifify a secondary axis</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>scale_(x|y)_continuous</code></p> </td> </tr> </table> "	FALSE
"scale_continuous"	"ggplot2"	"Position scales for continuous data (x & y)"	"<p><code>scale_x_continuous</code> and <code>scale_y_continuous</code> are the default scales for continuous x and y aesthetics. There are three variants that set the <code>trans</code> argument for commonly used transformations: <code>scale_*_log10</code>, <code>scale_*_sqrt</code> and <code>scale_*_reverse</code>. </p>"	"<pre>scale_x_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'bottom', sec.axis = waiver())<br />scale_y_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'left', sec.axis = waiver())<br />scale_x_log10(...)<br />scale_y_log10(...)<br />scale_x_reverse(...)<br />scale_y_reverse(...)<br />scale_x_sqrt(...)<br />scale_y_sqrt(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>sec.axis</code></td> <td> <p>specifify a secondary axis</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>scale_(x|y)_continuous</code></p> </td> </tr> </table> "	FALSE
"scale_continuous"	"ggplot2"	"Position scales for continuous data (x & y)"	"<p><code>scale_x_continuous</code> and <code>scale_y_continuous</code> are the default scales for continuous x and y aesthetics. There are three variants that set the <code>trans</code> argument for commonly used transformations: <code>scale_*_log10</code>, <code>scale_*_sqrt</code> and <code>scale_*_reverse</code>. </p>"	"<pre>scale_x_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'bottom', sec.axis = waiver())<br />scale_y_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'left', sec.axis = waiver())<br />scale_x_log10(...)<br />scale_y_log10(...)<br />scale_x_reverse(...)<br />scale_y_reverse(...)<br />scale_x_sqrt(...)<br />scale_y_sqrt(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>sec.axis</code></td> <td> <p>specifify a secondary axis</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>scale_(x|y)_continuous</code></p> </td> </tr> </table> "	FALSE
"scale_date"	"ggplot2"	"Position scales for date/time data"	"<p>These are the default scales for the three date/time class. These will usually be added automatically. To override manually, use <code>scale_*_date</code> for dates (class <code>Date</code>), <code>scale_*_datetime</code> for datetimes (class <code>POSIXct</code>), and <code>scale_*_time</code> for times (class <code>hms</code>). </p>"	"<pre>scale_x_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'bottom')<br />scale_y_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'left')<br />scale_x_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'bottom')<br />scale_y_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'left')<br />scale_x_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'bottom')<br />scale_y_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'left') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_breaks</code></td> <td> <p>A string giving the distance between breaks like '2 weeks', or '10 years'. If both <code>breaks</code> and <code>date_breaks</code> are specified, <code>date_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_labels</code></td> <td> <p>A string giving the formatting specification for the labels. Codes are defined in <code>strftime</code>. If both <code>labels</code> and <code>date_labels</code> are specified, <code>date_labels</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_minor_breaks</code></td> <td> <p>A string giving the distance between minor breaks like '2 weeks', or '10 years'. If both <code>minor_breaks</code> and <code>date_minor_breaks</code> are specified, <code>date_minor_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>timezone</code></td> <td> <p>The timezone to use for display on the axes. The default (<code>NULL</code>) uses the timezone encoded in the data.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> </table> "	FALSE
"scale_continuous"	"ggplot2"	"Position scales for continuous data (x & y)"	"<p><code>scale_x_continuous</code> and <code>scale_y_continuous</code> are the default scales for continuous x and y aesthetics. There are three variants that set the <code>trans</code> argument for commonly used transformations: <code>scale_*_log10</code>, <code>scale_*_sqrt</code> and <code>scale_*_reverse</code>. </p>"	"<pre>scale_x_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'bottom', sec.axis = waiver())<br />scale_y_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'left', sec.axis = waiver())<br />scale_x_log10(...)<br />scale_y_log10(...)<br />scale_x_reverse(...)<br />scale_y_reverse(...)<br />scale_x_sqrt(...)<br />scale_y_sqrt(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>sec.axis</code></td> <td> <p>specifify a secondary axis</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>scale_(x|y)_continuous</code></p> </td> </tr> </table> "	FALSE
"scale_date"	"ggplot2"	"Position scales for date/time data"	"<p>These are the default scales for the three date/time class. These will usually be added automatically. To override manually, use <code>scale_*_date</code> for dates (class <code>Date</code>), <code>scale_*_datetime</code> for datetimes (class <code>POSIXct</code>), and <code>scale_*_time</code> for times (class <code>hms</code>). </p>"	"<pre>scale_x_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'bottom')<br />scale_y_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'left')<br />scale_x_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'bottom')<br />scale_y_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'left')<br />scale_x_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'bottom')<br />scale_y_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'left') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_breaks</code></td> <td> <p>A string giving the distance between breaks like '2 weeks', or '10 years'. If both <code>breaks</code> and <code>date_breaks</code> are specified, <code>date_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_labels</code></td> <td> <p>A string giving the formatting specification for the labels. Codes are defined in <code>strftime</code>. If both <code>labels</code> and <code>date_labels</code> are specified, <code>date_labels</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_minor_breaks</code></td> <td> <p>A string giving the distance between minor breaks like '2 weeks', or '10 years'. If both <code>minor_breaks</code> and <code>date_minor_breaks</code> are specified, <code>date_minor_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>timezone</code></td> <td> <p>The timezone to use for display on the axes. The default (<code>NULL</code>) uses the timezone encoded in the data.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> </table> "	FALSE
"scale_date"	"ggplot2"	"Position scales for date/time data"	"<p>These are the default scales for the three date/time class. These will usually be added automatically. To override manually, use <code>scale_*_date</code> for dates (class <code>Date</code>), <code>scale_*_datetime</code> for datetimes (class <code>POSIXct</code>), and <code>scale_*_time</code> for times (class <code>hms</code>). </p>"	"<pre>scale_x_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'bottom')<br />scale_y_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'left')<br />scale_x_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'bottom')<br />scale_y_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'left')<br />scale_x_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'bottom')<br />scale_y_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'left') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_breaks</code></td> <td> <p>A string giving the distance between breaks like '2 weeks', or '10 years'. If both <code>breaks</code> and <code>date_breaks</code> are specified, <code>date_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_labels</code></td> <td> <p>A string giving the formatting specification for the labels. Codes are defined in <code>strftime</code>. If both <code>labels</code> and <code>date_labels</code> are specified, <code>date_labels</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_minor_breaks</code></td> <td> <p>A string giving the distance between minor breaks like '2 weeks', or '10 years'. If both <code>minor_breaks</code> and <code>date_minor_breaks</code> are specified, <code>date_minor_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>timezone</code></td> <td> <p>The timezone to use for display on the axes. The default (<code>NULL</code>) uses the timezone encoded in the data.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> </table> "	FALSE
"scale_discrete"	"ggplot2"	"Position scales for discrete data"	"<p>You can use continuous positions even with a discrete position scale - this allows you (e.g.) to place labels between bars in a bar chart. Continuous positions are numeric values starting at one for the first level, and increasing by one for each level (i.e. the labels are placed at integer positions).  This is what allows jittering to work. </p>"	"<pre>scale_x_discrete(..., expand = waiver(), position = 'bottom')<br />scale_y_discrete(..., expand = waiver(), position = 'left') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>common discrete scale parameters: <code>name</code>, <code>breaks</code>, <code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See <code>discrete_scale</code> for more details</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>a numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. <code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes</p> </td> </tr> </table> "	FALSE
"scale_continuous"	"ggplot2"	"Position scales for continuous data (x & y)"	"<p><code>scale_x_continuous</code> and <code>scale_y_continuous</code> are the default scales for continuous x and y aesthetics. There are three variants that set the <code>trans</code> argument for commonly used transformations: <code>scale_*_log10</code>, <code>scale_*_sqrt</code> and <code>scale_*_reverse</code>. </p>"	"<pre>scale_x_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'bottom', sec.axis = waiver())<br />scale_y_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'left', sec.axis = waiver())<br />scale_x_log10(...)<br />scale_y_log10(...)<br />scale_x_reverse(...)<br />scale_y_reverse(...)<br />scale_x_sqrt(...)<br />scale_y_sqrt(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>sec.axis</code></td> <td> <p>specifify a secondary axis</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>scale_(x|y)_continuous</code></p> </td> </tr> </table> "	FALSE
"scale_continuous"	"ggplot2"	"Position scales for continuous data (x & y)"	"<p><code>scale_x_continuous</code> and <code>scale_y_continuous</code> are the default scales for continuous x and y aesthetics. There are three variants that set the <code>trans</code> argument for commonly used transformations: <code>scale_*_log10</code>, <code>scale_*_sqrt</code> and <code>scale_*_reverse</code>. </p>"	"<pre>scale_x_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'bottom', sec.axis = waiver())<br />scale_y_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'left', sec.axis = waiver())<br />scale_x_log10(...)<br />scale_y_log10(...)<br />scale_x_reverse(...)<br />scale_y_reverse(...)<br />scale_x_sqrt(...)<br />scale_y_sqrt(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>sec.axis</code></td> <td> <p>specifify a secondary axis</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>scale_(x|y)_continuous</code></p> </td> </tr> </table> "	FALSE
"scale_continuous"	"ggplot2"	"Position scales for continuous data (x & y)"	"<p><code>scale_x_continuous</code> and <code>scale_y_continuous</code> are the default scales for continuous x and y aesthetics. There are three variants that set the <code>trans</code> argument for commonly used transformations: <code>scale_*_log10</code>, <code>scale_*_sqrt</code> and <code>scale_*_reverse</code>. </p>"	"<pre>scale_x_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'bottom', sec.axis = waiver())<br />scale_y_continuous(name = waiver(), breaks = waiver(),<br />   minor_breaks = waiver(), labels = waiver(), limits = NULL,<br />   expand = waiver(), oob = censor, na.value = NA_real_,<br />   trans = 'identity', position = 'left', sec.axis = waiver())<br />scale_x_log10(...)<br />scale_y_log10(...)<br />scale_x_reverse(...)<br />scale_y_reverse(...)<br />scale_x_sqrt(...)<br />scale_y_sqrt(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> <tr valign='top'> <td><code>trans</code></td> <td> <p>Either the name of a transformation object, or the object itself. Built-in transformations include 'asn', 'atanh', 'boxcox', 'exp', 'identity', 'log', 'log10', 'log1p', 'log2', 'logit', 'probability', 'probit', 'reciprocal', 'reverse' and 'sqrt'. </p> <p>A transformation object bundles together a transform, it's inverse, and methods for generating breaks and labels. Transformation objects are defined in the scales package, and are called <code>name_trans</code>, e.g. <code>boxcox_trans</code>. You can create your own transformation with <code>trans_new</code>.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>sec.axis</code></td> <td> <p>specifify a secondary axis</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>scale_(x|y)_continuous</code></p> </td> </tr> </table> "	FALSE
"scale_date"	"ggplot2"	"Position scales for date/time data"	"<p>These are the default scales for the three date/time class. These will usually be added automatically. To override manually, use <code>scale_*_date</code> for dates (class <code>Date</code>), <code>scale_*_datetime</code> for datetimes (class <code>POSIXct</code>), and <code>scale_*_time</code> for times (class <code>hms</code>). </p>"	"<pre>scale_x_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'bottom')<br />scale_y_date(name = waiver(), breaks = waiver(), date_breaks = waiver(),<br />   labels = waiver(), date_labels = waiver(), minor_breaks = waiver(),<br />   date_minor_breaks = waiver(), limits = NULL, expand = waiver(),<br />   position = 'left')<br />scale_x_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'bottom')<br />scale_y_datetime(name = waiver(), breaks = waiver(),<br />   date_breaks = waiver(), labels = waiver(), date_labels = waiver(),<br />   minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL,<br />   limits = NULL, expand = waiver(), position = 'left')<br />scale_x_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'bottom')<br />scale_y_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(),<br />   labels = waiver(), limits = NULL, expand = waiver(), oob = censor,<br />   na.value = NA_real_, position = 'left') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the scale. Used as axis or legend title. If <code>NULL</code>, the default, the name of the scale is taken from the first mapping used for that aesthetic.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_breaks</code></td> <td> <p>A string giving the distance between breaks like '2 weeks', or '10 years'. If both <code>breaks</code> and <code>date_breaks</code> are specified, <code>date_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p> A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p> A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_labels</code></td> <td> <p>A string giving the formatting specification for the labels. Codes are defined in <code>strftime</code>. If both <code>labels</code> and <code>date_labels</code> are specified, <code>date_labels</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>minor_breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no minor breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks (one minor break between each major break) </p> </li> <li> <p> A numeric vector of positions </p> </li> <li> <p> A function that given the limits returns a vector of minor breaks. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>date_minor_breaks</code></td> <td> <p>A string giving the distance between minor breaks like '2 weeks', or '10 years'. If both <code>minor_breaks</code> and <code>date_minor_breaks</code> are specified, <code>date_minor_breaks</code> wins.</p> </td> </tr> <tr valign='top'> <td><code>limits</code></td> <td> <p>A numeric vector of length two providing limits of the scale. Use <code>NA</code> to refer to the existing minimum or maximum.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>A numeric vector of length two giving multiplicative and additive expansion constants. These constants ensure that the data is placed some distance away from the axes. The defaults are <code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for discrete variables.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>The position of the axis. 'left' or 'right' for vertical scales, 'top' or 'bottom' for horizontal scales</p> </td> </tr> <tr valign='top'> <td><code>timezone</code></td> <td> <p>The timezone to use for display on the axes. The default (<code>NULL</code>) uses the timezone encoded in the data.</p> </td> </tr> <tr valign='top'> <td><code>oob</code></td> <td> <p>Function that handles limits outside of the scale limits (out of bounds). The default replaces out of bounds values with NA.</p> </td> </tr> <tr valign='top'> <td><code>na.value</code></td> <td> <p>Missing values will be replaced with this value.</p> </td> </tr> </table> "	FALSE
"seals"	"ggplot2"	"Vector field of seal movements"	"<p>This vector field was produced from the data described in Brillinger, D.R., Preisler, H.K., Ager, A.A. and Kie, J.G. 'An exploratory data analysis (EDA) of the paths of moving animals'. J. Statistical Planning and Inference 122 (2004), 43-63, using the methods of Brillinger, D.R., 'Learning a potential function from a trajectory', Signal Processing Letters. December (2007). </p>"	"<pre>seals </pre>"	NA	FALSE
"sec_axis"	"ggplot2"	"Specify a secondary axis"	"<p>This function is used in conjunction with a position scale to create a secondary axis, positioned opposite of the primary axis. All secondary axes must be based on a one-to-one transformation of the primary axes. </p>"	"<pre>sec_axis(trans = NULL, name = waiver(), breaks = waiver(),<br />   labels = waiver())<br />dup_axis(trans = ~., name = derive(), breaks = derive(),<br />   labels = derive())<br />derive() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>trans</code></td> <td> <p>A transformation formula</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the secondary axis</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no breaks </p> </li> <li> <p><code>waiver()</code> for the default breaks computed by the transformation object </p> </li> <li> <p>A numeric vector of positions </p> </li> <li> <p>A function that takes the limits as input and returns breaks as output </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>One of: </p><br /><ul> <li> <p><code>NULL</code> for no labels </p> </li> <li> <p><code>waiver()</code> for the default labels computed by the transformation object </p> </li> <li> <p>A character vector giving labels (must be same length as <code>breaks</code>) </p> </li> <li> <p>A function that takes the breaks as input and returns labels as output </p> </li> </ul> </td> </tr> </table> "	FALSE
"aes_linetype_size_shape"	"ggplot2"	"Differentiation related aesthetics: linetype, size, shape"	"<p>This page demonstrates the usage of a sub-group of aesthetics; linetype, size and shape. </p>"	NA	NA	FALSE
"aes_linetype_size_shape"	"ggplot2"	"Differentiation related aesthetics: linetype, size, shape"	"<p>This page demonstrates the usage of a sub-group of aesthetics; linetype, size and shape. </p>"	NA	NA	FALSE
"geom_histogram"	"ggplot2"	"Histograms and frequency polygons"	"<p>Visualise the distribution of a single continuous variable by dividing the x axis into bins and counting the number of observations in each bin. Histograms (<code>geom_histogram</code>) display the count with bars; frequency polygons (<code>geom_freqpoly</code>), display the counts with lines. Frequency polygons are more suitable when you want to compare the distribution across a the levels of a categorical variable. </p> <p><code>stat_bin</code> is suitable only for continuous x data. If your x data is discrete, you probably want to use <code>stat_count</code>. </p>"	"<pre>geom_freqpoly(mapping = NULL, data = NULL, stat = 'bin',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />geom_histogram(mapping = NULL, data = NULL, stat = 'bin',<br />   position = 'stack', ..., binwidth = NULL, bins = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />stat_bin(mapping = NULL, data = NULL, geom = 'bar', position = 'stack',<br />   ..., binwidth = NULL, bins = NULL, center = NULL, boundary = NULL,<br />   breaks = NULL, closed = c('right', 'left'), pad = FALSE,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>The width of the bins. The default is to use <code>bins</code> bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data. </p> <p>The bin width of a date variable is the number of days in each time; the bin width of a time variable is the number of seconds.</p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>Number of bins. Overridden by <code>binwidth</code>. Defaults to 30</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_histogram</code>/<code>geom_freqpoly</code> and <code>stat_bin</code>.</p> </td> </tr> <tr valign='top'> <td><code>center</code></td> <td> <p>The center of one of the bins.  Note that if center is above or below the range of the data, things will be shifted by an appropriate number of <code>width</code>s. To center on integers, for example, use <code>width = 1</code> and <code>center = 0</code>, even if <code>0</code> is outside the range of the data.  At most one of <code>center</code> and <code>boundary</code> may be specified.</p> </td> </tr> <tr valign='top'> <td><code>boundary</code></td> <td> <p>A boundary between two bins. As with <code>center</code>, things are shifted when <code>boundary</code> is outside the range of the data. For example, to center on integers, use <code>width = 1</code> and <code>boundary = 0.5</code>, even if <code>0.5</code> is outside the range of the data.  At most one of <code>center</code> and <code>boundary</code> may be specified.</p> </td> </tr> <tr valign='top'> <td><code>breaks</code></td> <td> <p>Alternatively, you can supply a numeric vector giving the bin boundaries. Overrides <code>binwidth</code>, <code>bins</code>, <code>center</code>, and <code>boundary</code>.</p> </td> </tr> <tr valign='top'> <td><code>closed</code></td> <td> <p>One of <code>'right'</code> or <code>'left'</code> indicating whether right or left edges of bins are included in the bin.</p> </td> </tr> <tr valign='top'> <td><code>pad</code></td> <td> <p>If <code>TRUE</code>, adds empty bins at either end of x. This ensures frequency polygons touch 0. Defaults to <code>FALSE</code>.</p> </td> </tr> </table> "	FALSE
"geom_bin2d"	"ggplot2"	"Heatmap of 2d bin counts"	"<p>Divides the plane into rectangles, counts the number of cases in each rectangle, and then (by default) maps the number of cases to the rectangle's fill. This is a useful alternative to <code>geom_point</code> in the presence of overplotting. </p>"	"<pre>geom_bin2d(mapping = NULL, data = NULL, stat = 'bin2d',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_bin_2d(mapping = NULL, data = NULL, geom = 'tile',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, drop = TRUE,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_bin2d</code> and <code>stat_bin2d</code>.</p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>numeric vector giving number of bins in both vertical and horizontal directions. Set to 30 by default.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>Numeric vector giving bin width in both vertical and horizontal directions. Overrides <code>bins</code> if both set.</p> </td> </tr> <tr valign='top'> <td><code>drop</code></td> <td> <p>if <code>TRUE</code> removes all cells with 0 counts.</p> </td> </tr> </table> "	FALSE
"geom_hex"	"ggplot2"	"Hexagonal heatmap of 2d bin counts"	"<p>Divides the plane into regular hexagons, counts the number of cases in each hexagon, and then (by default) maps the number of cases to the hexagon fill.  Hexagon bins avoid the visual artefacts sometimes generated by the very regular alignment of <code>geom_bin2d</code>. </p>"	"<pre>geom_hex(mapping = NULL, data = NULL, stat = 'binhex',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_bin_hex(mapping = NULL, data = NULL, geom = 'hex',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Override the default connection between <code>geom_hex</code> and <code>stat_binhex.</code></p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>numeric vector giving number of bins in both vertical and horizontal directions. Set to 30 by default.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>Numeric vector giving bin width in both vertical and horizontal directions. Overrides <code>bins</code> if both set.</p> </td> </tr> </table> "	FALSE
"geom_bin2d"	"ggplot2"	"Heatmap of 2d bin counts"	"<p>Divides the plane into rectangles, counts the number of cases in each rectangle, and then (by default) maps the number of cases to the rectangle's fill. This is a useful alternative to <code>geom_point</code> in the presence of overplotting. </p>"	"<pre>geom_bin2d(mapping = NULL, data = NULL, stat = 'bin2d',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_bin_2d(mapping = NULL, data = NULL, geom = 'tile',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, drop = TRUE,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_bin2d</code> and <code>stat_bin2d</code>.</p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>numeric vector giving number of bins in both vertical and horizontal directions. Set to 30 by default.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>Numeric vector giving bin width in both vertical and horizontal directions. Overrides <code>bins</code> if both set.</p> </td> </tr> <tr valign='top'> <td><code>drop</code></td> <td> <p>if <code>TRUE</code> removes all cells with 0 counts.</p> </td> </tr> </table> "	FALSE
"geom_hex"	"ggplot2"	"Hexagonal heatmap of 2d bin counts"	"<p>Divides the plane into regular hexagons, counts the number of cases in each hexagon, and then (by default) maps the number of cases to the hexagon fill.  Hexagon bins avoid the visual artefacts sometimes generated by the very regular alignment of <code>geom_bin2d</code>. </p>"	"<pre>geom_hex(mapping = NULL, data = NULL, stat = 'binhex',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_bin_hex(mapping = NULL, data = NULL, geom = 'hex',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Override the default connection between <code>geom_hex</code> and <code>stat_binhex.</code></p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>numeric vector giving number of bins in both vertical and horizontal directions. Set to 30 by default.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>Numeric vector giving bin width in both vertical and horizontal directions. Overrides <code>bins</code> if both set.</p> </td> </tr> </table> "	FALSE
"geom_boxplot"	"ggplot2"	"A box and whiskers plot (in the style of Tukey)"	"<p>The boxplot compactly displays the distribution of a continuous variable. It visualises five summary statistics (the median, two hinges and two whiskers), and all 'outlying' points individually. </p>"	"<pre>geom_boxplot(mapping = NULL, data = NULL, stat = 'boxplot',<br />   position = 'dodge', ..., outlier.colour = NULL, outlier.color = NULL,<br />   outlier.fill = NULL, outlier.shape = 19, outlier.size = 1.5,<br />   outlier.stroke = 0.5, outlier.alpha = NULL, notch = FALSE,<br />   notchwidth = 0.5, varwidth = FALSE, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_boxplot(mapping = NULL, data = NULL, geom = 'boxplot',<br />   position = 'dodge', ..., coef = 1.5, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>outlier.colour, outlier.color, outlier.fill, outlier.shape, outlier.size, outlier.stroke, outlier.alpha</code></td> <td> <p>Default aesthetics for outliers. Set to <code>NULL</code> to inherit from the aesthetics used for the box. </p> <p>In the unlikely event you specify both US and UK spellings of colour, the US spelling will take precedence.</p> </td> </tr> <tr valign='top'> <td><code>notch</code></td> <td> <p>if <code>FALSE</code> (default) make a standard box plot. If <code>TRUE</code>, make a notched box plot. Notches are used to compare groups; if the notches of two boxes do not overlap, this suggests that the medians are significantly different.</p> </td> </tr> <tr valign='top'> <td><code>notchwidth</code></td> <td> <p>for a notched box plot, width of the notch relative to the body (default 0.5)</p> </td> </tr> <tr valign='top'> <td><code>varwidth</code></td> <td> <p>if <code>FALSE</code> (default) make a standard box plot. If <code>TRUE</code>, boxes are drawn with widths proportional to the square-roots of the number of observations in the groups (possibly weighted, using the <code>weight</code> aesthetic).</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_boxplot</code> and <code>stat_boxplot</code>.</p> </td> </tr> <tr valign='top'> <td><code>coef</code></td> <td> <p>length of the whiskers as multiple of IQR.  Defaults to 1.5</p> </td> </tr> </table> "	FALSE
"geom_contour"	"ggplot2"	"2d contours of a 3d surface"	"<p>ggplot2 can not draw true 3d surfaces, but you can use <code>geom_contour</code> and <code>geom_tile</code> to visualise 3d surfaces in 2d. To be a valid surface, the data must contain only a single row for each unique combination of the variables mapped to the <code>x</code> and <code>y</code> aesthetics. Contouring tends to work best when <code>x</code> and <code>y</code> form a (roughly) evenly spaced grid. If you data is not evenly spaced, you may want to interpolate to a grid before visualising. </p>"	"<pre>geom_contour(mapping = NULL, data = NULL, stat = 'contour',<br />   position = 'identity', ..., lineend = 'butt', linejoin = 'round',<br />   linemitre = 1, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_contour(mapping = NULL, data = NULL, geom = 'contour',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>linejoin</code></td> <td> <p>Line join style (round, mitre, bevel)</p> </td> </tr> <tr valign='top'> <td><code>linemitre</code></td> <td> <p>Line mitre limit (number greater than 1)</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> </table> "	FALSE
"geom_bar"	"ggplot2"	"Bars charts"	"<p>There are two types of bar charts: <code>geom_bar</code> makes the height of the bar proportional to the number of cases in each group (or if the <code>weight</code> aethetic is supplied, the sum of the weights). If you want the heights of the bars to represent values in the data, use geom_col instead. <code>geom_bar</code> uses <code>stat_count</code> by default: it counts the  number of cases at each x position. <code>geom_col</code> uses <code>stat_identity</code>: it leaves the data as is. </p>"	"<pre>geom_bar(mapping = NULL, data = NULL, stat = 'count',<br />   position = 'stack', ..., width = NULL, binwidth = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />geom_col(mapping = NULL, data = NULL, position = 'stack', ...,<br />   width = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_count(mapping = NULL, data = NULL, geom = 'bar',<br />   position = 'stack', ..., width = NULL, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Bar width. By default, set to 90% of the resolution of the data.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p><code>geom_bar</code> no longer has a binwidth argument - if you use it you'll get an warning telling to you use <code>geom_histogram</code> instead.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Override the default connection between <code>geom_bar</code> and <code>stat_count</code>.</p> </td> </tr> </table> "	FALSE
"geom_density"	"ggplot2"	"Smoothed density estimates"	"<p>Computes and draws kernel density estimate, which is a smoothed version of the histogram. This is a useful alternative to the histogram if for continuous data that comes from an underlying smooth distribution. </p>"	"<pre>geom_density(mapping = NULL, data = NULL, stat = 'density',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_density(mapping = NULL, data = NULL, geom = 'area',<br />   position = 'stack', ..., bw = 'nrd0', adjust = 1, kernel = 'gaussian',<br />   n = 512, trim = FALSE, na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_density</code> and <code>stat_density</code>.</p> </td> </tr> <tr valign='top'> <td><code>bw</code></td> <td> <p>The smoothing bandwidth to be used. If numeric, the standard deviation of the smoothing kernel. If character, a rule to choose the bandwidth, as listed in <code>bw.nrd</code>.</p> </td> </tr> <tr valign='top'> <td><code>adjust</code></td> <td> <p>A multiplicate bandwidth adjustment. This makes it possible to adjust the bandwidth while still using the a bandwidth estimator. For exampe, <code>adjust = 1/2</code> means use half of the default bandwidth.</p> </td> </tr> <tr valign='top'> <td><code>kernel</code></td> <td> <p>Kernel. See list of available kernels in <code>density</code>.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of equally spaced points at which the density is to be estimated, should be a power of two, see <code>density</code> for details</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>This parameter only matters if you are displaying multiple densities in one plot. If <code>FALSE</code>, the default, each density is computed on the full range of the data. If <code>TRUE</code>, each density is computed over the range of that group: this typically means the estimated x values will not line-up, and hence you won't be able to stack density values.</p> </td> </tr> </table> "	FALSE
"geom_density_2d"	"ggplot2"	"Contours of a 2d density estimate"	"<p>Perform a 2D kernel density estimation using <code>kde2d</code> and display the results with contours. This can be useful for dealing with overplotting. This is a 2d version of <code>geom_density</code>. </p>"	"<pre>geom_density_2d(mapping = NULL, data = NULL, stat = 'density2d',<br />   position = 'identity', ..., lineend = 'butt', linejoin = 'round',<br />   linemitre = 1, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_density_2d(mapping = NULL, data = NULL, geom = 'density_2d',<br />   position = 'identity', ..., contour = TRUE, n = 100, h = NULL,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>linejoin</code></td> <td> <p>Line join style (round, mitre, bevel)</p> </td> </tr> <tr valign='top'> <td><code>linemitre</code></td> <td> <p>Line mitre limit (number greater than 1)</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_density_2d</code> and <code>stat_density_2d</code>.</p> </td> </tr> <tr valign='top'> <td><code>contour</code></td> <td> <p>If <code>TRUE</code>, contour the results of the 2d density estimation</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of grid points in each direction</p> </td> </tr> <tr valign='top'> <td><code>h</code></td> <td> <p>Bandwidth (vector of length two). If <code>NULL</code>, estimated using <code>bandwidth.nrd</code>.</p> </td> </tr> </table> "	FALSE
"geom_density_2d"	"ggplot2"	"Contours of a 2d density estimate"	"<p>Perform a 2D kernel density estimation using <code>kde2d</code> and display the results with contours. This can be useful for dealing with overplotting. This is a 2d version of <code>geom_density</code>. </p>"	"<pre>geom_density_2d(mapping = NULL, data = NULL, stat = 'density2d',<br />   position = 'identity', ..., lineend = 'butt', linejoin = 'round',<br />   linemitre = 1, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_density_2d(mapping = NULL, data = NULL, geom = 'density_2d',<br />   position = 'identity', ..., contour = TRUE, n = 100, h = NULL,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>linejoin</code></td> <td> <p>Line join style (round, mitre, bevel)</p> </td> </tr> <tr valign='top'> <td><code>linemitre</code></td> <td> <p>Line mitre limit (number greater than 1)</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_density_2d</code> and <code>stat_density_2d</code>.</p> </td> </tr> <tr valign='top'> <td><code>contour</code></td> <td> <p>If <code>TRUE</code>, contour the results of the 2d density estimation</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of grid points in each direction</p> </td> </tr> <tr valign='top'> <td><code>h</code></td> <td> <p>Bandwidth (vector of length two). If <code>NULL</code>, estimated using <code>bandwidth.nrd</code>.</p> </td> </tr> </table> "	FALSE
"stat_ecdf"	"ggplot2"	"Compute empirical cumulative distribution"	"<p>The empirical cumulative distribution function (ECDF) provides an alternative visualisation of distribution. Compared to other visualisations that rely on density (like <code>geom_histogram</code>), the ECDF doesn't require any tuning parameters and handles both continuous and categorical variables. The downside is that it requires more training to accurately interpret, and the underlying visual tasks are somewhat more challenging. </p>"	"<pre>stat_ecdf(mapping = NULL, data = NULL, geom = 'step',<br />   position = 'identity', ..., n = NULL, pad = TRUE, na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>if NULL, do not interpolate. If not NULL, this is the number of points to interpolate with.</p> </td> </tr> <tr valign='top'> <td><code>pad</code></td> <td> <p>If <code>TRUE</code>, pad the ecdf with additional points (-Inf, 0) and (Inf, 1)</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code> (the default), removes missing values with a warning.  If <code>TRUE</code> silently removes missing values.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"stat_ellipse"	"ggplot2"	"Compute normal confidence ellipses"	"<p>The method for calculating the ellipses has been modified from <code>car::ellipse</code> (Fox and Weisberg, 2011) </p>"	"<pre>stat_ellipse(mapping = NULL, data = NULL, geom = 'path',<br />   position = 'identity', ..., type = 't', level = 0.95, segments = 51,<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>The type of ellipse. The default <code>'t'</code> assumes a multivariate t-distribution, and <code>'norm'</code> assumes a multivariate normal distribution. <code>'euclid'</code> draws a circle with the radius equal to <code>level</code>, representing the euclidean distance from the center. This ellipse probably won't appear circular unless <code>coord_fixed()</code> is applied.</p> </td> </tr> <tr valign='top'> <td><code>level</code></td> <td> <p>The confidence level at which to draw an ellipse (default is 0.95), or, if <code>type='euclid'</code>, the radius of the circle to be drawn.</p> </td> </tr> <tr valign='top'> <td><code>segments</code></td> <td> <p>The number of segments to be used in drawing the ellipse.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"stat_function"	"ggplot2"	"Compute function for each x value"	"<p>This stat makes it easy to superimpose a function on top of an existing plot. The function is called with a grid of evenly spaced values along the x axis, and the results are drawn (by default) with a line. </p>"	"<pre>stat_function(mapping = NULL, data = NULL, geom = 'path',<br />   position = 'identity', ..., fun, xlim = NULL, n = 101, args = list(),<br />   na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>fun</code></td> <td> <p>function to use. Must be vectorised.</p> </td> </tr> <tr valign='top'> <td><code>xlim</code></td> <td> <p>Optionally, restrict the range of the function to this range.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of points to interpolate along</p> </td> </tr> <tr valign='top'> <td><code>args</code></td> <td> <p>list of additional arguments to pass to <code>fun</code></p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"stat_identity"	"ggplot2"	"Leave data as is"	"<p>The identity statistic leaves the data unchanged. </p>"	"<pre>stat_identity(mapping = NULL, data = NULL, geom = 'point',<br />   position = 'identity', ..., show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_qq"	"ggplot2"	"A quantile-quantile plot"	"<p>A quantile-quantile plot </p>"	"<pre>geom_qq(mapping = NULL, data = NULL, geom = 'point',<br />   position = 'identity', ..., distribution = stats::qnorm,<br />   dparams = list(), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_qq(mapping = NULL, data = NULL, geom = 'point',<br />   position = 'identity', ..., distribution = stats::qnorm,<br />   dparams = list(), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>distribution</code></td> <td> <p>Distribution function to use, if x not specified</p> </td> </tr> <tr valign='top'> <td><code>dparams</code></td> <td> <p>Additional parameters passed on to <code>distribution</code> function.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_quantile"	"ggplot2"	"Quantile regression"	"<p>This fits a quantile regression to the data and draws the fitted quantiles with lines. This is as a continuous analogue to <code>geom_boxplot</code>. </p>"	"<pre>geom_quantile(mapping = NULL, data = NULL, stat = 'quantile',<br />   position = 'identity', ..., lineend = 'butt', linejoin = 'round',<br />   linemitre = 1, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_quantile(mapping = NULL, data = NULL, geom = 'quantile',<br />   position = 'identity', ..., quantiles = c(0.25, 0.5, 0.75),<br />   formula = NULL, method = 'rq', method.args = list(), na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>lineend</code></td> <td> <p>Line end style (round, butt, square)</p> </td> </tr> <tr valign='top'> <td><code>linejoin</code></td> <td> <p>Line join style (round, mitre, bevel)</p> </td> </tr> <tr valign='top'> <td><code>linemitre</code></td> <td> <p>Line mitre limit (number greater than 1)</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_quantile</code> and <code>stat_quantile</code>.</p> </td> </tr> <tr valign='top'> <td><code>quantiles</code></td> <td> <p>conditional quantiles of y to calculate and display</p> </td> </tr> <tr valign='top'> <td><code>formula</code></td> <td> <p>formula relating y variables to x variables</p> </td> </tr> <tr valign='top'> <td><code>method</code></td> <td> <p>Quantile regression method to use.  Currently only supports <code>rq</code>.</p> </td> </tr> <tr valign='top'> <td><code>method.args</code></td> <td> <p>List of additional arguments passed on to the modelling function defined by <code>method</code>.</p> </td> </tr> </table> "	FALSE
"geom_smooth"	"ggplot2"	"Smoothed conditional means"	"<p>Aids the eye in seeing patterns in the presence of overplotting. <code>geom_smooth</code> and <code>stat_smooth</code> are effectively aliases: they both use the same arguments. Use <code>geom_smooth</code> unless you want to display the results with a non-standard geom. </p>"	"<pre>geom_smooth(mapping = NULL, data = NULL, stat = 'smooth',<br />   position = 'identity', ..., method = 'auto', formula = y ~ x,<br />   se = TRUE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_smooth(mapping = NULL, data = NULL, geom = 'smooth',<br />   position = 'identity', ..., method = 'auto', formula = y ~ x,<br />   se = TRUE, n = 80, span = 0.75, fullrange = FALSE, level = 0.95,<br />   method.args = list(), na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>method</code></td> <td> <p>smoothing method (function) to use, eg. 'lm', 'glm', 'gam', 'loess', 'rlm'. </p> <p>For <code>method = 'auto'</code> the smoothing method is chosen based on the size of the largest group (across all panels). <code>loess</code> is used for than 1,000 observations; otherwise <code>gam</code> is used with <code>formula = y ~ s(x, bs = 'cs')</code>. Somewhat anecdotally, <code>loess</code> gives a better appearance, but is O(n^2) in memory, so does not work for larger datasets.</p> </td> </tr> <tr valign='top'> <td><code>formula</code></td> <td> <p>formula to use in smoothing function, eg. <code>y ~ x</code>, <code>y ~ poly(x, 2)</code>, <code>y ~ log(x)</code></p> </td> </tr> <tr valign='top'> <td><code>se</code></td> <td> <p>display confidence interval around smooth? (TRUE by default, see level to control</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_smooth</code> and <code>stat_smooth</code>.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of points to evaluate smoother at</p> </td> </tr> <tr valign='top'> <td><code>span</code></td> <td> <p>Controls the amount of smoothing for the default loess smoother. Smaller numbers produce wigglier lines, larger numbers produce smoother lines.</p> </td> </tr> <tr valign='top'> <td><code>fullrange</code></td> <td> <p>should the fit span the full range of the plot, or just the data</p> </td> </tr> <tr valign='top'> <td><code>level</code></td> <td> <p>level of confidence interval to use (0.95 by default)</p> </td> </tr> <tr valign='top'> <td><code>method.args</code></td> <td> <p>List of additional arguments passed on to the modelling function defined by <code>method</code>.</p> </td> </tr> </table> "	FALSE
"geom_spoke"	"ggplot2"	"Line segments parameterised by location, direction and distance"	"<p>This is a polar parameterisation of <code>geom_segment</code>. It is useful when you have variables that describe direction and distance. </p>"	"<pre>geom_spoke(mapping = NULL, data = NULL, stat = 'identity',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>stat</code></td> <td> <p>The statistical transformation to use on the data for this layer, as a string.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_count"	"ggplot2"	"Count overlapping points"	"<p>This is a variant <code>geom_point</code> that counts the number of observations at each location, then maps the count to point area. It useful when you have discrete data and overplotting. </p>"	"<pre>geom_count(mapping = NULL, data = NULL, stat = 'sum',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_sum(mapping = NULL, data = NULL, geom = 'point',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_count</code> and <code>stat_sum</code>.</p> </td> </tr> </table> "	FALSE
"stat_summary"	"ggplot2"	"Summarise y values at unique/binned x"	"<p><code>stat_summary</code> operates on unique <code>x</code>; <code>stat_summary_bin</code> operators on binned <code>x</code>. They are more flexible versions of <code>stat_bin</code>: instead of just counting, they can compute any aggregate. </p>"	"<pre>stat_summary_bin(mapping = NULL, data = NULL, geom = 'pointrange',<br />   position = 'identity', ..., fun.data = NULL, fun.y = NULL,<br />   fun.ymax = NULL, fun.ymin = NULL, fun.args = list(), na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />stat_summary(mapping = NULL, data = NULL, geom = 'pointrange',<br />   position = 'identity', ..., fun.data = NULL, fun.y = NULL,<br />   fun.ymax = NULL, fun.ymin = NULL, fun.args = list(), na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>Use to override the default connection between <code>geom_histogram</code>/<code>geom_freqpoly</code> and <code>stat_bin</code>.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>fun.data</code></td> <td> <p>A function that is given the complete data and should return a data frame with variables <code>ymin</code>, <code>y</code>, and <code>ymax</code>.</p> </td> </tr> <tr valign='top'> <td><code>fun.ymin, fun.y, fun.ymax</code></td> <td> <p>Alternatively, supply three individual functions that are each passed a vector of x's and should return a single number.</p> </td> </tr> <tr valign='top'> <td><code>fun.args</code></td> <td> <p>Optional additional arguments passed on to the functions.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"stat_summary_2d"	"ggplot2"	"Bin and summarise in 2d (rectangle & hexagons)"	"<p><code>stat_summary_2d</code> is a 2d variation of <code>stat_summary</code>. <code>stat_summary_hex</code> is a hexagonal variation of <code>stat_summary_2d</code>. The data are divided into bins defined by <code>x</code> and <code>y</code>, and then the values of <code>z</code> in each cell is are summarised with <code>fun</code>. </p>"	"<pre>stat_summary_2d(mapping = NULL, data = NULL, geom = 'tile',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, drop = TRUE,<br />   fun = 'mean', fun.args = list(), na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_summary_hex(mapping = NULL, data = NULL, geom = 'hex',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, drop = TRUE,<br />   fun = 'mean', fun.args = list(), na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>numeric vector giving number of bins in both vertical and horizontal directions. Set to 30 by default.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>Numeric vector giving bin width in both vertical and horizontal directions. Overrides <code>bins</code> if both set.</p> </td> </tr> <tr valign='top'> <td><code>drop</code></td> <td> <p>drop if the output of <code>fun</code> is <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>fun</code></td> <td> <p>function for summary.</p> </td> </tr> <tr valign='top'> <td><code>fun.args</code></td> <td> <p>A list of extra arguments to pass to <code>fun</code></p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"stat_summary_2d"	"ggplot2"	"Bin and summarise in 2d (rectangle & hexagons)"	"<p><code>stat_summary_2d</code> is a 2d variation of <code>stat_summary</code>. <code>stat_summary_hex</code> is a hexagonal variation of <code>stat_summary_2d</code>. The data are divided into bins defined by <code>x</code> and <code>y</code>, and then the values of <code>z</code> in each cell is are summarised with <code>fun</code>. </p>"	"<pre>stat_summary_2d(mapping = NULL, data = NULL, geom = 'tile',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, drop = TRUE,<br />   fun = 'mean', fun.args = list(), na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_summary_hex(mapping = NULL, data = NULL, geom = 'hex',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, drop = TRUE,<br />   fun = 'mean', fun.args = list(), na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>numeric vector giving number of bins in both vertical and horizontal directions. Set to 30 by default.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>Numeric vector giving bin width in both vertical and horizontal directions. Overrides <code>bins</code> if both set.</p> </td> </tr> <tr valign='top'> <td><code>drop</code></td> <td> <p>drop if the output of <code>fun</code> is <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>fun</code></td> <td> <p>function for summary.</p> </td> </tr> <tr valign='top'> <td><code>fun.args</code></td> <td> <p>A list of extra arguments to pass to <code>fun</code></p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"stat_summary"	"ggplot2"	"Summarise y values at unique/binned x"	"<p><code>stat_summary</code> operates on unique <code>x</code>; <code>stat_summary_bin</code> operators on binned <code>x</code>. They are more flexible versions of <code>stat_bin</code>: instead of just counting, they can compute any aggregate. </p>"	"<pre>stat_summary_bin(mapping = NULL, data = NULL, geom = 'pointrange',<br />   position = 'identity', ..., fun.data = NULL, fun.y = NULL,<br />   fun.ymax = NULL, fun.ymin = NULL, fun.args = list(), na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE)<br />stat_summary(mapping = NULL, data = NULL, geom = 'pointrange',<br />   position = 'identity', ..., fun.data = NULL, fun.y = NULL,<br />   fun.ymax = NULL, fun.ymin = NULL, fun.args = list(), na.rm = FALSE,<br />   show.legend = NA, inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>Use to override the default connection between <code>geom_histogram</code>/<code>geom_freqpoly</code> and <code>stat_bin</code>.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>fun.data</code></td> <td> <p>A function that is given the complete data and should return a data frame with variables <code>ymin</code>, <code>y</code>, and <code>ymax</code>.</p> </td> </tr> <tr valign='top'> <td><code>fun.ymin, fun.y, fun.ymax</code></td> <td> <p>Alternatively, supply three individual functions that are each passed a vector of x's and should return a single number.</p> </td> </tr> <tr valign='top'> <td><code>fun.args</code></td> <td> <p>Optional additional arguments passed on to the functions.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"stat_summary_2d"	"ggplot2"	"Bin and summarise in 2d (rectangle & hexagons)"	"<p><code>stat_summary_2d</code> is a 2d variation of <code>stat_summary</code>. <code>stat_summary_hex</code> is a hexagonal variation of <code>stat_summary_2d</code>. The data are divided into bins defined by <code>x</code> and <code>y</code>, and then the values of <code>z</code> in each cell is are summarised with <code>fun</code>. </p>"	"<pre>stat_summary_2d(mapping = NULL, data = NULL, geom = 'tile',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, drop = TRUE,<br />   fun = 'mean', fun.args = list(), na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE)<br />stat_summary_hex(mapping = NULL, data = NULL, geom = 'hex',<br />   position = 'identity', ..., bins = 30, binwidth = NULL, drop = TRUE,<br />   fun = 'mean', fun.args = list(), na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>bins</code></td> <td> <p>numeric vector giving number of bins in both vertical and horizontal directions. Set to 30 by default.</p> </td> </tr> <tr valign='top'> <td><code>binwidth</code></td> <td> <p>Numeric vector giving bin width in both vertical and horizontal directions. Overrides <code>bins</code> if both set.</p> </td> </tr> <tr valign='top'> <td><code>drop</code></td> <td> <p>drop if the output of <code>fun</code> is <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>fun</code></td> <td> <p>function for summary.</p> </td> </tr> <tr valign='top'> <td><code>fun.args</code></td> <td> <p>A list of extra arguments to pass to <code>fun</code></p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"stat_unique"	"ggplot2"	"Remove duplicates"	"<p>Remove duplicates </p>"	"<pre>stat_unique(mapping = NULL, data = NULL, geom = 'point',<br />   position = 'identity', ..., na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>geom</code></td> <td> <p>The geometric object to use display the data</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> </table> "	FALSE
"geom_violin"	"ggplot2"	"Violin plot"	"<p>A violin plot is a compact display of a continuous distribution. It is a blend of <code>geom_boxplot</code> and <code>geom_density</code>: a violin plot is a mirrored density plot displayed in the same way as a boxplot. </p>"	"<pre>geom_violin(mapping = NULL, data = NULL, stat = 'ydensity',<br />   position = 'dodge', ..., draw_quantiles = NULL, trim = TRUE,<br />   scale = 'area', na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)<br />stat_ydensity(mapping = NULL, data = NULL, geom = 'violin',<br />   position = 'dodge', ..., bw = 'nrd0', adjust = 1, kernel = 'gaussian',<br />   trim = TRUE, scale = 'area', na.rm = FALSE, show.legend = NA,<br />   inherit.aes = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mapping</code></td> <td> <p>Set of aesthetic mappings created by <code>aes</code> or <code>aes_</code>. If specified and <code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping at the top level of the plot. You must supply <code>mapping</code> if there is no plot mapping.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The data to be displayed in this layer. There are three options: </p> <p>If <code>NULL</code>, the default, the data is inherited from the plot data as specified in the call to <code>ggplot</code>. </p> <p>A <code>data.frame</code>, or other object, will override the plot data. All objects will be fortified to produce a data frame. See <code>fortify</code> for which variables will be created. </p> <p>A <code>function</code> will be called with a single argument, the plot data. The return value must be a <code>data.frame.</code>, and will be used as the layer data.</p> </td> </tr> <tr valign='top'> <td><code>position</code></td> <td> <p>Position adjustment, either as a string, or the result of a call to a position adjustment function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other arguments passed on to <code>layer</code>. These are often aesthetics, used to set an aesthetic to a fixed value, like <code>color = 'red'</code> or <code>size = 3</code>. They may also be parameters to the paired geom/stat.</p> </td> </tr> <tr valign='top'> <td><code>draw_quantiles</code></td> <td> <p>If <code>not(NULL)</code> (default), draw horizontal lines at the given quantiles of the density estimate.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> (default), trim the tails of the violins to the range of the data. If <code>FALSE</code>, don't trim the tails.</p> </td> </tr> <tr valign='top'> <td><code>scale</code></td> <td> <p>if 'area' (default), all violins have the same area (before trimming the tails). If 'count', areas are scaled proportionally to the number of observations. If 'width', all violins have the same maximum width.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>FALSE</code>, the default, missing values are removed with a warning. If <code>TRUE</code>, missing values are silently removed.</p> </td> </tr> <tr valign='top'> <td><code>show.legend</code></td> <td> <p>logical. Should this layer be included in the legends? <code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p> </td> </tr> <tr valign='top'> <td><code>inherit.aes</code></td> <td> <p>If <code>FALSE</code>, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. <code>borders</code>.</p> </td> </tr> <tr valign='top'> <td><code>geom, stat</code></td> <td> <p>Use to override the default connection between <code>geom_violin</code> and <code>stat_ydensity</code>.</p> </td> </tr> <tr valign='top'> <td><code>bw</code></td> <td> <p>The smoothing bandwidth to be used. If numeric, the standard deviation of the smoothing kernel. If character, a rule to choose the bandwidth, as listed in <code>bw.nrd</code>.</p> </td> </tr> <tr valign='top'> <td><code>adjust</code></td> <td> <p>A multiplicate bandwidth adjustment. This makes it possible to adjust the bandwidth while still using the a bandwidth estimator. For exampe, <code>adjust = 1/2</code> means use half of the default bandwidth.</p> </td> </tr> <tr valign='top'> <td><code>kernel</code></td> <td> <p>Kernel. See list of available kernels in <code>density</code>.</p> </td> </tr> </table> "	FALSE
"theme"	"ggplot2"	"Modify components of a theme"	"<p>Use <code>theme()</code> to modify individual components of a theme, allowing you to control the appearance of all non-data components of the plot. <code>theme()</code> only affects a single plot: see <code>theme_update</code> if you want modify the active theme, to affect all subsequent plots. </p>"	"<pre>theme(line, rect, text, title, aspect.ratio, axis.title, axis.title.x,<br />   axis.title.x.top, axis.title.y, axis.title.y.right, axis.text, axis.text.x,<br />   axis.text.x.top, axis.text.y, axis.text.y.right, axis.ticks, axis.ticks.x,<br />   axis.ticks.y, axis.ticks.length, axis.line, axis.line.x, axis.line.y,<br />   legend.background, legend.margin, legend.spacing, legend.spacing.x,<br />   legend.spacing.y, legend.key, legend.key.size, legend.key.height,<br />   legend.key.width, legend.text, legend.text.align, legend.title,<br />   legend.title.align, legend.position, legend.direction, legend.justification,<br />   legend.box, legend.box.just, legend.box.margin, legend.box.background,<br />   legend.box.spacing, panel.background, panel.border, panel.spacing,<br />   panel.spacing.x, panel.spacing.y, panel.grid, panel.grid.major,<br />   panel.grid.minor, panel.grid.major.x, panel.grid.major.y, panel.grid.minor.x,<br />   panel.grid.minor.y, panel.ontop, plot.background, plot.title, plot.subtitle,<br />   plot.caption, plot.margin, strip.background, strip.placement, strip.text,<br />   strip.text.x, strip.text.y, strip.switch.pad.grid, strip.switch.pad.wrap, ...,<br />   complete = FALSE, validate = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>line</code></td> <td> <p>all line elements (<code>element_line</code>)</p> </td> </tr> <tr valign='top'> <td><code>rect</code></td> <td> <p>all rectangular elements (<code>element_rect</code>)</p> </td> </tr> <tr valign='top'> <td><code>text</code></td> <td> <p>all text elements (<code>element_text</code>)</p> </td> </tr> <tr valign='top'> <td><code>title</code></td> <td> <p>all title elements: plot, axes, legends (<code>element_text</code>; inherits from <code>text</code>)</p> </td> </tr> <tr valign='top'> <td><code>aspect.ratio</code></td> <td> <p>aspect ratio of the panel</p> </td> </tr> <tr valign='top'> <td><code>axis.title</code></td> <td> <p>label of axes (<code>element_text</code>; inherits from <code>text</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.title.x</code></td> <td> <p>x axis label (<code>element_text</code>; inherits from <code>axis.title</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.title.x.top</code></td> <td> <p>x axis label on top axis (<code>element_text</code>; inherits from <code>axis.title.x</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.title.y</code></td> <td> <p>y axis label (<code>element_text</code>; inherits from <code>axis.title</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.title.y.right</code></td> <td> <p>y axis label on right axis (<code>element_text</code>; inherits from <code>axis.title.y</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.text</code></td> <td> <p>tick labels along axes (<code>element_text</code>; inherits from <code>text</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.text.x</code></td> <td> <p>x axis tick labels (<code>element_text</code>; inherits from <code>axis.text</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.text.x.top</code></td> <td> <p>x axis tick labels on top axis (<code>element_text</code>; inherits from <code>axis.text.x</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.text.y</code></td> <td> <p>y axis tick labels (<code>element_text</code>; inherits from <code>axis.text</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.text.y.right</code></td> <td> <p>y axis tick labels on right axis (<code>element_text</code>; inherits from <code>axis.text.y</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.ticks</code></td> <td> <p>tick marks along axes (<code>element_line</code>; inherits from <code>line</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.ticks.x</code></td> <td> <p>x axis tick marks (<code>element_line</code>; inherits from <code>axis.ticks</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.ticks.y</code></td> <td> <p>y axis tick marks (<code>element_line</code>; inherits from <code>axis.ticks</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.ticks.length</code></td> <td> <p>length of tick marks (<code>unit</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.line</code></td> <td> <p>lines along axes (<code>element_line</code>; inherits from <code>line</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.line.x</code></td> <td> <p>line along x axis (<code>element_line</code>; inherits from <code>axis.line</code>)</p> </td> </tr> <tr valign='top'> <td><code>axis.line.y</code></td> <td> <p>line along y axis (<code>element_line</code>; inherits from <code>axis.line</code>)</p> </td> </tr> <tr valign='top'> <td><code>legend.background</code></td> <td> <p>background of legend (<code>element_rect</code>; inherits from <code>rect</code>)</p> </td> </tr> <tr valign='top'> <td><code>legend.margin</code></td> <td> <p>the margin around each legend (<code>margin</code>)</p> </td> </tr> <tr valign='top'> <td><code>legend.spacing</code></td> <td> <p>the spacing between legends (<code>unit</code>)</p> </td> </tr> <tr valign='top'> <td><code>legend.spacing.x</code></td> <td> <p>the horizontal spacing between legends (<code>unit</code>); inherits from <code>legend.spacing</code></p> </td> </tr> <tr valign='top'> <td><code>legend.spacing.y</code></td> <td> <p>the horizontal spacing between legends (<code>unit</code>); inherits from <code>legend.spacing</code></p> </td> </tr> <tr valign='top'> <td><code>legend.key</code></td> <td> <p>background underneath legend keys (<code>element_rect</code>; inherits from <code>rect</code>)</p> </td> </tr> <tr valign='top'> <td><code>legend.key.size</code></td> <td> <p>size of legend keys (<code>unit</code>)</p> </td> </tr> <tr valign='top'> <td><code>legend.key.height</code></td> <td> <p>key background height (<code>unit</code>; inherits from <code>legend.key.size</code>)</p> </td> </tr> <tr valign='top'> <td><code>legend.key.width</code></td> <td> <p>key background width (<code>unit</code>; inherits from <code>legend.key.size</code>)</p> </td> </tr> <tr valign='top'> <td><code>legend.text</code></td> <td> <p>legend item labels (<code>element_text</code>; inherits from <code>text</code>)</p> </td> </tr> <tr valign='top'> <td><code>legend.text.align</code></td> <td> <p>alignment of legend labels (number from 0 (left) to 1 (right))</p> </td> </tr> <tr valign='top'> <td><code>legend.title</code></td> <td> <p>title of legend (<code>element_text</code>; inherits from <code>title</code>)</p> </td> </tr> <tr valign='top'> <td><code>legend.title.align</code></td> <td> <p>alignment of legend title (number from 0 (left) to 1 (right))</p> </td> </tr> <tr valign='top'> <td><code>legend.position</code></td> <td> <p>the position of legends ('none', 'left', 'right', 'bottom', 'top', or two-element numeric vector)</p> </td> </tr> <tr valign='top'> <td><code>legend.direction</code></td> <td> <p>layout of items in legends ('horizontal' or 'vertical')</p> </td> </tr> <tr valign='top'> <td><code>legend.justification</code></td> <td> <p>anchor point for positioning legend inside plot ('center' or two-element numeric vector) or the justification according to the plot area when positioned outside the plot</p> </td> </tr> <tr valign='top'> <td><code>legend.box</code></td> <td> <p>arrangement of multiple legends ('horizontal' or 'vertical')</p> </td> </tr> <tr valign='top'> <td><code>legend.box.just</code></td> <td> <p>justification of each legend within the overall bounding box, when there are multiple legends ('top', 'bottom', 'left', or 'right')</p> </td> </tr> <tr valign='top'> <td><code>legend.box.margin</code></td> <td> <p>margins around the full legend area, as specified using <code>margin</code></p> </td> </tr> <tr valign='top'> <td><code>legend.box.background</code></td> <td> <p>background of legend area (<code>element_rect</code>; inherits from <code>rect</code>)</p> </td> </tr> <tr valign='top'> <td><code>legend.box.spacing</code></td> <td> <p>The spacing between the plotting area and the legend box (<code>unit</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.background</code></td> <td> <p>background of plotting area, drawn underneath plot (<code>element_rect</code>; inherits from <code>rect</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.border</code></td> <td> <p>border around plotting area, drawn on top of plot so that it covers tick marks and grid lines. This should be used with <code>fill=NA</code> (<code>element_rect</code>; inherits from <code>rect</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.spacing</code></td> <td> <p>spacing between facet panels (<code>unit</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.spacing.x</code></td> <td> <p>horizontal spacing between facet panels (<code>unit</code>; inherits from <code>panel.spacing</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.spacing.y</code></td> <td> <p>vertical spacing between facet panels (<code>unit</code>; inherits from <code>panel.spacing</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.grid</code></td> <td> <p>grid lines (<code>element_line</code>; inherits from <code>line</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.grid.major</code></td> <td> <p>major grid lines (<code>element_line</code>; inherits from <code>panel.grid</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.grid.minor</code></td> <td> <p>minor grid lines (<code>element_line</code>; inherits from <code>panel.grid</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.grid.major.x</code></td> <td> <p>vertical major grid lines (<code>element_line</code>; inherits from <code>panel.grid.major</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.grid.major.y</code></td> <td> <p>horizontal major grid lines (<code>element_line</code>; inherits from <code>panel.grid.major</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.grid.minor.x</code></td> <td> <p>vertical minor grid lines (<code>element_line</code>; inherits from <code>panel.grid.minor</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.grid.minor.y</code></td> <td> <p>horizontal minor grid lines (<code>element_line</code>; inherits from <code>panel.grid.minor</code>)</p> </td> </tr> <tr valign='top'> <td><code>panel.ontop</code></td> <td> <p>option to place the panel (background, gridlines) over the data layers.  Usually used with a transparent or blank <code>panel.background</code>. (<code>logical</code>)</p> </td> </tr> <tr valign='top'> <td><code>plot.background</code></td> <td> <p>background of the entire plot (<code>element_rect</code>; inherits from <code>rect</code>)</p> </td> </tr> <tr valign='top'> <td><code>plot.title</code></td> <td> <p>plot title (text appearance) (<code>element_text</code>; inherits from <code>title</code>) left-aligned by default</p> </td> </tr> <tr valign='top'> <td><code>plot.subtitle</code></td> <td> <p>plot subtitle (text appearance) (<code>element_text</code>; inherits from <code>title</code>) left-aligned by default</p> </td> </tr> <tr valign='top'> <td><code>plot.caption</code></td> <td> <p>caption below the plot (text appearance) (<code>element_text</code>; inherits from <code>title</code>) right-aligned by default</p> </td> </tr> <tr valign='top'> <td><code>plot.margin</code></td> <td> <p>margin around entire plot (<code>unit</code> with the sizes of the top, right, bottom, and left margins)</p> </td> </tr> <tr valign='top'> <td><code>strip.background</code></td> <td> <p>background of facet labels (<code>element_rect</code>; inherits from <code>rect</code>)</p> </td> </tr> <tr valign='top'> <td><code>strip.placement</code></td> <td> <p>placement of strip with respect to axes, either 'inside' or 'outside'. Only important when axes and strips are on the same side of the plot.</p> </td> </tr> <tr valign='top'> <td><code>strip.text</code></td> <td> <p>facet labels (<code>element_text</code>; inherits from <code>text</code>)</p> </td> </tr> <tr valign='top'> <td><code>strip.text.x</code></td> <td> <p>facet labels along horizontal direction (<code>element_text</code>; inherits from <code>strip.text</code>)</p> </td> </tr> <tr valign='top'> <td><code>strip.text.y</code></td> <td> <p>facet labels along vertical direction (<code>element_text</code>; inherits from <code>strip.text</code>)</p> </td> </tr> <tr valign='top'> <td><code>strip.switch.pad.grid</code></td> <td> <p>space between strips and axes when strips are switched (<code>unit</code>)</p> </td> </tr> <tr valign='top'> <td><code>strip.switch.pad.wrap</code></td> <td> <p>space between strips and axes when strips are switched (<code>unit</code>)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional element specifications not part of base ggplot2. If supplied <code>validate</code> needs to be set to <code>FALSE</code>.</p> </td> </tr> <tr valign='top'> <td><code>complete</code></td> <td> <p>set this to TRUE if this is a complete theme, such as the one returned <code>by theme_grey()</code>. Complete themes behave differently when added to a ggplot object. Also, when setting <code>complete = TRUE</code> all elements will be set to inherit from blank elements.</p> </td> </tr> <tr valign='top'> <td><code>validate</code></td> <td> <p><code>TRUE</code> to run validate_element, <code>FALSE</code> to bypass checks.</p> </td> </tr> </table> "	FALSE
"ggtheme"	"ggplot2"	"Complete themes"	"<p>These are complete themes which control all non-data display. Use <code>theme</code> if you just need to tweak the display of an existing theme. </p>"	"<pre>theme_grey(base_size = 11, base_family = '')<br />theme_gray(base_size = 11, base_family = '')<br />theme_bw(base_size = 11, base_family = '')<br />theme_linedraw(base_size = 11, base_family = '')<br />theme_light(base_size = 11, base_family = '')<br />theme_dark(base_size = 11, base_family = '')<br />theme_minimal(base_size = 11, base_family = '')<br />theme_classic(base_size = 11, base_family = '')<br />theme_void(base_size = 11, base_family = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>base_size</code></td> <td> <p>base font size</p> </td> </tr> <tr valign='top'> <td><code>base_family</code></td> <td> <p>base font family</p> </td> </tr> </table> "	FALSE
"ggtheme"	"ggplot2"	"Complete themes"	"<p>These are complete themes which control all non-data display. Use <code>theme</code> if you just need to tweak the display of an existing theme. </p>"	"<pre>theme_grey(base_size = 11, base_family = '')<br />theme_gray(base_size = 11, base_family = '')<br />theme_bw(base_size = 11, base_family = '')<br />theme_linedraw(base_size = 11, base_family = '')<br />theme_light(base_size = 11, base_family = '')<br />theme_dark(base_size = 11, base_family = '')<br />theme_minimal(base_size = 11, base_family = '')<br />theme_classic(base_size = 11, base_family = '')<br />theme_void(base_size = 11, base_family = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>base_size</code></td> <td> <p>base font size</p> </td> </tr> <tr valign='top'> <td><code>base_family</code></td> <td> <p>base font family</p> </td> </tr> </table> "	FALSE
"ggtheme"	"ggplot2"	"Complete themes"	"<p>These are complete themes which control all non-data display. Use <code>theme</code> if you just need to tweak the display of an existing theme. </p>"	"<pre>theme_grey(base_size = 11, base_family = '')<br />theme_gray(base_size = 11, base_family = '')<br />theme_bw(base_size = 11, base_family = '')<br />theme_linedraw(base_size = 11, base_family = '')<br />theme_light(base_size = 11, base_family = '')<br />theme_dark(base_size = 11, base_family = '')<br />theme_minimal(base_size = 11, base_family = '')<br />theme_classic(base_size = 11, base_family = '')<br />theme_void(base_size = 11, base_family = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>base_size</code></td> <td> <p>base font size</p> </td> </tr> <tr valign='top'> <td><code>base_family</code></td> <td> <p>base font family</p> </td> </tr> </table> "	FALSE
"theme_get"	"ggplot2"	"Get, set, and modify the active theme"	"<p>The current/active theme is automatically applied to every plot you draw. Use <code>theme_get</code> to get the current theme, and <code>theme_set</code> to completely override it. <code>theme_update</code> and <code>theme_replace</code> are shorthands for changing individual elements. </p>"	"<pre>theme_get()<br />theme_set(new)<br />theme_update(...)<br />theme_replace(...)<br />e1 %+replace% e2 </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>new</code></td> <td> <p>new theme (a list of theme elements)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>named list of theme settings</p> </td> </tr> <tr valign='top'> <td><code>e1, e2</code></td> <td> <p>Theme and element to combine</p> </td> </tr> </table> "	FALSE
"ggtheme"	"ggplot2"	"Complete themes"	"<p>These are complete themes which control all non-data display. Use <code>theme</code> if you just need to tweak the display of an existing theme. </p>"	"<pre>theme_grey(base_size = 11, base_family = '')<br />theme_gray(base_size = 11, base_family = '')<br />theme_bw(base_size = 11, base_family = '')<br />theme_linedraw(base_size = 11, base_family = '')<br />theme_light(base_size = 11, base_family = '')<br />theme_dark(base_size = 11, base_family = '')<br />theme_minimal(base_size = 11, base_family = '')<br />theme_classic(base_size = 11, base_family = '')<br />theme_void(base_size = 11, base_family = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>base_size</code></td> <td> <p>base font size</p> </td> </tr> <tr valign='top'> <td><code>base_family</code></td> <td> <p>base font family</p> </td> </tr> </table> "	FALSE
"ggtheme"	"ggplot2"	"Complete themes"	"<p>These are complete themes which control all non-data display. Use <code>theme</code> if you just need to tweak the display of an existing theme. </p>"	"<pre>theme_grey(base_size = 11, base_family = '')<br />theme_gray(base_size = 11, base_family = '')<br />theme_bw(base_size = 11, base_family = '')<br />theme_linedraw(base_size = 11, base_family = '')<br />theme_light(base_size = 11, base_family = '')<br />theme_dark(base_size = 11, base_family = '')<br />theme_minimal(base_size = 11, base_family = '')<br />theme_classic(base_size = 11, base_family = '')<br />theme_void(base_size = 11, base_family = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>base_size</code></td> <td> <p>base font size</p> </td> </tr> <tr valign='top'> <td><code>base_family</code></td> <td> <p>base font family</p> </td> </tr> </table> "	FALSE
"ggtheme"	"ggplot2"	"Complete themes"	"<p>These are complete themes which control all non-data display. Use <code>theme</code> if you just need to tweak the display of an existing theme. </p>"	"<pre>theme_grey(base_size = 11, base_family = '')<br />theme_gray(base_size = 11, base_family = '')<br />theme_bw(base_size = 11, base_family = '')<br />theme_linedraw(base_size = 11, base_family = '')<br />theme_light(base_size = 11, base_family = '')<br />theme_dark(base_size = 11, base_family = '')<br />theme_minimal(base_size = 11, base_family = '')<br />theme_classic(base_size = 11, base_family = '')<br />theme_void(base_size = 11, base_family = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>base_size</code></td> <td> <p>base font size</p> </td> </tr> <tr valign='top'> <td><code>base_family</code></td> <td> <p>base font family</p> </td> </tr> </table> "	FALSE
"ggtheme"	"ggplot2"	"Complete themes"	"<p>These are complete themes which control all non-data display. Use <code>theme</code> if you just need to tweak the display of an existing theme. </p>"	"<pre>theme_grey(base_size = 11, base_family = '')<br />theme_gray(base_size = 11, base_family = '')<br />theme_bw(base_size = 11, base_family = '')<br />theme_linedraw(base_size = 11, base_family = '')<br />theme_light(base_size = 11, base_family = '')<br />theme_dark(base_size = 11, base_family = '')<br />theme_minimal(base_size = 11, base_family = '')<br />theme_classic(base_size = 11, base_family = '')<br />theme_void(base_size = 11, base_family = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>base_size</code></td> <td> <p>base font size</p> </td> </tr> <tr valign='top'> <td><code>base_family</code></td> <td> <p>base font family</p> </td> </tr> </table> "	FALSE
"ggtheme"	"ggplot2"	"Complete themes"	"<p>These are complete themes which control all non-data display. Use <code>theme</code> if you just need to tweak the display of an existing theme. </p>"	"<pre>theme_grey(base_size = 11, base_family = '')<br />theme_gray(base_size = 11, base_family = '')<br />theme_bw(base_size = 11, base_family = '')<br />theme_linedraw(base_size = 11, base_family = '')<br />theme_light(base_size = 11, base_family = '')<br />theme_dark(base_size = 11, base_family = '')<br />theme_minimal(base_size = 11, base_family = '')<br />theme_classic(base_size = 11, base_family = '')<br />theme_void(base_size = 11, base_family = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>base_size</code></td> <td> <p>base font size</p> </td> </tr> <tr valign='top'> <td><code>base_family</code></td> <td> <p>base font family</p> </td> </tr> </table> "	FALSE
"theme_get"	"ggplot2"	"Get, set, and modify the active theme"	"<p>The current/active theme is automatically applied to every plot you draw. Use <code>theme_get</code> to get the current theme, and <code>theme_set</code> to completely override it. <code>theme_update</code> and <code>theme_replace</code> are shorthands for changing individual elements. </p>"	"<pre>theme_get()<br />theme_set(new)<br />theme_update(...)<br />theme_replace(...)<br />e1 %+replace% e2 </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>new</code></td> <td> <p>new theme (a list of theme elements)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>named list of theme settings</p> </td> </tr> <tr valign='top'> <td><code>e1, e2</code></td> <td> <p>Theme and element to combine</p> </td> </tr> </table> "	FALSE
"theme_get"	"ggplot2"	"Get, set, and modify the active theme"	"<p>The current/active theme is automatically applied to every plot you draw. Use <code>theme_get</code> to get the current theme, and <code>theme_set</code> to completely override it. <code>theme_update</code> and <code>theme_replace</code> are shorthands for changing individual elements. </p>"	"<pre>theme_get()<br />theme_set(new)<br />theme_update(...)<br />theme_replace(...)<br />e1 %+replace% e2 </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>new</code></td> <td> <p>new theme (a list of theme elements)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>named list of theme settings</p> </td> </tr> <tr valign='top'> <td><code>e1, e2</code></td> <td> <p>Theme and element to combine</p> </td> </tr> </table> "	FALSE
"theme_get"	"ggplot2"	"Get, set, and modify the active theme"	"<p>The current/active theme is automatically applied to every plot you draw. Use <code>theme_get</code> to get the current theme, and <code>theme_set</code> to completely override it. <code>theme_update</code> and <code>theme_replace</code> are shorthands for changing individual elements. </p>"	"<pre>theme_get()<br />theme_set(new)<br />theme_update(...)<br />theme_replace(...)<br />e1 %+replace% e2 </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>new</code></td> <td> <p>new theme (a list of theme elements)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>named list of theme settings</p> </td> </tr> <tr valign='top'> <td><code>e1, e2</code></td> <td> <p>Theme and element to combine</p> </td> </tr> </table> "	FALSE
"ggtheme"	"ggplot2"	"Complete themes"	"<p>These are complete themes which control all non-data display. Use <code>theme</code> if you just need to tweak the display of an existing theme. </p>"	"<pre>theme_grey(base_size = 11, base_family = '')<br />theme_gray(base_size = 11, base_family = '')<br />theme_bw(base_size = 11, base_family = '')<br />theme_linedraw(base_size = 11, base_family = '')<br />theme_light(base_size = 11, base_family = '')<br />theme_dark(base_size = 11, base_family = '')<br />theme_minimal(base_size = 11, base_family = '')<br />theme_classic(base_size = 11, base_family = '')<br />theme_void(base_size = 11, base_family = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>base_size</code></td> <td> <p>base font size</p> </td> </tr> <tr valign='top'> <td><code>base_family</code></td> <td> <p>base font family</p> </td> </tr> </table> "	FALSE
"txhousing"	"ggplot2"	"Housing sales in TX"	"<p>Information about the housing market in Texas provided by the TAMU real estate center, <a href='http://recenter.tamu.edu/'>http://recenter.tamu.edu/</a>. </p>"	"<pre>txhousing </pre>"	NA	FALSE
"aes_position"	"ggplot2"	"Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend"	"<p>This page demonstrates the usage of a sub-group of aesthetics; x, y, xmin, xmax, ymin, ymax, xend, and yend. </p>"	NA	NA	FALSE
"aes_position"	"ggplot2"	"Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend"	"<p>This page demonstrates the usage of a sub-group of aesthetics; x, y, xmin, xmax, ymin, ymax, xend, and yend. </p>"	NA	NA	FALSE
"labs"	"ggplot2"	"Modify axis, legend, and plot labels"	"<p>Good labels are critical for making your plots accessible to a wider audience. Ensure the axis and legend labels display the full variable name. Use the plot <code>title</code> and <code>subtitle</code> to explain the main findings. It's common to use the <code>caption</code> to provide information about the data source. </p>"	"<pre>labs(...)<br />xlab(label)<br />ylab(label)<br />ggtitle(label, subtitle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A list of new name-value pairs. The name should either be an aesthetic, or one of 'title', 'subtitle', or 'caption'.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>The text for the axis, plot title or caption below the plot.</p> </td> </tr> <tr valign='top'> <td><code>subtitle</code></td> <td> <p>the text for the subtitle for the plot which will be displayed below the title. Leave <code>NULL</code> for no subtitle.</p> </td> </tr> </table> "	FALSE
"lims"	"ggplot2"	"Set scale limits"	"<p>This is a shortcut for supplying the <code>limits</code> argument to the individual scales. Note that, by default, any values outside the limits will be replaced with <code>NA</code>. </p>"	"<pre>lims(...)<br />xlim(...)<br />ylim(...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>...</code></td> <td> <p>A name-value pair. The name must be an aesthetic, and the value must be either a length-2 numeric, a character, a factor, or a date/time. </p> <p>A numeric value will create a continuous scale. If the larger value comes first, the scale will be reversed. You can leave one value as <code>NA</code> to compute from the range of the data. </p> <p>A character or factor value will create a discrete scale. </p> <p>A date-time value will create a continuous date/time scale.</p> </td> </tr></table> "	FALSE
"aes_position"	"ggplot2"	"Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend"	"<p>This page demonstrates the usage of a sub-group of aesthetics; x, y, xmin, xmax, ymin, ymax, xend, and yend. </p>"	NA	NA	FALSE
"aes_position"	"ggplot2"	"Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend"	"<p>This page demonstrates the usage of a sub-group of aesthetics; x, y, xmin, xmax, ymin, ymax, xend, and yend. </p>"	NA	NA	FALSE
"aes_position"	"ggplot2"	"Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend"	"<p>This page demonstrates the usage of a sub-group of aesthetics; x, y, xmin, xmax, ymin, ymax, xend, and yend. </p>"	NA	NA	FALSE
"aes_position"	"ggplot2"	"Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend"	"<p>This page demonstrates the usage of a sub-group of aesthetics; x, y, xmin, xmax, ymin, ymax, xend, and yend. </p>"	NA	NA	FALSE
"labs"	"ggplot2"	"Modify axis, legend, and plot labels"	"<p>Good labels are critical for making your plots accessible to a wider audience. Ensure the axis and legend labels display the full variable name. Use the plot <code>title</code> and <code>subtitle</code> to explain the main findings. It's common to use the <code>caption</code> to provide information about the data source. </p>"	"<pre>labs(...)<br />xlab(label)<br />ylab(label)<br />ggtitle(label, subtitle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A list of new name-value pairs. The name should either be an aesthetic, or one of 'title', 'subtitle', or 'caption'.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>The text for the axis, plot title or caption below the plot.</p> </td> </tr> <tr valign='top'> <td><code>subtitle</code></td> <td> <p>the text for the subtitle for the plot which will be displayed below the title. Leave <code>NULL</code> for no subtitle.</p> </td> </tr> </table> "	FALSE
"lims"	"ggplot2"	"Set scale limits"	"<p>This is a shortcut for supplying the <code>limits</code> argument to the individual scales. Note that, by default, any values outside the limits will be replaced with <code>NA</code>. </p>"	"<pre>lims(...)<br />xlim(...)<br />ylim(...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>...</code></td> <td> <p>A name-value pair. The name must be an aesthetic, and the value must be either a length-2 numeric, a character, a factor, or a date/time. </p> <p>A numeric value will create a continuous scale. If the larger value comes first, the scale will be reversed. You can leave one value as <code>NA</code> to compute from the range of the data. </p> <p>A character or factor value will create a discrete scale. </p> <p>A date-time value will create a continuous date/time scale.</p> </td> </tr></table> "	FALSE
"aes_position"	"ggplot2"	"Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend"	"<p>This page demonstrates the usage of a sub-group of aesthetics; x, y, xmin, xmax, ymin, ymax, xend, and yend. </p>"	NA	NA	FALSE
"aes_position"	"ggplot2"	"Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend"	"<p>This page demonstrates the usage of a sub-group of aesthetics; x, y, xmin, xmax, ymin, ymax, xend, and yend. </p>"	NA	NA	FALSE
"gg-add"	"ggplot2"	"Add components to a plot"	"<p><code>+</code> is the key to constructing sophisticated ggplot2 graphics. It allows you to start simple, then get more and more complex, checking your work at each step. </p>"	"<pre>## S3 method for class 'gg' e1 + e2<br />e1 %+% e2 </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>e1</code></td> <td> <p>An object of class <code>ggplot</code> or a <code>theme</code>.</p> </td> </tr> <tr valign='top'> <td><code>e2</code></td> <td> <p>A plot component, as described below.</p> </td> </tr> </table> "	FALSE
"theme_get"	"ggplot2"	"Get, set, and modify the active theme"	"<p>The current/active theme is automatically applied to every plot you draw. Use <code>theme_get</code> to get the current theme, and <code>theme_set</code> to completely override it. <code>theme_update</code> and <code>theme_replace</code> are shorthands for changing individual elements. </p>"	"<pre>theme_get()<br />theme_set(new)<br />theme_update(...)<br />theme_replace(...)<br />e1 %+replace% e2 </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>new</code></td> <td> <p>new theme (a list of theme elements)</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>named list of theme settings</p> </td> </tr> <tr valign='top'> <td><code>e1, e2</code></td> <td> <p>Theme and element to combine</p> </td> </tr> </table> "	FALSE
"gg-add"	"ggplot2"	"Add components to a plot"	"<p><code>+</code> is the key to constructing sophisticated ggplot2 graphics. It allows you to start simple, then get more and more complex, checking your work at each step. </p>"	"<pre>## S3 method for class 'gg' e1 + e2<br />e1 %+% e2 </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>e1</code></td> <td> <p>An object of class <code>ggplot</code> or a <code>theme</code>.</p> </td> </tr> <tr valign='top'> <td><code>e2</code></td> <td> <p>A plot component, as described below.</p> </td> </tr> </table> "	FALSE
"as_factor"	"haven"	"Convert input to a factor."	"<p>The base function <code>as.factor()</code> is not a generic, but this variant is. Methods are provided for factors, character vectors, labelled vectors, and data frames. By default, when applied to a data frame, it only affects <code>labelled</code> columns. </p>"	"<pre>as_factor(x, ...)<br />## S3 method for class 'factor' as_factor(x, ...)<br />## S3 method for class 'character' as_factor(x, ...)<br />## S3 method for class 'data.frame' as_factor(x, ..., only_labelled = TRUE)<br />## S3 method for class 'labelled' as_factor(x, levels = c('default', 'labels', 'values',<br />   'both'), ordered = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to coerce to a factor.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed down to method.</p> </td> </tr> <tr valign='top'> <td><code>only_labelled</code></td> <td> <p>Only apply to labelled columns?</p> </td> </tr> <tr valign='top'> <td><code>levels</code></td> <td> <p>How to create the levels of the generated factor: </p><br /><ul> <li> <p> 'default': uses labels where available, otherwise the values. Labels are sorted by value. </p> </li> <li> <p> 'both': like 'default', but pastes together the level and value </p> </li> <li> <p> 'label': use only the labels; unlabelled values become <code>NA</code> </p> </li> <li> <p> 'values: use only the values </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>ordered</code></td> <td> <p>If <code>TRUE</code> create an ordered (ordinal) factor, if <code>FALSE</code> (the default) create a regular (nominal) factor.</p> </td> </tr> </table> "	FALSE
"as_factor"	"haven"	"Convert input to a factor."	"<p>The base function <code>as.factor()</code> is not a generic, but this variant is. Methods are provided for factors, character vectors, labelled vectors, and data frames. By default, when applied to a data frame, it only affects <code>labelled</code> columns. </p>"	"<pre>as_factor(x, ...)<br />## S3 method for class 'factor' as_factor(x, ...)<br />## S3 method for class 'character' as_factor(x, ...)<br />## S3 method for class 'data.frame' as_factor(x, ..., only_labelled = TRUE)<br />## S3 method for class 'labelled' as_factor(x, levels = c('default', 'labels', 'values',<br />   'both'), ordered = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to coerce to a factor.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed down to method.</p> </td> </tr> <tr valign='top'> <td><code>only_labelled</code></td> <td> <p>Only apply to labelled columns?</p> </td> </tr> <tr valign='top'> <td><code>levels</code></td> <td> <p>How to create the levels of the generated factor: </p><br /><ul> <li> <p> 'default': uses labels where available, otherwise the values. Labels are sorted by value. </p> </li> <li> <p> 'both': like 'default', but pastes together the level and value </p> </li> <li> <p> 'label': use only the labels; unlabelled values become <code>NA</code> </p> </li> <li> <p> 'values: use only the values </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>ordered</code></td> <td> <p>If <code>TRUE</code> create an ordered (ordinal) factor, if <code>FALSE</code> (the default) create a regular (nominal) factor.</p> </td> </tr> </table> "	FALSE
"as_factor"	"haven"	"Convert input to a factor."	"<p>The base function <code>as.factor()</code> is not a generic, but this variant is. Methods are provided for factors, character vectors, labelled vectors, and data frames. By default, when applied to a data frame, it only affects <code>labelled</code> columns. </p>"	"<pre>as_factor(x, ...)<br />## S3 method for class 'factor' as_factor(x, ...)<br />## S3 method for class 'character' as_factor(x, ...)<br />## S3 method for class 'data.frame' as_factor(x, ..., only_labelled = TRUE)<br />## S3 method for class 'labelled' as_factor(x, levels = c('default', 'labels', 'values',<br />   'both'), ordered = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to coerce to a factor.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed down to method.</p> </td> </tr> <tr valign='top'> <td><code>only_labelled</code></td> <td> <p>Only apply to labelled columns?</p> </td> </tr> <tr valign='top'> <td><code>levels</code></td> <td> <p>How to create the levels of the generated factor: </p><br /><ul> <li> <p> 'default': uses labels where available, otherwise the values. Labels are sorted by value. </p> </li> <li> <p> 'both': like 'default', but pastes together the level and value </p> </li> <li> <p> 'label': use only the labels; unlabelled values become <code>NA</code> </p> </li> <li> <p> 'values: use only the values </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>ordered</code></td> <td> <p>If <code>TRUE</code> create an ordered (ordinal) factor, if <code>FALSE</code> (the default) create a regular (nominal) factor.</p> </td> </tr> </table> "	FALSE
"as_factor"	"haven"	"Convert input to a factor."	"<p>The base function <code>as.factor()</code> is not a generic, but this variant is. Methods are provided for factors, character vectors, labelled vectors, and data frames. By default, when applied to a data frame, it only affects <code>labelled</code> columns. </p>"	"<pre>as_factor(x, ...)<br />## S3 method for class 'factor' as_factor(x, ...)<br />## S3 method for class 'character' as_factor(x, ...)<br />## S3 method for class 'data.frame' as_factor(x, ..., only_labelled = TRUE)<br />## S3 method for class 'labelled' as_factor(x, levels = c('default', 'labels', 'values',<br />   'both'), ordered = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to coerce to a factor.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed down to method.</p> </td> </tr> <tr valign='top'> <td><code>only_labelled</code></td> <td> <p>Only apply to labelled columns?</p> </td> </tr> <tr valign='top'> <td><code>levels</code></td> <td> <p>How to create the levels of the generated factor: </p><br /><ul> <li> <p> 'default': uses labels where available, otherwise the values. Labels are sorted by value. </p> </li> <li> <p> 'both': like 'default', but pastes together the level and value </p> </li> <li> <p> 'label': use only the labels; unlabelled values become <code>NA</code> </p> </li> <li> <p> 'values: use only the values </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>ordered</code></td> <td> <p>If <code>TRUE</code> create an ordered (ordinal) factor, if <code>FALSE</code> (the default) create a regular (nominal) factor.</p> </td> </tr> </table> "	FALSE
"as_factor"	"haven"	"Convert input to a factor."	"<p>The base function <code>as.factor()</code> is not a generic, but this variant is. Methods are provided for factors, character vectors, labelled vectors, and data frames. By default, when applied to a data frame, it only affects <code>labelled</code> columns. </p>"	"<pre>as_factor(x, ...)<br />## S3 method for class 'factor' as_factor(x, ...)<br />## S3 method for class 'character' as_factor(x, ...)<br />## S3 method for class 'data.frame' as_factor(x, ..., only_labelled = TRUE)<br />## S3 method for class 'labelled' as_factor(x, levels = c('default', 'labels', 'values',<br />   'both'), ordered = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to coerce to a factor.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed down to method.</p> </td> </tr> <tr valign='top'> <td><code>only_labelled</code></td> <td> <p>Only apply to labelled columns?</p> </td> </tr> <tr valign='top'> <td><code>levels</code></td> <td> <p>How to create the levels of the generated factor: </p><br /><ul> <li> <p> 'default': uses labels where available, otherwise the values. Labels are sorted by value. </p> </li> <li> <p> 'both': like 'default', but pastes together the level and value </p> </li> <li> <p> 'label': use only the labels; unlabelled values become <code>NA</code> </p> </li> <li> <p> 'values: use only the values </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>ordered</code></td> <td> <p>If <code>TRUE</code> create an ordered (ordinal) factor, if <code>FALSE</code> (the default) create a regular (nominal) factor.</p> </td> </tr> </table> "	FALSE
"tagged_na"	"haven"	"\"Tagged\" missing values"	"<p>'Tagged' missing values work exactly like regular R missing values except that they store one additional byte of information a tag, which is usually a letter ('a' to 'z'). When by loading a SAS and Stata file, the tagged missing values always use lower case values. </p>"	"<pre>tagged_na(...)<br />na_tag(x)<br />is_tagged_na(x, tag = NULL)<br />format_tagged_na(x, digits = getOption('digits'))<br />print_tagged_na(x, digits = getOption('digits')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Vectors containing single character. The letter will be used to 'tag' the missing value.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A numeric vector</p> </td> </tr> <tr valign='top'> <td><code>tag</code></td> <td> <p>If <code>NULL</code>, will only return true if the tag has this value.</p> </td> </tr> <tr valign='top'> <td><code>digits</code></td> <td> <p>Number of digits to use in string representation</p> </td> </tr> </table> "	FALSE
"labelled"	"haven"	"Create a labelled vector."	"<p>A labelled vector is a common data structure in other statistical environments, allowing you to assign text labels to specific values. This class makes it possible to import such labelled vectors in to R without loss of fidelity. This class provides few methods, as I expect you'll coerce to a standard R class (e.g. a <code>factor</code>) soon after importing. </p>"	"<pre>labelled(x, labels)<br />is.labelled(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A vector to label. Must be either numeric (integer or double) or character.</p> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>A named vector. The vector should be the same type as <code>x</code>. Unlike factors, labels don't need to be exhaustive: only a fraction of the values might be labelled.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Ignored</p> </td> </tr> </table> "	FALSE
"tagged_na"	"haven"	"\"Tagged\" missing values"	"<p>'Tagged' missing values work exactly like regular R missing values except that they store one additional byte of information a tag, which is usually a letter ('a' to 'z'). When by loading a SAS and Stata file, the tagged missing values always use lower case values. </p>"	"<pre>tagged_na(...)<br />na_tag(x)<br />is_tagged_na(x, tag = NULL)<br />format_tagged_na(x, digits = getOption('digits'))<br />print_tagged_na(x, digits = getOption('digits')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Vectors containing single character. The letter will be used to 'tag' the missing value.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A numeric vector</p> </td> </tr> <tr valign='top'> <td><code>tag</code></td> <td> <p>If <code>NULL</code>, will only return true if the tag has this value.</p> </td> </tr> <tr valign='top'> <td><code>digits</code></td> <td> <p>Number of digits to use in string representation</p> </td> </tr> </table> "	FALSE
"labelled"	"haven"	"Create a labelled vector."	"<p>A labelled vector is a common data structure in other statistical environments, allowing you to assign text labels to specific values. This class makes it possible to import such labelled vectors in to R without loss of fidelity. This class provides few methods, as I expect you'll coerce to a standard R class (e.g. a <code>factor</code>) soon after importing. </p>"	"<pre>labelled(x, labels)<br />is.labelled(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A vector to label. Must be either numeric (integer or double) or character.</p> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>A named vector. The vector should be the same type as <code>x</code>. Unlike factors, labels don't need to be exhaustive: only a fraction of the values might be labelled.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Ignored</p> </td> </tr> </table> "	FALSE
"labelled_spss"	"haven"	"Labelled vectors for SPSS"	"<p>This class is only used when <code>user_na = TRUE</code> in <code>read_sav()</code>. It is similar to the <code>labelled</code> class but it also models SPSS's user-defined missings, which can be up to three distinct values, or for numeric vectors a range. </p>"	"<pre>labelled_spss(x, labels, na_values = NULL, na_range = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A vector to label. Must be either numeric (integer or double) or character.</p> </td> </tr> <tr valign='top'> <td><code>labels</code></td> <td> <p>A named vector. The vector should be the same type as <code>x</code>. Unlike factors, labels don't need to be exhaustive: only a fraction of the values might be labelled.</p> </td> </tr> <tr valign='top'> <td><code>na_values</code></td> <td> <p>A vector of values that should also be considered as missing.</p> </td> </tr> <tr valign='top'> <td><code>na_range</code></td> <td> <p>A numeric vector of length two giving the (inclusive) extents of the range. Use <code>-Inf</code> and <code>Inf</code> if you want the range to be open ended.</p> </td> </tr> </table> "	FALSE
"tagged_na"	"haven"	"\"Tagged\" missing values"	"<p>'Tagged' missing values work exactly like regular R missing values except that they store one additional byte of information a tag, which is usually a letter ('a' to 'z'). When by loading a SAS and Stata file, the tagged missing values always use lower case values. </p>"	"<pre>tagged_na(...)<br />na_tag(x)<br />is_tagged_na(x, tag = NULL)<br />format_tagged_na(x, digits = getOption('digits'))<br />print_tagged_na(x, digits = getOption('digits')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Vectors containing single character. The letter will be used to 'tag' the missing value.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A numeric vector</p> </td> </tr> <tr valign='top'> <td><code>tag</code></td> <td> <p>If <code>NULL</code>, will only return true if the tag has this value.</p> </td> </tr> <tr valign='top'> <td><code>digits</code></td> <td> <p>Number of digits to use in string representation</p> </td> </tr> </table> "	FALSE
"print_labels"	"haven"	"Print the labels of a labelled vector"	"<p>This is a convenience function, useful to explore the variables of a newly imported dataset. </p>"	"<pre>print_labels(x, name = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A labelled vector</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the vector (optional)</p> </td> </tr> </table> "	FALSE
"tagged_na"	"haven"	"\"Tagged\" missing values"	"<p>'Tagged' missing values work exactly like regular R missing values except that they store one additional byte of information a tag, which is usually a letter ('a' to 'z'). When by loading a SAS and Stata file, the tagged missing values always use lower case values. </p>"	"<pre>tagged_na(...)<br />na_tag(x)<br />is_tagged_na(x, tag = NULL)<br />format_tagged_na(x, digits = getOption('digits'))<br />print_tagged_na(x, digits = getOption('digits')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Vectors containing single character. The letter will be used to 'tag' the missing value.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A numeric vector</p> </td> </tr> <tr valign='top'> <td><code>tag</code></td> <td> <p>If <code>NULL</code>, will only return true if the tag has this value.</p> </td> </tr> <tr valign='top'> <td><code>digits</code></td> <td> <p>Number of digits to use in string representation</p> </td> </tr> </table> "	FALSE
"read_dta"	"haven"	"Read and write Stata DTA files."	"<p>Currently haven can read and write logical, integer, numeric, character and factors. See <code>labelled</code> for how labelled variables in Stata are handled in R. </p>"	"<pre>read_dta(file, encoding = NULL)<br />read_stata(file, encoding = NULL)<br />write_dta(data, path, version = 14) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>The character encoding used for the file. This defaults to the encoding specified in the file, or UTF-8. But older versions of Stata (13 and earlier) did not store the encoding used, and you'll need to specify manually. A commonly used value is 'Win 1252'.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Data frame to write.</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to a file where the data will be written.</p> </td> </tr> <tr valign='top'> <td><code>version</code></td> <td> <p>File version to use. Supports versions 8-14.</p> </td> </tr> </table> "	FALSE
"read_spss"	"haven"	"Read SPSS (SAV & POR) files. Write SAV files."	"<p>Currently haven can read and write logical, integer, numeric, character and factors. See <code>labelled_spss</code> for how labelled variables in Stata are handled in R. <code>read_spss</code> is an alias for <code>read_sav</code>. </p>"	"<pre>read_sav(file, user_na = FALSE)<br />read_por(file, user_na = FALSE)<br />write_sav(data, path)<br />read_spss(file, user_na = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>user_na</code></td> <td> <p>If <code>TRUE</code> variables with user defined missing will be read into <code>labelled_spss</code> objects. If <code>FALSE</code>, the default, user-defined missings will be converted to <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Data frame to write.</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to a file where the data will be written.</p> </td> </tr> </table> "	FALSE
"read_sas"	"haven"	"Read and write SAS files."	"<p>Reading supports both sas7bdat files and the accompanying sas7bdat files that SAS uses to record value labels. Writing value labels is not currently supported. </p>"	"<pre>read_sas(data_file, catalog_file = NULL, encoding = NULL)<br />write_sas(data, path) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data_file, catalog_file</code></td> <td> <p>Path to data and catalog files. The files are processed with <code>datasource()</code>.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>The character encoding used for the file. This defaults to the encoding specified in the file, or UTF-8. You can use this argument to override the value stored in the file if it is correct</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Data frame to write.</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to file where the data will be written.</p> </td> </tr> </table> "	FALSE
"read_spss"	"haven"	"Read SPSS (SAV & POR) files. Write SAV files."	"<p>Currently haven can read and write logical, integer, numeric, character and factors. See <code>labelled_spss</code> for how labelled variables in Stata are handled in R. <code>read_spss</code> is an alias for <code>read_sav</code>. </p>"	"<pre>read_sav(file, user_na = FALSE)<br />read_por(file, user_na = FALSE)<br />write_sav(data, path)<br />read_spss(file, user_na = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>user_na</code></td> <td> <p>If <code>TRUE</code> variables with user defined missing will be read into <code>labelled_spss</code> objects. If <code>FALSE</code>, the default, user-defined missings will be converted to <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Data frame to write.</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to a file where the data will be written.</p> </td> </tr> </table> "	FALSE
"read_spss"	"haven"	"Read SPSS (SAV & POR) files. Write SAV files."	"<p>Currently haven can read and write logical, integer, numeric, character and factors. See <code>labelled_spss</code> for how labelled variables in Stata are handled in R. <code>read_spss</code> is an alias for <code>read_sav</code>. </p>"	"<pre>read_sav(file, user_na = FALSE)<br />read_por(file, user_na = FALSE)<br />write_sav(data, path)<br />read_spss(file, user_na = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>user_na</code></td> <td> <p>If <code>TRUE</code> variables with user defined missing will be read into <code>labelled_spss</code> objects. If <code>FALSE</code>, the default, user-defined missings will be converted to <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Data frame to write.</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to a file where the data will be written.</p> </td> </tr> </table> "	FALSE
"read_dta"	"haven"	"Read and write Stata DTA files."	"<p>Currently haven can read and write logical, integer, numeric, character and factors. See <code>labelled</code> for how labelled variables in Stata are handled in R. </p>"	"<pre>read_dta(file, encoding = NULL)<br />read_stata(file, encoding = NULL)<br />write_dta(data, path, version = 14) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>The character encoding used for the file. This defaults to the encoding specified in the file, or UTF-8. But older versions of Stata (13 and earlier) did not store the encoding used, and you'll need to specify manually. A commonly used value is 'Win 1252'.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Data frame to write.</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to a file where the data will be written.</p> </td> </tr> <tr valign='top'> <td><code>version</code></td> <td> <p>File version to use. Supports versions 8-14.</p> </td> </tr> </table> "	FALSE
"tagged_na"	"haven"	"\"Tagged\" missing values"	"<p>'Tagged' missing values work exactly like regular R missing values except that they store one additional byte of information a tag, which is usually a letter ('a' to 'z'). When by loading a SAS and Stata file, the tagged missing values always use lower case values. </p>"	"<pre>tagged_na(...)<br />na_tag(x)<br />is_tagged_na(x, tag = NULL)<br />format_tagged_na(x, digits = getOption('digits'))<br />print_tagged_na(x, digits = getOption('digits')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Vectors containing single character. The letter will be used to 'tag' the missing value.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>A numeric vector</p> </td> </tr> <tr valign='top'> <td><code>tag</code></td> <td> <p>If <code>NULL</code>, will only return true if the tag has this value.</p> </td> </tr> <tr valign='top'> <td><code>digits</code></td> <td> <p>Number of digits to use in string representation</p> </td> </tr> </table> "	FALSE
"read_dta"	"haven"	"Read and write Stata DTA files."	"<p>Currently haven can read and write logical, integer, numeric, character and factors. See <code>labelled</code> for how labelled variables in Stata are handled in R. </p>"	"<pre>read_dta(file, encoding = NULL)<br />read_stata(file, encoding = NULL)<br />write_dta(data, path, version = 14) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>The character encoding used for the file. This defaults to the encoding specified in the file, or UTF-8. But older versions of Stata (13 and earlier) did not store the encoding used, and you'll need to specify manually. A commonly used value is 'Win 1252'.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Data frame to write.</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to a file where the data will be written.</p> </td> </tr> <tr valign='top'> <td><code>version</code></td> <td> <p>File version to use. Supports versions 8-14.</p> </td> </tr> </table> "	FALSE
"read_sas"	"haven"	"Read and write SAS files."	"<p>Reading supports both sas7bdat files and the accompanying sas7bdat files that SAS uses to record value labels. Writing value labels is not currently supported. </p>"	"<pre>read_sas(data_file, catalog_file = NULL, encoding = NULL)<br />write_sas(data, path) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data_file, catalog_file</code></td> <td> <p>Path to data and catalog files. The files are processed with <code>datasource()</code>.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>The character encoding used for the file. This defaults to the encoding specified in the file, or UTF-8. You can use this argument to override the value stored in the file if it is correct</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Data frame to write.</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to file where the data will be written.</p> </td> </tr> </table> "	FALSE
"read_spss"	"haven"	"Read SPSS (SAV & POR) files. Write SAV files."	"<p>Currently haven can read and write logical, integer, numeric, character and factors. See <code>labelled_spss</code> for how labelled variables in Stata are handled in R. <code>read_spss</code> is an alias for <code>read_sav</code>. </p>"	"<pre>read_sav(file, user_na = FALSE)<br />read_por(file, user_na = FALSE)<br />write_sav(data, path)<br />read_spss(file, user_na = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>user_na</code></td> <td> <p>If <code>TRUE</code> variables with user defined missing will be read into <code>labelled_spss</code> objects. If <code>FALSE</code>, the default, user-defined missings will be converted to <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>Data frame to write.</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to a file where the data will be written.</p> </td> </tr> </table> "	FALSE
"zap_empty"	"haven"	"Convert empty strings into missing values."	"<p>Convert empty strings into missing values. </p>"	"<pre>zap_empty(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A character vector</p> </td> </tr></table> "	FALSE
"zap_formats"	"haven"	"Remove format attributes"	"<p>To provide some mild support for round-tripping variables between Stata/SPSS and R, haven stores variable formats in an attribute: <code>format.stata</code>, <code>format.spss</code>, or <code>format.sas</code>. If this causes problems for your code, you can get rid of them with <code>zap_formats</code>. </p>"	"<pre>zap_formats(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A vector or data frame.</p> </td> </tr></table> "	FALSE
"zap_labels"	"haven"	"Zap labels"	"<p>Removes labels, leaving unlabelled vectors as is. Use this if you want to simply drop all labelling from a data frame. Zapping labels from <code>labelled_spss</code> also removes user-defined missing values, replacing all with <code>NA</code>s. </p>"	"<pre>zap_labels(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A vector or data frame</p> </td> </tr></table> "	FALSE
"zap_missing"	"haven"	"Zap special missings to regular R missings"	"<p>This is useful if you want to convert tagged missing values from SAS or Stata, or user-defined missings from SPSS, to regular R <code>NA</code>. </p>"	"<pre>zap_missing(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A vector or data frame</p> </td> </tr></table> "	FALSE
"httr"	"httr"	"httr makes http easy."	"<p><code>httr</code> is organised around the five most common http verbs: <code>GET</code>, <code>PATCH</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, and <code>DELETE</code>. </p>"	NA	NA	FALSE
"content_type"	"httr"	"Set content-type and accept headers."	"<p>These are convenient wrappers aroud <code>add_headers</code>. </p>"	"<pre>content_type(type)<br />content_type_json()<br />content_type_xml()<br />accept(type)<br />accept_json()<br />accept_xml() </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>type</code></td> <td> <p>A mime type or a file extension. If a file extension (i.e. starts with <code>.</code>) will guess the mime type using <code>guess_type</code>.</p> </td> </tr></table> "	FALSE
"content_type"	"httr"	"Set content-type and accept headers."	"<p>These are convenient wrappers aroud <code>add_headers</code>. </p>"	"<pre>content_type(type)<br />content_type_json()<br />content_type_xml()<br />accept(type)<br />accept_json()<br />accept_xml() </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>type</code></td> <td> <p>A mime type or a file extension. If a file extension (i.e. starts with <code>.</code>) will guess the mime type using <code>guess_type</code>.</p> </td> </tr></table> "	FALSE
"content_type"	"httr"	"Set content-type and accept headers."	"<p>These are convenient wrappers aroud <code>add_headers</code>. </p>"	"<pre>content_type(type)<br />content_type_json()<br />content_type_xml()<br />accept(type)<br />accept_json()<br />accept_xml() </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>type</code></td> <td> <p>A mime type or a file extension. If a file extension (i.e. starts with <code>.</code>) will guess the mime type using <code>guess_type</code>.</p> </td> </tr></table> "	FALSE
"add_headers"	"httr"	"Add additional headers to a request."	"<p>Wikipedia provides a useful list of common http headers: <a href='http://en.wikipedia.org/wiki/List_of_HTTP_header_fields'>http://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a>. </p>"	"<pre>add_headers(..., .headers = character()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>named header values.  To stop an existing header from being set, pass an empty string: <code>''</code>.</p> </td> </tr> <tr valign='top'> <td><code>.headers</code></td> <td> <p>a named character vector</p> </td> </tr> </table> "	FALSE
"authenticate"	"httr"	"Use http authentication."	"<p>It's not obvious how to turn authentication off after using it, so I recommend using custom handles with authentication. </p>"	"<pre>authenticate(user, password, type = 'basic') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>user</code></td> <td> <p>user name</p> </td> </tr> <tr valign='top'> <td><code>password</code></td> <td> <p>password</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>type of HTTP authentication.  Should be one of the following types supported by Curl: basic, digest, digest_ie, gssnegotiate, ntlm, any.  It defaults to 'basic', the most common type.</p> </td> </tr> </table> "	FALSE
"BROWSE"	"httr"	"Open specified url in browser."	"<p>(This isn't really a http verb, but it seems to follow the same format). </p>"	"<pre>BROWSE(url = NULL, config = list(), ..., handle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url</code></td> <td> <p>the url of the page to retrieve</p> </td> </tr> <tr valign='top'> <td><code>config</code></td> <td> <p>All configuration options are ignored because the request is handled by the browser, not <span class='pkg'>RCurl</span>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further named parameters, such as <code>query</code>, <code>path</code>, etc, passed on to <code>modify_url</code>. Unnamed parameters will be combined with <code>config</code>.</p> </td> </tr> <tr valign='top'> <td><code>handle</code></td> <td> <p>The handle to use with this request. If not supplied, will be retrieved and reused from the <code>handle_pool</code> based on the scheme, hostname and port of the url. By default <span class='pkg'>httr</span> requests to the same scheme/host/port combo. This substantially reduces connection time, and ensures that cookies are maintained over multiple requests to the same host. See <code>handle_pool</code> for more details.</p> </td> </tr> </table> "	FALSE
"parse_url"	"httr"	"Parse and build urls according to RFC1808."	"<p>See <a href='http://tools.ietf.org/html/rfc1808.html'>http://tools.ietf.org/html/rfc1808.html</a> for details of parsing algorithm. </p>"	"<pre>parse_url(url)<br />build_url(url) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>url</code></td> <td> <p>a character vector (of length 1) to parse into components, or for <code>build_url</code> a url to turn back into a string.</p> </td> </tr></table> "	FALSE
"cache_info"	"httr"	"Compute caching information for a response."	"<p><code>cache_info()</code> gives details of cacheability of a response, <code>rerequest()</code> re-performs the original request doing as little work as possible (if not expired, returns response as is, or performs revalidation if Etag or Last-Modified headers are present). </p>"	"<pre>cache_info(r)<br />rerequest(r) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>r</code></td> <td> <p>A response</p> </td> </tr></table> "	FALSE
"config"	"httr"	"Set curl options."	"<p>Generally you should only need to use this function to set CURL options directly if there isn't already a helpful wrapper function, like <code>set_cookies</code>, <code>add_headers</code> or <code>authenticate</code>. To use this function effectively requires some knowledge of CURL, and CURL options. Use <code>httr_options</code> to see a complete list of available options. To see the libcurl documentation for a given option, use <code>curl_docs</code>. </p>"	"<pre>config(..., token = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>named Curl options.</p> </td> </tr> <tr valign='top'> <td><code>token</code></td> <td> <p>An OAuth token (1.0 or 2.0)</p> </td> </tr> </table> "	FALSE
"content"	"httr"	"Extract content from a request."	"<p>There are currently three ways to retrieve the contents of a request: as a raw object (<code>as = 'raw'</code>), as a character vector, (<code>as = 'text'</code>), and as parsed into an R object where possible, (<code>as = 'parsed'</code>). If <code>as</code> is not specified, <code>content</code> does its best to guess which output is most appropriate. </p>"	"<pre>content(x, as = NULL, type = NULL, encoding = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>request object</p> </td> </tr> <tr valign='top'> <td><code>as</code></td> <td> <p>desired type of output: <code>raw</code>, <code>text</code> or <code>parsed</code>. <code>content</code> attempts to automatically figure out which one is most appropriate, based on the content-type.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>MIME type (aka internet media type) used to override the content type returned by the server. See <a href='http://en.wikipedia.org/wiki/Internet_media_type'>http://en.wikipedia.org/wiki/Internet_media_type</a> for a list of common types.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>For text, overrides the charset or the Latin1 (ISO-8859-1) default, if you know that the server is returning the incorrect encoding as the charset in the content-type. Use for text and parsed outputs.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other parameters parsed on to the parsing functions, if <code>as = 'parsed'</code></p> </td> </tr> </table> "	FALSE
"content_type"	"httr"	"Set content-type and accept headers."	"<p>These are convenient wrappers aroud <code>add_headers</code>. </p>"	"<pre>content_type(type)<br />content_type_json()<br />content_type_xml()<br />accept(type)<br />accept_json()<br />accept_xml() </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>type</code></td> <td> <p>A mime type or a file extension. If a file extension (i.e. starts with <code>.</code>) will guess the mime type using <code>guess_type</code>.</p> </td> </tr></table> "	FALSE
"content_type"	"httr"	"Set content-type and accept headers."	"<p>These are convenient wrappers aroud <code>add_headers</code>. </p>"	"<pre>content_type(type)<br />content_type_json()<br />content_type_xml()<br />accept(type)<br />accept_json()<br />accept_xml() </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>type</code></td> <td> <p>A mime type or a file extension. If a file extension (i.e. starts with <code>.</code>) will guess the mime type using <code>guess_type</code>.</p> </td> </tr></table> "	FALSE
"content_type"	"httr"	"Set content-type and accept headers."	"<p>These are convenient wrappers aroud <code>add_headers</code>. </p>"	"<pre>content_type(type)<br />content_type_json()<br />content_type_xml()<br />accept(type)<br />accept_json()<br />accept_xml() </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>type</code></td> <td> <p>A mime type or a file extension. If a file extension (i.e. starts with <code>.</code>) will guess the mime type using <code>guess_type</code>.</p> </td> </tr></table> "	FALSE
"cookies"	"httr"	"Access cookies in a response."	"<p>Access cookies in a response. </p>"	"<pre>cookies(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A response.</p> </td> </tr></table> "	FALSE
"httr_options"	"httr"	"List available options."	"<p>This function lists all available options for <code>config()</code>. It provides both the short R name which you use with httr, and the longer Curl name, which is useful when searching the documentation. <code>curl_doc</code> opens a link to the libcurl documentation for an option in your browser. </p>"	"<pre>httr_options(matches)<br />curl_docs(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>matches</code></td> <td> <p>If not missing, this restricts the output so that either the httr or curl option matches this regular expression.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An option name (either short or full).</p> </td> </tr> </table> "	FALSE
"DELETE"	"httr"	"Send a DELETE request."	"<p>Send a DELETE request. </p>"	"<pre>DELETE(url = NULL, config = list(), ..., body = NULL,<br />   encode = c('multipart', 'form', 'json', 'raw'), handle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url</code></td> <td> <p>the url of the page to retrieve</p> </td> </tr> <tr valign='top'> <td><code>config</code></td> <td> <p>Additional configuration settings such as http authentication (<code>authenticate</code>), additional headers (<code>add_headers</code>), cookies (<code>set_cookies</code>) etc. See <code>config</code> for full details and list of helpers.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further named parameters, such as <code>query</code>, <code>path</code>, etc, passed on to <code>modify_url</code>. Unnamed parameters will be combined with <code>config</code>.</p> </td> </tr> <tr valign='top'> <td><code>body</code></td> <td> <p>One of the following: </p><br /><ul> <li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>, <code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a bodyless request (like <code>GET</code>) with <code>VERB()</code>. </p> </li> <li> <p><code>NULL</code>: An empty body </p> </li> <li> <p><code>''</code>: A length 0 body </p> </li> <li> <p><code>upload_file('path/')</code>: The contents of a file.  The mime type will be guessed from the extension, or can be supplied explicitly as the second argument to <code>upload_file()</code> </p> </li> <li> <p> A character or raw vector: sent as is in body. Use <code>content_type</code> to tell the server what sort of data you are sending. </p> </li> <li> <p> A named list: See details for encode. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>encode</code></td> <td> <p>If the body is a named list, how should it be encoded? Can be one of form (application/x-www-form-urlencoded), multipart, (multipart/form-data), or json (application/json). </p> <p>For 'multipart', list elements can be strings or objects created by <code>upload_file</code>. For 'form', elements are coerced to strings and escaped, use <code>I()</code> to prevent double-escaping. For 'json', parameters are automatically 'unboxed' (i.e. length 1 vectors are converted to scalars). To preserve a length 1 vector as a vector, wrap in <code>I()</code>. For 'raw', either a character or raw vector. You'll need to make sure to set the <code>content_type()</code> yourself.</p> </td> </tr> <tr valign='top'> <td><code>handle</code></td> <td> <p>The handle to use with this request. If not supplied, will be retrieved and reused from the <code>handle_pool</code> based on the scheme, hostname and port of the url. By default <span class='pkg'>httr</span> requests to the same scheme/host/port combo. This substantially reduces connection time, and ensures that cookies are maintained over multiple requests to the same host. See <code>handle_pool</code> for more details.</p> </td> </tr> </table> "	FALSE
"GET"	"httr"	"GET a url."	"<p>GET a url. </p>"	"<pre>GET(url = NULL, config = list(), ..., handle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url</code></td> <td> <p>the url of the page to retrieve</p> </td> </tr> <tr valign='top'> <td><code>config</code></td> <td> <p>Additional configuration settings such as http authentication (<code>authenticate</code>), additional headers (<code>add_headers</code>), cookies (<code>set_cookies</code>) etc. See <code>config</code> for full details and list of helpers.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further named parameters, such as <code>query</code>, <code>path</code>, etc, passed on to <code>modify_url</code>. Unnamed parameters will be combined with <code>config</code>.</p> </td> </tr> <tr valign='top'> <td><code>handle</code></td> <td> <p>The handle to use with this request. If not supplied, will be retrieved and reused from the <code>handle_pool</code> based on the scheme, hostname and port of the url. By default <span class='pkg'>httr</span> requests to the same scheme/host/port combo. This substantially reduces connection time, and ensures that cookies are maintained over multiple requests to the same host. See <code>handle_pool</code> for more details.</p> </td> </tr> </table> "	FALSE
"handle"	"httr"	"Create a handle tied to a particular host."	"<p>This handle preserves settings and cookies across multiple requests. It is the foundation of all requests performed through the httr package, although it will mostly be hidden from the user. </p>"	"<pre>handle(url, cookies = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url</code></td> <td> <p>full url to site</p> </td> </tr> <tr valign='top'> <td><code>cookies</code></td> <td> <p>DEPRECATED</p> </td> </tr> </table> "	FALSE
"HEAD"	"httr"	"Get url HEADers."	"<p>Get url HEADers. </p>"	"<pre>HEAD(url = NULL, config = list(), ..., handle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url</code></td> <td> <p>the url of the page to retrieve</p> </td> </tr> <tr valign='top'> <td><code>config</code></td> <td> <p>Additional configuration settings such as http authentication (<code>authenticate</code>), additional headers (<code>add_headers</code>), cookies (<code>set_cookies</code>) etc. See <code>config</code> for full details and list of helpers.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further named parameters, such as <code>query</code>, <code>path</code>, etc, passed on to <code>modify_url</code>. Unnamed parameters will be combined with <code>config</code>.</p> </td> </tr> <tr valign='top'> <td><code>handle</code></td> <td> <p>The handle to use with this request. If not supplied, will be retrieved and reused from the <code>handle_pool</code> based on the scheme, hostname and port of the url. By default <span class='pkg'>httr</span> requests to the same scheme/host/port combo. This substantially reduces connection time, and ensures that cookies are maintained over multiple requests to the same host. See <code>handle_pool</code> for more details.</p> </td> </tr> </table> "	FALSE
"headers"	"httr"	"Extract the headers from a response"	"<p>Extract the headers from a response </p>"	"<pre>headers(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A request object</p> </td> </tr></table> "	FALSE
"parse_http_date"	"httr"	"Parse and print http dates."	"<p>As defined in RFC2616, <a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3'>http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3</a>, there are three valid formats: </p> <ul> <li> <p> Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123 </p> </li> <li> <p> Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036 </p> </li> <li> <p> Sun Nov  6 08:49:37 1994<br />       ; ANSI C's asctime() format </p> </li> </ul> "	"<pre>parse_http_date(x, failure = NA)<br />http_date(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>For <code>parse_http_date</code>, a character vector of strings to parse. All elements must be of the same type. </p> <p>For <code>http_date</code>, a <code>POSIXt</code> vector.</p> </td> </tr> <tr valign='top'> <td><code>failure</code></td> <td> <p>What to return on failure?</p> </td> </tr> </table> "	FALSE
"http_error"	"httr"	"Check for an http error."	"<p>Check for an http error. </p>"	"<pre>http_error(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to check. Default methods are provided for strings (which perform an <code>HEAD</code> request), responses, and integer status codes.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to methods.</p> </td> </tr> </table> "	FALSE
"http_status"	"httr"	"Give information on the status of a request."	"<p>Extract the http status code and convert it into a human readable message. </p>"	"<pre>http_status(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>a request object or a number.</p> </td> </tr></table> "	FALSE
"http_type"	"httr"	"Extract the content type of a response"	"<p>Extract the content type of a response </p>"	"<pre>http_type(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A response</p> </td> </tr></table> "	FALSE
"httr"	"httr"	"httr makes http easy."	"<p><code>httr</code> is organised around the five most common http verbs: <code>GET</code>, <code>PATCH</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, and <code>DELETE</code>. </p>"	NA	NA	FALSE
"httr_dr"	"httr"	"Diagnose common configuration problems"	"<p>Currently one check: that curl uses nss. </p>"	"<pre>httr_dr() </pre>"	NA	FALSE
"httr_options"	"httr"	"List available options."	"<p>This function lists all available options for <code>config()</code>. It provides both the short R name which you use with httr, and the longer Curl name, which is useful when searching the documentation. <code>curl_doc</code> opens a link to the libcurl documentation for an option in your browser. </p>"	"<pre>httr_options(matches)<br />curl_docs(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>matches</code></td> <td> <p>If not missing, this restricts the output so that either the httr or curl option matches this regular expression.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An option name (either short or full).</p> </td> </tr> </table> "	FALSE
"stop_for_status"	"httr"	"Take action on http error."	"<p>Converts http errors to R errors or warnings - these should always be used whenever you're creating requests inside a function, so that the user knows why a request has failed. </p>"	"<pre>stop_for_status(x, task = NULL)<br />warn_for_status(x, task = NULL)<br />message_for_status(x, task = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a response, or numeric http code (or other object with <code>status_code</code> method)</p> </td> </tr> <tr valign='top'> <td><code>task</code></td> <td> <p>The text of the message: either <code>NULL</code> or a character vector. If non-<code>NULL</code>, the error message will finish with 'Failed to <code>task</code>'.</p> </td> </tr> </table> "	FALSE
"modify_url"	"httr"	"Modify a url."	"<p>Modify a url by first parsing it and then replacing components with the non-NULL arguments of this function. </p>"	"<pre>modify_url(url, scheme = NULL, hostname = NULL, port = NULL,<br />   path = NULL, query = NULL, params = NULL, fragment = NULL,<br />   username = NULL, password = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url</code></td> <td> <p>the url to modify</p> </td> </tr> <tr valign='top'> <td><code>scheme, hostname, port, path, query, params, fragment, username, password</code></td> <td> <p>components of the url to change</p> </td> </tr> </table>"	FALSE
"oauth1.0_token"	"httr"	"Generate an oauth1.0 token."	"<p>This is the final object in the OAuth dance - it encapsulates the app, the endpoint, other parameters and the received credentials. </p>"	"<pre>oauth1.0_token(endpoint, app, permission = NULL, as_header = TRUE,<br />   private_key = NULL, cache = getOption('httr_oauth_cache')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>endpoint</code></td> <td> <p>An OAuth endpoint, created by <code>oauth_endpoint</code></p> </td> </tr> <tr valign='top'> <td><code>app</code></td> <td> <p>An OAuth consumer application, created by <code>oauth_app</code></p> </td> </tr> <tr valign='top'> <td><code>permission</code></td> <td> <p>optional, a string of permissions to ask for.</p> </td> </tr> <tr valign='top'> <td><code>as_header</code></td> <td> <p>If <code>TRUE</code>, the default, sends oauth in header. If <code>FALSE</code>, adds as parameter to url.</p> </td> </tr> <tr valign='top'> <td><code>private_key</code></td> <td> <p>Optional, a key provided by <code>read_key</code>. Used for signed OAuth 1.0.</p> </td> </tr> <tr valign='top'> <td><code>cache</code></td> <td> <p>A logical value or a string. <code>TRUE</code> means to cache using the default cache file <code>.httr-oauth</code>, <code>FALSE</code> means don't cache, and <code>NA</code> means to guess using some sensible heuristics. A string mean use the specified path as the cache file.</p> </td> </tr> </table> "	FALSE
"oauth2.0_token"	"httr"	"Generate an oauth2.0 token."	"<p>This is the final object in the OAuth dance - it encapsulates the app, the endpoint, other parameters and the received credentials. It is a reference class so that it can be seamlessly updated (e.g. using <code>$refresh()</code>) when access expires. </p>"	"<pre>oauth2.0_token(endpoint, app, scope = NULL, user_params = NULL,<br />   type = NULL, use_oob = getOption('httr_oob_default'), as_header = TRUE,<br />   use_basic_auth = FALSE, cache = getOption('httr_oauth_cache')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>endpoint</code></td> <td> <p>An OAuth endpoint, created by <code>oauth_endpoint</code></p> </td> </tr> <tr valign='top'> <td><code>app</code></td> <td> <p>An OAuth consumer application, created by <code>oauth_app</code></p> </td> </tr> <tr valign='top'> <td><code>scope</code></td> <td> <p>a character vector of scopes to request.</p> </td> </tr> <tr valign='top'> <td><code>user_params</code></td> <td> <p>Named list holding endpoint specific parameters to pass to the server when posting the request for obtaining or refreshing the access token.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>content type used to override incorrect server response</p> </td> </tr> <tr valign='top'> <td><code>use_oob</code></td> <td> <p>if FALSE, use a local webserver for the OAuth dance. Otherwise, provide a URL to the user and prompt for a validation code. Defaults to the of the <code>'httr_oob_default'</code> default, or <code>TRUE</code> if <code>httpuv</code> is not installed.</p> </td> </tr> <tr valign='top'> <td><code>as_header</code></td> <td> <p>If <code>TRUE</code>, the default, configures the token to add itself to the bearer header of subsequent requests. If <code>FALSE</code>, configures the token to add itself as a url parameter of subsequent requests.</p> </td> </tr> <tr valign='top'> <td><code>use_basic_auth</code></td> <td> <p>if <code>TRUE</code> use http basic authentication to retrieve the token. Some authorization servers require this. If <code>FALSE</code>, the default, retrieve the token by including the app key and secret in the request body.</p> </td> </tr> <tr valign='top'> <td><code>cache</code></td> <td> <p>A logical value or a string. <code>TRUE</code> means to cache using the default cache file <code>.httr-oauth</code>, <code>FALSE</code> means don't cache, and <code>NA</code> means to guess using some sensible heuristics. A string mean use the specified path as the cache file.</p> </td> </tr> </table> "	FALSE
"oauth_app"	"httr"	"Create an OAuth application."	"<p>The OAuth framework doesn't match perfectly to use from R. Each user of the package for a particular OAuth enabled site must create their own application. See the demos for instructions on how to do this for linkedin, twitter, vimeo, facebook, github and google. </p>"	"<pre>oauth_app(appname, key, secret = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>appname</code></td> <td> <p>name of the application.  This is not used for OAuth, but is used to make it easier to identify different applications and provide a consistent way of storing secrets in environment variables.</p> </td> </tr> <tr valign='top'> <td><code>key</code></td> <td> <p>consumer key (equivalent to a user name)</p> </td> </tr> <tr valign='top'> <td><code>secret</code></td> <td> <p>consumer secret. This is not equivalent to a password, and is not really a secret. If you are writing an API wrapper package, it is fine to include this secret in your package code. </p> <p>Use <code>NULL</code> to not store a secret: this is useful if you're relying on cached OAuth tokens.</p> </td> </tr> </table> "	FALSE
"oauth_endpoint"	"httr"	"Describe an OAuth endpoint."	"<p>See <code>oauth_endpoints</code> for a list of popular OAuth endpoints baked into httr. </p>"	"<pre>oauth_endpoint(request = NULL, authorize, access, ..., base_url = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>request</code></td> <td> <p>url used to request initial (unauthenticated) token. If using OAuth2.0, leave as <code>NULL</code>.</p> </td> </tr> <tr valign='top'> <td><code>authorize</code></td> <td> <p>url to send client to for authorisation</p> </td> </tr> <tr valign='top'> <td><code>access</code></td> <td> <p>url used to exchange unauthenticated for authenticated token.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>other additional endpoints.</p> </td> </tr> <tr valign='top'> <td><code>base_url</code></td> <td> <p>option url to use as base for <code>request</code>, <code>authorize</code> and <code>access</code> urls.</p> </td> </tr> </table> "	FALSE
"oauth_endpoints"	"httr"	"Popular oauth endpoints."	"<p>Provides some common OAuth endpoints. </p>"	"<pre>oauth_endpoints(name) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>name</code></td> <td> <p>One of the following endpoints: linkedin, twitter, vimeo, google, facebook, github, azure.</p> </td> </tr></table> "	FALSE
"oauth_service_token"	"httr"	"Generate OAuth token for service accounts."	"<p>Service accounts provide a way of using OAuth2 without user intervention. They instead assume that the server has access to a private key used to sign requests. The OAuth app is not needed for service accounts: that information is embedded in the account itself. </p>"	"<pre>oauth_service_token(endpoint, secrets, scope = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>endpoint</code></td> <td> <p>An OAuth endpoint, created by <code>oauth_endpoint</code></p> </td> </tr> <tr valign='top'> <td><code>secrets</code></td> <td> <p>Secrets loaded from JSON file, downloaded from console.</p> </td> </tr> <tr valign='top'> <td><code>scope</code></td> <td> <p>a character vector of scopes to request.</p> </td> </tr> </table> "	FALSE
"content"	"httr"	"Extract content from a request."	"<p>There are currently three ways to retrieve the contents of a request: as a raw object (<code>as = 'raw'</code>), as a character vector, (<code>as = 'text'</code>), and as parsed into an R object where possible, (<code>as = 'parsed'</code>). If <code>as</code> is not specified, <code>content</code> does its best to guess which output is most appropriate. </p>"	"<pre>content(x, as = NULL, type = NULL, encoding = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>request object</p> </td> </tr> <tr valign='top'> <td><code>as</code></td> <td> <p>desired type of output: <code>raw</code>, <code>text</code> or <code>parsed</code>. <code>content</code> attempts to automatically figure out which one is most appropriate, based on the content-type.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>MIME type (aka internet media type) used to override the content type returned by the server. See <a href='http://en.wikipedia.org/wiki/Internet_media_type'>http://en.wikipedia.org/wiki/Internet_media_type</a> for a list of common types.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>For text, overrides the charset or the Latin1 (ISO-8859-1) default, if you know that the server is returning the incorrect encoding as the charset in the content-type. Use for text and parsed outputs.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other parameters parsed on to the parsing functions, if <code>as = 'parsed'</code></p> </td> </tr> </table> "	FALSE
"parse_http_date"	"httr"	"Parse and print http dates."	"<p>As defined in RFC2616, <a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3'>http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3</a>, there are three valid formats: </p> <ul> <li> <p> Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123 </p> </li> <li> <p> Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036 </p> </li> <li> <p> Sun Nov  6 08:49:37 1994<br />       ; ANSI C's asctime() format </p> </li> </ul> "	"<pre>parse_http_date(x, failure = NA)<br />http_date(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>For <code>parse_http_date</code>, a character vector of strings to parse. All elements must be of the same type. </p> <p>For <code>http_date</code>, a <code>POSIXt</code> vector.</p> </td> </tr> <tr valign='top'> <td><code>failure</code></td> <td> <p>What to return on failure?</p> </td> </tr> </table> "	FALSE
"parse_url"	"httr"	"Parse and build urls according to RFC1808."	"<p>See <a href='http://tools.ietf.org/html/rfc1808.html'>http://tools.ietf.org/html/rfc1808.html</a> for details of parsing algorithm. </p>"	"<pre>parse_url(url)<br />build_url(url) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>url</code></td> <td> <p>a character vector (of length 1) to parse into components, or for <code>build_url</code> a url to turn back into a string.</p> </td> </tr></table> "	FALSE
"PATCH"	"httr"	"Send PATCH request to a server."	"<p>Send PATCH request to a server. </p>"	"<pre>PATCH(url = NULL, config = list(), ..., body = NULL,<br />   encode = c('multipart', 'form', 'json', 'raw'), handle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url</code></td> <td> <p>the url of the page to retrieve</p> </td> </tr> <tr valign='top'> <td><code>config</code></td> <td> <p>Additional configuration settings such as http authentication (<code>authenticate</code>), additional headers (<code>add_headers</code>), cookies (<code>set_cookies</code>) etc. See <code>config</code> for full details and list of helpers.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further named parameters, such as <code>query</code>, <code>path</code>, etc, passed on to <code>modify_url</code>. Unnamed parameters will be combined with <code>config</code>.</p> </td> </tr> <tr valign='top'> <td><code>body</code></td> <td> <p>One of the following: </p><br /><ul> <li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>, <code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a bodyless request (like <code>GET</code>) with <code>VERB()</code>. </p> </li> <li> <p><code>NULL</code>: An empty body </p> </li> <li> <p><code>''</code>: A length 0 body </p> </li> <li> <p><code>upload_file('path/')</code>: The contents of a file.  The mime type will be guessed from the extension, or can be supplied explicitly as the second argument to <code>upload_file()</code> </p> </li> <li> <p> A character or raw vector: sent as is in body. Use <code>content_type</code> to tell the server what sort of data you are sending. </p> </li> <li> <p> A named list: See details for encode. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>encode</code></td> <td> <p>If the body is a named list, how should it be encoded? Can be one of form (application/x-www-form-urlencoded), multipart, (multipart/form-data), or json (application/json). </p> <p>For 'multipart', list elements can be strings or objects created by <code>upload_file</code>. For 'form', elements are coerced to strings and escaped, use <code>I()</code> to prevent double-escaping. For 'json', parameters are automatically 'unboxed' (i.e. length 1 vectors are converted to scalars). To preserve a length 1 vector as a vector, wrap in <code>I()</code>. For 'raw', either a character or raw vector. You'll need to make sure to set the <code>content_type()</code> yourself.</p> </td> </tr> <tr valign='top'> <td><code>handle</code></td> <td> <p>The handle to use with this request. If not supplied, will be retrieved and reused from the <code>handle_pool</code> based on the scheme, hostname and port of the url. By default <span class='pkg'>httr</span> requests to the same scheme/host/port combo. This substantially reduces connection time, and ensures that cookies are maintained over multiple requests to the same host. See <code>handle_pool</code> for more details.</p> </td> </tr> </table> "	FALSE
"POST"	"httr"	"POST file to a server."	"<p>POST file to a server. </p>"	"<pre>POST(url = NULL, config = list(), ..., body = NULL,<br />   encode = c('multipart', 'form', 'json', 'raw'), handle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url</code></td> <td> <p>the url of the page to retrieve</p> </td> </tr> <tr valign='top'> <td><code>config</code></td> <td> <p>Additional configuration settings such as http authentication (<code>authenticate</code>), additional headers (<code>add_headers</code>), cookies (<code>set_cookies</code>) etc. See <code>config</code> for full details and list of helpers.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further named parameters, such as <code>query</code>, <code>path</code>, etc, passed on to <code>modify_url</code>. Unnamed parameters will be combined with <code>config</code>.</p> </td> </tr> <tr valign='top'> <td><code>body</code></td> <td> <p>One of the following: </p><br /><ul> <li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>, <code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a bodyless request (like <code>GET</code>) with <code>VERB()</code>. </p> </li> <li> <p><code>NULL</code>: An empty body </p> </li> <li> <p><code>''</code>: A length 0 body </p> </li> <li> <p><code>upload_file('path/')</code>: The contents of a file.  The mime type will be guessed from the extension, or can be supplied explicitly as the second argument to <code>upload_file()</code> </p> </li> <li> <p> A character or raw vector: sent as is in body. Use <code>content_type</code> to tell the server what sort of data you are sending. </p> </li> <li> <p> A named list: See details for encode. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>encode</code></td> <td> <p>If the body is a named list, how should it be encoded? Can be one of form (application/x-www-form-urlencoded), multipart, (multipart/form-data), or json (application/json). </p> <p>For 'multipart', list elements can be strings or objects created by <code>upload_file</code>. For 'form', elements are coerced to strings and escaped, use <code>I()</code> to prevent double-escaping. For 'json', parameters are automatically 'unboxed' (i.e. length 1 vectors are converted to scalars). To preserve a length 1 vector as a vector, wrap in <code>I()</code>. For 'raw', either a character or raw vector. You'll need to make sure to set the <code>content_type()</code> yourself.</p> </td> </tr> <tr valign='top'> <td><code>handle</code></td> <td> <p>The handle to use with this request. If not supplied, will be retrieved and reused from the <code>handle_pool</code> based on the scheme, hostname and port of the url. By default <span class='pkg'>httr</span> requests to the same scheme/host/port combo. This substantially reduces connection time, and ensures that cookies are maintained over multiple requests to the same host. See <code>handle_pool</code> for more details.</p> </td> </tr> </table> "	FALSE
"progress"	"httr"	"Add a progress bar."	"<p>Add a progress bar. </p>"	"<pre>progress(type = c('down', 'up'), con = stdout()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>type</code></td> <td> <p>Type of progress to display: either number of bytes uploaded or downloaded.</p> </td> </tr> <tr valign='top'> <td><code>con</code></td> <td> <p>Connection to send output too. Usually <code>stdout()</code> or <code>stderr</code>.</p> </td> </tr> </table> "	FALSE
"PUT"	"httr"	"Send PUT request to server."	"<p>Send PUT request to server. </p>"	"<pre>PUT(url = NULL, config = list(), ..., body = NULL,<br />   encode = c('multipart', 'form', 'json', 'raw'), handle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url</code></td> <td> <p>the url of the page to retrieve</p> </td> </tr> <tr valign='top'> <td><code>config</code></td> <td> <p>Additional configuration settings such as http authentication (<code>authenticate</code>), additional headers (<code>add_headers</code>), cookies (<code>set_cookies</code>) etc. See <code>config</code> for full details and list of helpers.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further named parameters, such as <code>query</code>, <code>path</code>, etc, passed on to <code>modify_url</code>. Unnamed parameters will be combined with <code>config</code>.</p> </td> </tr> <tr valign='top'> <td><code>body</code></td> <td> <p>One of the following: </p><br /><ul> <li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>, <code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a bodyless request (like <code>GET</code>) with <code>VERB()</code>. </p> </li> <li> <p><code>NULL</code>: An empty body </p> </li> <li> <p><code>''</code>: A length 0 body </p> </li> <li> <p><code>upload_file('path/')</code>: The contents of a file.  The mime type will be guessed from the extension, or can be supplied explicitly as the second argument to <code>upload_file()</code> </p> </li> <li> <p> A character or raw vector: sent as is in body. Use <code>content_type</code> to tell the server what sort of data you are sending. </p> </li> <li> <p> A named list: See details for encode. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>encode</code></td> <td> <p>If the body is a named list, how should it be encoded? Can be one of form (application/x-www-form-urlencoded), multipart, (multipart/form-data), or json (application/json). </p> <p>For 'multipart', list elements can be strings or objects created by <code>upload_file</code>. For 'form', elements are coerced to strings and escaped, use <code>I()</code> to prevent double-escaping. For 'json', parameters are automatically 'unboxed' (i.e. length 1 vectors are converted to scalars). To preserve a length 1 vector as a vector, wrap in <code>I()</code>. For 'raw', either a character or raw vector. You'll need to make sure to set the <code>content_type()</code> yourself.</p> </td> </tr> <tr valign='top'> <td><code>handle</code></td> <td> <p>The handle to use with this request. If not supplied, will be retrieved and reused from the <code>handle_pool</code> based on the scheme, hostname and port of the url. By default <span class='pkg'>httr</span> requests to the same scheme/host/port combo. This substantially reduces connection time, and ensures that cookies are maintained over multiple requests to the same host. See <code>handle_pool</code> for more details.</p> </td> </tr> </table> "	FALSE
"cache_info"	"httr"	"Compute caching information for a response."	"<p><code>cache_info()</code> gives details of cacheability of a response, <code>rerequest()</code> re-performs the original request doing as little work as possible (if not expired, returns response as is, or performs revalidation if Etag or Last-Modified headers are present). </p>"	"<pre>cache_info(r)<br />rerequest(r) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>r</code></td> <td> <p>A response</p> </td> </tr></table> "	FALSE
"set_config"	"httr"	"Set (and reset) global httr configuration."	"<p>Set (and reset) global httr configuration. </p>"	"<pre>set_config(config, override = FALSE)<br />reset_config() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>config</code></td> <td> <p>Settings as generated by <code>add_headers</code>, <code>set_cookies</code> or <code>authenticate</code>.</p> </td> </tr> <tr valign='top'> <td><code>override</code></td> <td> <p>if <code>TRUE</code>, ignore existing settings, if <code>FALSE</code>, combine new config with old.</p> </td> </tr> </table> "	FALSE
"response"	"httr"	"The response object."	"<p>The response object captures all information from a request.  It includes fields: </p>"	NA	NA	FALSE
"RETRY"	"httr"	"Retry a request until it succeeds."	"<p>Safely retry a request until it succeeds (returns an HTTP status code below 400). It is designed to be kind to the server: after each failure randomly waits up to twice as long. (Technically it uses exponential backoff with jitter, using the approach outlined in <a href='https://www.awsarchitectureblog.com/2015/03/backoff.html'>https://www.awsarchitectureblog.com/2015/03/backoff.html</a>.) </p>"	"<pre>RETRY(verb, url = NULL, config = list(), ..., body = NULL,<br />   encode = c('multipart', 'form', 'json', 'raw'), times = 3,<br />   pause_base = 1, pause_cap = 60, handle = NULL, quiet = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>verb</code></td> <td> <p>Name of verb to use.</p> </td> </tr> <tr valign='top'> <td><code>url</code></td> <td> <p>the url of the page to retrieve</p> </td> </tr> <tr valign='top'> <td><code>config</code></td> <td> <p>Additional configuration settings such as http authentication (<code>authenticate</code>), additional headers (<code>add_headers</code>), cookies (<code>set_cookies</code>) etc. See <code>config</code> for full details and list of helpers.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further named parameters, such as <code>query</code>, <code>path</code>, etc, passed on to <code>modify_url</code>. Unnamed parameters will be combined with <code>config</code>.</p> </td> </tr> <tr valign='top'> <td><code>body</code></td> <td> <p>One of the following: </p><br /><ul> <li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>, <code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a bodyless request (like <code>GET</code>) with <code>VERB()</code>. </p> </li> <li> <p><code>NULL</code>: An empty body </p> </li> <li> <p><code>''</code>: A length 0 body </p> </li> <li> <p><code>upload_file('path/')</code>: The contents of a file.  The mime type will be guessed from the extension, or can be supplied explicitly as the second argument to <code>upload_file()</code> </p> </li> <li> <p> A character or raw vector: sent as is in body. Use <code>content_type</code> to tell the server what sort of data you are sending. </p> </li> <li> <p> A named list: See details for encode. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>encode</code></td> <td> <p>If the body is a named list, how should it be encoded? Can be one of form (application/x-www-form-urlencoded), multipart, (multipart/form-data), or json (application/json). </p> <p>For 'multipart', list elements can be strings or objects created by <code>upload_file</code>. For 'form', elements are coerced to strings and escaped, use <code>I()</code> to prevent double-escaping. For 'json', parameters are automatically 'unboxed' (i.e. length 1 vectors are converted to scalars). To preserve a length 1 vector as a vector, wrap in <code>I()</code>. For 'raw', either a character or raw vector. You'll need to make sure to set the <code>content_type()</code> yourself.</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>Maximum number of requests to attempt.</p> </td> </tr> <tr valign='top'> <td><code>pause_base, pause_cap</code></td> <td> <p>This method uses exponential back-off with full jitter - this means that each request will randomly wait between 0 and <code>pause_base * 2 ^ attempt</code> seconds, up to a maximum of <code>pause_cap</code> seconds.</p> </td> </tr> <tr valign='top'> <td><code>handle</code></td> <td> <p>The handle to use with this request. If not supplied, will be retrieved and reused from the <code>handle_pool</code> based on the scheme, hostname and port of the url. By default <span class='pkg'>httr</span> requests to the same scheme/host/port combo. This substantially reduces connection time, and ensures that cookies are maintained over multiple requests to the same host. See <code>handle_pool</code> for more details.</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>If <code>FALSE</code>, will print a message displaying how long until the next request.</p> </td> </tr> </table> "	FALSE
"revoke_all"	"httr"	"Revoke all OAuth tokens in the cache."	"<p>Use this function if you think that your token may have been compromised, e.g. you accidentally uploaded the cache file to github. It's not possible to automatically revoke all tokens - this function will warn when it can't. </p>"	"<pre>revoke_all(cache_path = NA) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>cache_path</code></td> <td> <p>Path to cache file. Defaults to '.httr-oauth' in current directory.</p> </td> </tr></table>"	FALSE
"safe_callback"	"httr"	"Generate a safe R callback."	"<p>Generate a safe R callback. </p>"	"<pre>safe_callback(f) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>f</code></td> <td> <p>A function.</p> </td> </tr></table>"	FALSE
"set_config"	"httr"	"Set (and reset) global httr configuration."	"<p>Set (and reset) global httr configuration. </p>"	"<pre>set_config(config, override = FALSE)<br />reset_config() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>config</code></td> <td> <p>Settings as generated by <code>add_headers</code>, <code>set_cookies</code> or <code>authenticate</code>.</p> </td> </tr> <tr valign='top'> <td><code>override</code></td> <td> <p>if <code>TRUE</code>, ignore existing settings, if <code>FALSE</code>, combine new config with old.</p> </td> </tr> </table> "	FALSE
"set_cookies"	"httr"	"Set cookies."	"<p>Set cookies. </p>"	"<pre>set_cookies(..., .cookies = character(0)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a named cookie values</p> </td> </tr> <tr valign='top'> <td><code>.cookies</code></td> <td> <p>a named character vector</p> </td> </tr> </table> "	FALSE
"status_code"	"httr"	"Extract status code from response."	"<p>Extract status code from response. </p>"	"<pre>status_code(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A response</p> </td> </tr></table>"	FALSE
"stop_for_status"	"httr"	"Take action on http error."	"<p>Converts http errors to R errors or warnings - these should always be used whenever you're creating requests inside a function, so that the user knows why a request has failed. </p>"	"<pre>stop_for_status(x, task = NULL)<br />warn_for_status(x, task = NULL)<br />message_for_status(x, task = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a response, or numeric http code (or other object with <code>status_code</code> method)</p> </td> </tr> <tr valign='top'> <td><code>task</code></td> <td> <p>The text of the message: either <code>NULL</code> or a character vector. If non-<code>NULL</code>, the error message will finish with 'Failed to <code>task</code>'.</p> </td> </tr> </table> "	FALSE
"content"	"httr"	"Extract content from a request."	"<p>There are currently three ways to retrieve the contents of a request: as a raw object (<code>as = 'raw'</code>), as a character vector, (<code>as = 'text'</code>), and as parsed into an R object where possible, (<code>as = 'parsed'</code>). If <code>as</code> is not specified, <code>content</code> does its best to guess which output is most appropriate. </p>"	"<pre>content(x, as = NULL, type = NULL, encoding = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>request object</p> </td> </tr> <tr valign='top'> <td><code>as</code></td> <td> <p>desired type of output: <code>raw</code>, <code>text</code> or <code>parsed</code>. <code>content</code> attempts to automatically figure out which one is most appropriate, based on the content-type.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>MIME type (aka internet media type) used to override the content type returned by the server. See <a href='http://en.wikipedia.org/wiki/Internet_media_type'>http://en.wikipedia.org/wiki/Internet_media_type</a> for a list of common types.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>For text, overrides the charset or the Latin1 (ISO-8859-1) default, if you know that the server is returning the incorrect encoding as the charset in the content-type. Use for text and parsed outputs.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other parameters parsed on to the parsing functions, if <code>as = 'parsed'</code></p> </td> </tr> </table> "	FALSE
"timeout"	"httr"	"Set maximum request time."	"<p>Set maximum request time. </p>"	"<pre>timeout(seconds) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>seconds</code></td> <td> <p>number of seconds to wait for a response until giving up. Can not be less than 1 ms.</p> </td> </tr></table> "	FALSE
"upload_file"	"httr"	"Upload a file with POST or PUT."	"<p>Upload a file with <code>POST</code> or <code>PUT</code>. </p>"	"<pre>upload_file(path, type = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>path</code></td> <td> <p>path to file</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>mime type of path. If not supplied, will be guess by <code>guess_type</code> when needed.</p> </td> </tr> </table> "	FALSE
"http_error"	"httr"	"Check for an http error."	"<p>Check for an http error. </p>"	"<pre>http_error(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to check. Default methods are provided for strings (which perform an <code>HEAD</code> request), responses, and integer status codes.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to methods.</p> </td> </tr> </table> "	FALSE
"http_error"	"httr"	"Check for an http error."	"<p>Check for an http error. </p>"	"<pre>http_error(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to check. Default methods are provided for strings (which perform an <code>HEAD</code> request), responses, and integer status codes.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to methods.</p> </td> </tr> </table> "	FALSE
"user_agent"	"httr"	"Set user agent."	"<p>Override the default RCurl user agent of <code>NULL</code> </p>"	"<pre>user_agent(agent) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>agent</code></td> <td> <p>string giving user agent</p> </td> </tr></table> "	FALSE
"use_proxy"	"httr"	"Use a proxy to connect to the internet."	"<p>Use a proxy to connect to the internet. </p>"	"<pre>use_proxy(url, port = NULL, username = NULL, password = NULL,<br />   auth = 'basic') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url, port</code></td> <td> <p>location of proxy</p> </td> </tr> <tr valign='top'> <td><code>username, password</code></td> <td> <p>login details for proxy, if needed</p> </td> </tr> <tr valign='top'> <td><code>auth</code></td> <td> <p>type of HTTP authentication to use. Should be one of the following: basic, digest, digest_ie, gssnegotiate, ntlm, any.</p> </td> </tr> </table> "	FALSE
"VERB"	"httr"	"VERB a url."	"<p>Use an arbitrary verb. </p>"	"<pre>VERB(verb, url = NULL, config = list(), ..., body = NULL,<br />   encode = c('multipart', 'form', 'json', 'raw'), handle = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>verb</code></td> <td> <p>Name of verb to use.</p> </td> </tr> <tr valign='top'> <td><code>url</code></td> <td> <p>the url of the page to retrieve</p> </td> </tr> <tr valign='top'> <td><code>config</code></td> <td> <p>Additional configuration settings such as http authentication (<code>authenticate</code>), additional headers (<code>add_headers</code>), cookies (<code>set_cookies</code>) etc. See <code>config</code> for full details and list of helpers.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further named parameters, such as <code>query</code>, <code>path</code>, etc, passed on to <code>modify_url</code>. Unnamed parameters will be combined with <code>config</code>.</p> </td> </tr> <tr valign='top'> <td><code>body</code></td> <td> <p>One of the following: </p><br /><ul> <li> <p><code>FALSE</code>: No body. This is typically not used with <code>POST</code>, <code>PUT</code>, or <code>PATCH</code>, but can be useful if you need to send a bodyless request (like <code>GET</code>) with <code>VERB()</code>. </p> </li> <li> <p><code>NULL</code>: An empty body </p> </li> <li> <p><code>''</code>: A length 0 body </p> </li> <li> <p><code>upload_file('path/')</code>: The contents of a file.  The mime type will be guessed from the extension, or can be supplied explicitly as the second argument to <code>upload_file()</code> </p> </li> <li> <p> A character or raw vector: sent as is in body. Use <code>content_type</code> to tell the server what sort of data you are sending. </p> </li> <li> <p> A named list: See details for encode. </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>encode</code></td> <td> <p>If the body is a named list, how should it be encoded? Can be one of form (application/x-www-form-urlencoded), multipart, (multipart/form-data), or json (application/json). </p> <p>For 'multipart', list elements can be strings or objects created by <code>upload_file</code>. For 'form', elements are coerced to strings and escaped, use <code>I()</code> to prevent double-escaping. For 'json', parameters are automatically 'unboxed' (i.e. length 1 vectors are converted to scalars). To preserve a length 1 vector as a vector, wrap in <code>I()</code>. For 'raw', either a character or raw vector. You'll need to make sure to set the <code>content_type()</code> yourself.</p> </td> </tr> <tr valign='top'> <td><code>handle</code></td> <td> <p>The handle to use with this request. If not supplied, will be retrieved and reused from the <code>handle_pool</code> based on the scheme, hostname and port of the url. By default <span class='pkg'>httr</span> requests to the same scheme/host/port combo. This substantially reduces connection time, and ensures that cookies are maintained over multiple requests to the same host. See <code>handle_pool</code> for more details.</p> </td> </tr> </table> "	FALSE
"verbose"	"httr"	"Give verbose output."	"<p>A verbose connection provides much more information about the flow of information between the client and server. </p>"	"<pre>verbose(data_out = TRUE, data_in = FALSE, info = FALSE, ssl = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data_out</code></td> <td> <p>Show data sent to the server.</p> </td> </tr> <tr valign='top'> <td><code>data_in</code></td> <td> <p>Show data recieved from the server.</p> </td> </tr> <tr valign='top'> <td><code>info</code></td> <td> <p>Show informational text from curl. This is mainly useful for debugging https and auth problems, so is disabled by default.</p> </td> </tr> <tr valign='top'> <td><code>ssl</code></td> <td> <p>Show even data sent/recieved over SSL connections?</p> </td> </tr> </table> "	FALSE
"stop_for_status"	"httr"	"Take action on http error."	"<p>Converts http errors to R errors or warnings - these should always be used whenever you're creating requests inside a function, so that the user knows why a request has failed. </p>"	"<pre>stop_for_status(x, task = NULL)<br />warn_for_status(x, task = NULL)<br />message_for_status(x, task = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a response, or numeric http code (or other object with <code>status_code</code> method)</p> </td> </tr> <tr valign='top'> <td><code>task</code></td> <td> <p>The text of the message: either <code>NULL</code> or a character vector. If non-<code>NULL</code>, the error message will finish with 'Failed to <code>task</code>'.</p> </td> </tr> </table> "	FALSE
"with_config"	"httr"	"Execute code with configuration set."	"<p>Execute code with configuration set. </p>"	"<pre>with_config(config = config(), expr, override = FALSE)<br />with_verbose(expr, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>config</code></td> <td> <p>Settings as generated by <code>add_headers</code>, <code>set_cookies</code> or <code>authenticate</code>.</p> </td> </tr> <tr valign='top'> <td><code>expr</code></td> <td> <p>code to execute under specified configuration</p> </td> </tr> <tr valign='top'> <td><code>override</code></td> <td> <p>if <code>TRUE</code>, ignore existing settings, if <code>FALSE</code>, combine new config with old.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>verbose</code></p> </td> </tr> </table> "	FALSE
"with_config"	"httr"	"Execute code with configuration set."	"<p>Execute code with configuration set. </p>"	"<pre>with_config(config = config(), expr, override = FALSE)<br />with_verbose(expr, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>config</code></td> <td> <p>Settings as generated by <code>add_headers</code>, <code>set_cookies</code> or <code>authenticate</code>.</p> </td> </tr> <tr valign='top'> <td><code>expr</code></td> <td> <p>code to execute under specified configuration</p> </td> </tr> <tr valign='top'> <td><code>override</code></td> <td> <p>if <code>TRUE</code>, ignore existing settings, if <code>FALSE</code>, combine new config with old.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>verbose</code></p> </td> </tr> </table> "	FALSE
"write_disk"	"httr"	"Control where the response body is written."	"<p>The default behaviour is to use <code>write_memory()</code>, which caches the response locally in memory. This is useful when talking to APIs as it avoids a round-trip to disk. If you want to save a file that's bigger than memory, use <code>write_disk()</code> to save it to a known path. </p>"	"<pre>write_disk(path, overwrite = FALSE)<br />write_memory() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to content to.</p> </td> </tr> <tr valign='top'> <td><code>overwrite</code></td> <td> <p>Will only overwrite existing <code>path</code> if TRUE.</p> </td> </tr> </table> "	FALSE
"write_disk"	"httr"	"Control where the response body is written."	"<p>The default behaviour is to use <code>write_memory()</code>, which caches the response locally in memory. This is useful when talking to APIs as it avoids a round-trip to disk. If you want to save a file that's bigger than memory, use <code>write_disk()</code> to save it to a known path. </p>"	"<pre>write_disk(path, overwrite = FALSE)<br />write_memory() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to content to.</p> </td> </tr> <tr valign='top'> <td><code>overwrite</code></td> <td> <p>Will only overwrite existing <code>path</code> if TRUE.</p> </td> </tr> </table> "	FALSE
"write_stream"	"httr"	"Process output in a streaming manner."	"<p>This is the most general way of processing the response from the server - you receive the raw bytes as they come in, and you can do whatever you want with them. </p>"	"<pre>write_stream(f) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>f</code></td> <td> <p>Callback function. It should have a single argument, a raw vector containing the bytes recieved from the server. This will usually be 16k or less. The return value of the function is ignored.</p> </td> </tr></table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"hms"	"hms"	"A simple class for storing time-of-day values"	"<p>The values are stored as a <code>difftime</code> vector with a custom class, and always with 'seconds' as unit for robust coercion to numeric. Supports construction from time values, coercion to and from various data types, and formatting.  Can be used as a regular column in a data frame. </p>"	"<pre>hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)<br />is.hms(x)<br />as.hms(x, ...)<br />## Default S3 method: as.hms(x, ...)<br />## S3 method for class 'difftime' as.hms(x, ...)<br />## S3 method for class 'numeric' as.hms(x, ...)<br />## S3 method for class 'character' as.hms(x, ...)<br />## S3 method for class 'POSIXt' as.hms(x, ...)<br />## S3 method for class 'hms' as.POSIXct(x, ...)<br />## S3 method for class 'hms' as.POSIXlt(x, ...)<br />## S3 method for class 'hms' as.character(x, ...)<br />## S3 method for class 'hms' as.data.frame(x, row.names = NULL, optional = FALSE, ...,<br />   nm = paste(deparse(substitute(x), width.cutoff = 500L), collapse = ' '))<br />## S3 method for class 'hms' format(x, ...)<br />## S3 method for class 'hms' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>seconds, minutes, hours, days</code></td> <td> <p>Time since midnight. No bounds checking is performed.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Arguments passed on to further methods.</p> </td> </tr> <tr valign='top'> <td><code>row.names</code></td> <td> <p><code>NULL</code> or a character vector giving the row names for the data frame.  Missing values are not allowed.</p> </td> </tr> <tr valign='top'> <td><code>optional</code></td> <td> <p>logical. If <code>TRUE</code>, setting row names and converting column names (to syntactic names: see <code>make.names</code>) is optional.  Note that all of <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span>'s <span class='pkg'>base</span> package <code>as.data.frame()</code> methods use <code>optional</code> only for column names treatment, basically with the meaning of <code>data.frame(*, check.names = !optional)</code>.</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Name of column in new data frame</p> </td> </tr> </table> "	FALSE
"base64"	"jsonlite"	"Encode/decode base64"	"<p>Simple in-memory base64 encoder and decoder. Used internally for converting raw vectors to text. Interchangable with encoder from <code>base64enc</code> or <code>openssl</code> package. </p>"	"<pre>base64_dec(input)<br />base64_enc(input) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>input</code></td> <td> <p>string or raw vector to be encoded/decoded</p> </td> </tr></table> "	FALSE
"base64"	"jsonlite"	"Encode/decode base64"	"<p>Simple in-memory base64 encoder and decoder. Used internally for converting raw vectors to text. Interchangable with encoder from <code>base64enc</code> or <code>openssl</code> package. </p>"	"<pre>base64_dec(input)<br />base64_enc(input) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>input</code></td> <td> <p>string or raw vector to be encoded/decoded</p> </td> </tr></table> "	FALSE
"base64"	"jsonlite"	"Encode/decode base64"	"<p>Simple in-memory base64 encoder and decoder. Used internally for converting raw vectors to text. Interchangable with encoder from <code>base64enc</code> or <code>openssl</code> package. </p>"	"<pre>base64_dec(input)<br />base64_enc(input) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>input</code></td> <td> <p>string or raw vector to be encoded/decoded</p> </td> </tr></table> "	FALSE
"flatten"	"jsonlite"	"Flatten nested data frames"	"<p>In a nested data frame, one or more of the columns consist of another data frame. These structures frequently appear when parsing JSON data from the web. We can flatten such data frames into a regular 2 dimensional tabular structure. </p>"	"<pre>flatten(x, recursive = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a data frame</p> </td> </tr> <tr valign='top'> <td><code>recursive</code></td> <td> <p>flatten recursively</p> </td> </tr> </table> "	FALSE
"fromJSON"	"jsonlite"	"Convert R objects to/from JSON"	"<p>These functions are used to convert between JSON data and <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span> objects. The <code>toJSON</code> and <code>fromJSON</code> functions use a class based mapping, which follows conventions outlined in this paper:  <a href='https://arxiv.org/abs/1403.2805'>https://arxiv.org/abs/1403.2805</a> (also available as vignette). </p>"	"<pre>fromJSON(txt, simplifyVector = TRUE, simplifyDataFrame = simplifyVector,<br />   simplifyMatrix = simplifyVector, flatten = FALSE, ...)<br />toJSON(x, dataframe = c('rows', 'columns', 'values'), matrix = c('rowmajor',<br />   'columnmajor'), Date = c('ISO8601', 'epoch'), POSIXt = c('string',<br />   'ISO8601', 'epoch', 'mongo'), factor = c('string', 'integer'),<br />   complex = c('string', 'list'), raw = c('base64', 'hex', 'mongo'),<br />   null = c('list', 'null'), na = c('null', 'string'), auto_unbox = FALSE,<br />   digits = 4, pretty = FALSE, force = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>txt</code></td> <td> <p>a JSON string, URL or file</p> </td> </tr> <tr valign='top'> <td><code>simplifyVector</code></td> <td> <p>coerce JSON arrays containing only primitives into an atomic vector</p> </td> </tr> <tr valign='top'> <td><code>simplifyDataFrame</code></td> <td> <p>coerce JSON arrays containing only records (JSON objects) into a data frame</p> </td> </tr> <tr valign='top'> <td><code>simplifyMatrix</code></td> <td> <p>coerce JSON arrays containing vectors of equal mode and dimension into matrix or array</p> </td> </tr> <tr valign='top'> <td><code>flatten</code></td> <td> <p>automatically <code>flatten</code> nested data frames into a single non-nested data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments passed on to class specific <code>print</code> methods</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>the object to be encoded</p> </td> </tr> <tr valign='top'> <td><code>dataframe</code></td> <td> <p>how to encode data.frame objects: must be one of 'rows', 'columns' or 'values'</p> </td> </tr> <tr valign='top'> <td><code>matrix</code></td> <td> <p>how to encode matrices and higher dimensional arrays: must be one of 'rowmajor' or 'columnmajor'.</p> </td> </tr> <tr valign='top'> <td><code>Date</code></td> <td> <p>how to encode Date objects: must be one of 'ISO8601' or 'epoch'</p> </td> </tr> <tr valign='top'> <td><code>POSIXt</code></td> <td> <p>how to encode POSIXt (datetime) objects: must be one of 'string', 'ISO8601', 'epoch' or 'mongo'</p> </td> </tr> <tr valign='top'> <td><code>factor</code></td> <td> <p>how to encode factor objects: must be one of 'string' or 'integer'</p> </td> </tr> <tr valign='top'> <td><code>complex</code></td> <td> <p>how to encode complex numbers: must be one of 'string' or 'list'</p> </td> </tr> <tr valign='top'> <td><code>raw</code></td> <td> <p>how to encode raw objects: must be one of 'base64', 'hex' or 'mongo'</p> </td> </tr> <tr valign='top'> <td><code>null</code></td> <td> <p>how to encode NULL values within a list: must be one of 'null' or 'list'</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>how to print NA values: must be one of 'null' or 'string'. Defaults are class specific</p> </td> </tr> <tr valign='top'> <td><code>auto_unbox</code></td> <td> <p>automatically <code>unbox</code> all atomic vectors of length 1. It is usually safer to avoid this and instead use the <code>unbox</code> function to unbox individual elements. An exception is that objects of class <code>AsIs</code> (i.e. wrapped in <code>I()</code>) are not automatically unboxed. This is a way to mark single values as length-1 arrays.</p> </td> </tr> <tr valign='top'> <td><code>digits</code></td> <td> <p>max number of decimal digits to print for numeric values. Use <code>I()</code> to specify significant digits. Use <code>NA</code> for max precision.</p> </td> </tr> <tr valign='top'> <td><code>pretty</code></td> <td> <p>adds indentation whitespace to JSON output. Can be TRUE/FALSE or a number specifying the number of spaces to indent. See <code>prettify</code></p> </td> </tr> <tr valign='top'> <td><code>force</code></td> <td> <p>unclass/skip objects of classes with no defined JSON mapping</p> </td> </tr> </table> "	FALSE
"fromJSON"	"jsonlite"	"Convert R objects to/from JSON"	"<p>These functions are used to convert between JSON data and <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span> objects. The <code>toJSON</code> and <code>fromJSON</code> functions use a class based mapping, which follows conventions outlined in this paper:  <a href='https://arxiv.org/abs/1403.2805'>https://arxiv.org/abs/1403.2805</a> (also available as vignette). </p>"	"<pre>fromJSON(txt, simplifyVector = TRUE, simplifyDataFrame = simplifyVector,<br />   simplifyMatrix = simplifyVector, flatten = FALSE, ...)<br />toJSON(x, dataframe = c('rows', 'columns', 'values'), matrix = c('rowmajor',<br />   'columnmajor'), Date = c('ISO8601', 'epoch'), POSIXt = c('string',<br />   'ISO8601', 'epoch', 'mongo'), factor = c('string', 'integer'),<br />   complex = c('string', 'list'), raw = c('base64', 'hex', 'mongo'),<br />   null = c('list', 'null'), na = c('null', 'string'), auto_unbox = FALSE,<br />   digits = 4, pretty = FALSE, force = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>txt</code></td> <td> <p>a JSON string, URL or file</p> </td> </tr> <tr valign='top'> <td><code>simplifyVector</code></td> <td> <p>coerce JSON arrays containing only primitives into an atomic vector</p> </td> </tr> <tr valign='top'> <td><code>simplifyDataFrame</code></td> <td> <p>coerce JSON arrays containing only records (JSON objects) into a data frame</p> </td> </tr> <tr valign='top'> <td><code>simplifyMatrix</code></td> <td> <p>coerce JSON arrays containing vectors of equal mode and dimension into matrix or array</p> </td> </tr> <tr valign='top'> <td><code>flatten</code></td> <td> <p>automatically <code>flatten</code> nested data frames into a single non-nested data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments passed on to class specific <code>print</code> methods</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>the object to be encoded</p> </td> </tr> <tr valign='top'> <td><code>dataframe</code></td> <td> <p>how to encode data.frame objects: must be one of 'rows', 'columns' or 'values'</p> </td> </tr> <tr valign='top'> <td><code>matrix</code></td> <td> <p>how to encode matrices and higher dimensional arrays: must be one of 'rowmajor' or 'columnmajor'.</p> </td> </tr> <tr valign='top'> <td><code>Date</code></td> <td> <p>how to encode Date objects: must be one of 'ISO8601' or 'epoch'</p> </td> </tr> <tr valign='top'> <td><code>POSIXt</code></td> <td> <p>how to encode POSIXt (datetime) objects: must be one of 'string', 'ISO8601', 'epoch' or 'mongo'</p> </td> </tr> <tr valign='top'> <td><code>factor</code></td> <td> <p>how to encode factor objects: must be one of 'string' or 'integer'</p> </td> </tr> <tr valign='top'> <td><code>complex</code></td> <td> <p>how to encode complex numbers: must be one of 'string' or 'list'</p> </td> </tr> <tr valign='top'> <td><code>raw</code></td> <td> <p>how to encode raw objects: must be one of 'base64', 'hex' or 'mongo'</p> </td> </tr> <tr valign='top'> <td><code>null</code></td> <td> <p>how to encode NULL values within a list: must be one of 'null' or 'list'</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>how to print NA values: must be one of 'null' or 'string'. Defaults are class specific</p> </td> </tr> <tr valign='top'> <td><code>auto_unbox</code></td> <td> <p>automatically <code>unbox</code> all atomic vectors of length 1. It is usually safer to avoid this and instead use the <code>unbox</code> function to unbox individual elements. An exception is that objects of class <code>AsIs</code> (i.e. wrapped in <code>I()</code>) are not automatically unboxed. This is a way to mark single values as length-1 arrays.</p> </td> </tr> <tr valign='top'> <td><code>digits</code></td> <td> <p>max number of decimal digits to print for numeric values. Use <code>I()</code> to specify significant digits. Use <code>NA</code> for max precision.</p> </td> </tr> <tr valign='top'> <td><code>pretty</code></td> <td> <p>adds indentation whitespace to JSON output. Can be TRUE/FALSE or a number specifying the number of spaces to indent. See <code>prettify</code></p> </td> </tr> <tr valign='top'> <td><code>force</code></td> <td> <p>unclass/skip objects of classes with no defined JSON mapping</p> </td> </tr> </table> "	FALSE
"prettify"	"jsonlite"	"Prettify or minify a JSON string"	"<p>Prettify adds indentation to a JSON string; minify removes all indentation/whitespace. </p>"	"<pre>prettify(txt, indent = 4)<br />minify(txt) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>txt</code></td> <td> <p>JSON string</p> </td> </tr> <tr valign='top'> <td><code>indent</code></td> <td> <p>number of spaces to indent</p> </td> </tr> </table> "	FALSE
"prettify"	"jsonlite"	"Prettify or minify a JSON string"	"<p>Prettify adds indentation to a JSON string; minify removes all indentation/whitespace. </p>"	"<pre>prettify(txt, indent = 4)<br />minify(txt) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>txt</code></td> <td> <p>JSON string</p> </td> </tr> <tr valign='top'> <td><code>indent</code></td> <td> <p>number of spaces to indent</p> </td> </tr> </table> "	FALSE
"prettify"	"jsonlite"	"Prettify or minify a JSON string"	"<p>Prettify adds indentation to a JSON string; minify removes all indentation/whitespace. </p>"	"<pre>prettify(txt, indent = 4)<br />minify(txt) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>txt</code></td> <td> <p>JSON string</p> </td> </tr> <tr valign='top'> <td><code>indent</code></td> <td> <p>number of spaces to indent</p> </td> </tr> </table> "	FALSE
"rbind.pages"	"jsonlite"	"Combine pages into a single data frame"	"<p>The <code>rbind.pages</code> function is used to combine a list of data frames into a single data frame. This is often needed when working with a JSON API that limits the amount of data per request. If we need more data than what fits in a single request, we need to perform multiple requests that each retrieve a fragment of data, not unlike pages in a book. In practice this is often implemented using a <code>page</code> parameter in the API. The <code>rbind.pages</code> function can be used to combine these pages back into a single dataset. </p>"	"<pre>## S3 method for class 'pages' rbind(pages) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>pages</code></td> <td> <p>a list of data frames, each representing a <em>page</em> of data</p> </td> </tr></table> "	FALSE
"read_json"	"jsonlite"	"Read/write JSON"	"<p>Convenience wrappers around toJSON and fromJSON to read and write directly to/from disk. </p>"	"<pre>read_json(path, simplifyVector = FALSE, ...)<br />write_json(x, path, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>path</code></td> <td> <p>file on disk</p> </td> </tr> <tr valign='top'> <td><code>simplifyVector</code></td> <td> <p>simplifies nested lists into vectors and data frames. See fromJSON.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments passed to toJSON or fromJSON</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an object to be serialized to JSON</p> </td> </tr> </table> "	FALSE
"serializeJSON"	"jsonlite"	"serialize R objects to JSON"	"<p>The <code>serializeJSON</code> and <code>unserializeJSON</code> functions convert between <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span> objects to JSON data. Instead of using a class based mapping like <code>toJSON</code> and <code>fromJSON</code>, the serialize functions base the encoding schema on the storage type, and capture all data and attributes from any object. Thereby the object can be restored almost perfectly from its JSON representation, but the resulting JSON output is very verbose. Apart from environments, all standard storage types are supported. </p>"	"<pre>serializeJSON(x, digits = 8, pretty = FALSE)<br />unserializeJSON(txt) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span> object to be serialized</p> </td> </tr> <tr valign='top'> <td><code>digits</code></td> <td> <p>max number of digits (after the dot) to print for numeric values</p> </td> </tr> <tr valign='top'> <td><code>pretty</code></td> <td> <p>add indentation/whitespace to JSON output. See <code>prettify</code></p> </td> </tr> <tr valign='top'> <td><code>txt</code></td> <td> <p>a JSON string which was created using <code>serializeJSON</code></p> </td> </tr> </table> "	FALSE
"stream_in"	"jsonlite"	"Streaming JSON input/output"	"<p>The <code>stream_in</code> and <code>stream_out</code> functions implement line-by-line processing of JSON data over a <code>connection</code>, such as a socket, url, file or pipe. JSON streaming requires the <a href='http://ndjson.org'>ndjson</a> format, which slightly differs from <code>fromJSON</code> and <code>toJSON</code>, see details. </p>"	"<pre>stream_in(con, handler = NULL, pagesize = 500, verbose = TRUE, ...)<br />stream_out(x, con = stdout(), pagesize = 500, verbose = TRUE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>con</code></td> <td> <p>a <code>connection</code> object. If the connection is not open, <code>stream_in</code> and <code>stream_out</code> will automatically open and later close (and destroy) the connection. See details.</p> </td> </tr> <tr valign='top'> <td><code>handler</code></td> <td> <p>a custom function that is called on each page of JSON data. If not specified, the default handler stores all pages and binds them into a single data frame that will be returned by <code>stream_in</code>. See details.</p> </td> </tr> <tr valign='top'> <td><code>pagesize</code></td> <td> <p>number of lines to read/write from/to the connection per iteration.</p> </td> </tr> <tr valign='top'> <td><code>verbose</code></td> <td> <p>print some information on what is going on.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments for <code>fromJSON</code> and <code>toJSON</code> that control JSON formatting/parsing where applicable. Use with caution.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>object to be streamed out. Currently only data frames are supported.</p> </td> </tr> </table> "	FALSE
"stream_in"	"jsonlite"	"Streaming JSON input/output"	"<p>The <code>stream_in</code> and <code>stream_out</code> functions implement line-by-line processing of JSON data over a <code>connection</code>, such as a socket, url, file or pipe. JSON streaming requires the <a href='http://ndjson.org'>ndjson</a> format, which slightly differs from <code>fromJSON</code> and <code>toJSON</code>, see details. </p>"	"<pre>stream_in(con, handler = NULL, pagesize = 500, verbose = TRUE, ...)<br />stream_out(x, con = stdout(), pagesize = 500, verbose = TRUE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>con</code></td> <td> <p>a <code>connection</code> object. If the connection is not open, <code>stream_in</code> and <code>stream_out</code> will automatically open and later close (and destroy) the connection. See details.</p> </td> </tr> <tr valign='top'> <td><code>handler</code></td> <td> <p>a custom function that is called on each page of JSON data. If not specified, the default handler stores all pages and binds them into a single data frame that will be returned by <code>stream_in</code>. See details.</p> </td> </tr> <tr valign='top'> <td><code>pagesize</code></td> <td> <p>number of lines to read/write from/to the connection per iteration.</p> </td> </tr> <tr valign='top'> <td><code>verbose</code></td> <td> <p>print some information on what is going on.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments for <code>fromJSON</code> and <code>toJSON</code> that control JSON formatting/parsing where applicable. Use with caution.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>object to be streamed out. Currently only data frames are supported.</p> </td> </tr> </table> "	FALSE
"stream_in"	"jsonlite"	"Streaming JSON input/output"	"<p>The <code>stream_in</code> and <code>stream_out</code> functions implement line-by-line processing of JSON data over a <code>connection</code>, such as a socket, url, file or pipe. JSON streaming requires the <a href='http://ndjson.org'>ndjson</a> format, which slightly differs from <code>fromJSON</code> and <code>toJSON</code>, see details. </p>"	"<pre>stream_in(con, handler = NULL, pagesize = 500, verbose = TRUE, ...)<br />stream_out(x, con = stdout(), pagesize = 500, verbose = TRUE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>con</code></td> <td> <p>a <code>connection</code> object. If the connection is not open, <code>stream_in</code> and <code>stream_out</code> will automatically open and later close (and destroy) the connection. See details.</p> </td> </tr> <tr valign='top'> <td><code>handler</code></td> <td> <p>a custom function that is called on each page of JSON data. If not specified, the default handler stores all pages and binds them into a single data frame that will be returned by <code>stream_in</code>. See details.</p> </td> </tr> <tr valign='top'> <td><code>pagesize</code></td> <td> <p>number of lines to read/write from/to the connection per iteration.</p> </td> </tr> <tr valign='top'> <td><code>verbose</code></td> <td> <p>print some information on what is going on.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments for <code>fromJSON</code> and <code>toJSON</code> that control JSON formatting/parsing where applicable. Use with caution.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>object to be streamed out. Currently only data frames are supported.</p> </td> </tr> </table> "	FALSE
"fromJSON"	"jsonlite"	"Convert R objects to/from JSON"	"<p>These functions are used to convert between JSON data and <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span> objects. The <code>toJSON</code> and <code>fromJSON</code> functions use a class based mapping, which follows conventions outlined in this paper:  <a href='https://arxiv.org/abs/1403.2805'>https://arxiv.org/abs/1403.2805</a> (also available as vignette). </p>"	"<pre>fromJSON(txt, simplifyVector = TRUE, simplifyDataFrame = simplifyVector,<br />   simplifyMatrix = simplifyVector, flatten = FALSE, ...)<br />toJSON(x, dataframe = c('rows', 'columns', 'values'), matrix = c('rowmajor',<br />   'columnmajor'), Date = c('ISO8601', 'epoch'), POSIXt = c('string',<br />   'ISO8601', 'epoch', 'mongo'), factor = c('string', 'integer'),<br />   complex = c('string', 'list'), raw = c('base64', 'hex', 'mongo'),<br />   null = c('list', 'null'), na = c('null', 'string'), auto_unbox = FALSE,<br />   digits = 4, pretty = FALSE, force = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>txt</code></td> <td> <p>a JSON string, URL or file</p> </td> </tr> <tr valign='top'> <td><code>simplifyVector</code></td> <td> <p>coerce JSON arrays containing only primitives into an atomic vector</p> </td> </tr> <tr valign='top'> <td><code>simplifyDataFrame</code></td> <td> <p>coerce JSON arrays containing only records (JSON objects) into a data frame</p> </td> </tr> <tr valign='top'> <td><code>simplifyMatrix</code></td> <td> <p>coerce JSON arrays containing vectors of equal mode and dimension into matrix or array</p> </td> </tr> <tr valign='top'> <td><code>flatten</code></td> <td> <p>automatically <code>flatten</code> nested data frames into a single non-nested data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments passed on to class specific <code>print</code> methods</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>the object to be encoded</p> </td> </tr> <tr valign='top'> <td><code>dataframe</code></td> <td> <p>how to encode data.frame objects: must be one of 'rows', 'columns' or 'values'</p> </td> </tr> <tr valign='top'> <td><code>matrix</code></td> <td> <p>how to encode matrices and higher dimensional arrays: must be one of 'rowmajor' or 'columnmajor'.</p> </td> </tr> <tr valign='top'> <td><code>Date</code></td> <td> <p>how to encode Date objects: must be one of 'ISO8601' or 'epoch'</p> </td> </tr> <tr valign='top'> <td><code>POSIXt</code></td> <td> <p>how to encode POSIXt (datetime) objects: must be one of 'string', 'ISO8601', 'epoch' or 'mongo'</p> </td> </tr> <tr valign='top'> <td><code>factor</code></td> <td> <p>how to encode factor objects: must be one of 'string' or 'integer'</p> </td> </tr> <tr valign='top'> <td><code>complex</code></td> <td> <p>how to encode complex numbers: must be one of 'string' or 'list'</p> </td> </tr> <tr valign='top'> <td><code>raw</code></td> <td> <p>how to encode raw objects: must be one of 'base64', 'hex' or 'mongo'</p> </td> </tr> <tr valign='top'> <td><code>null</code></td> <td> <p>how to encode NULL values within a list: must be one of 'null' or 'list'</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>how to print NA values: must be one of 'null' or 'string'. Defaults are class specific</p> </td> </tr> <tr valign='top'> <td><code>auto_unbox</code></td> <td> <p>automatically <code>unbox</code> all atomic vectors of length 1. It is usually safer to avoid this and instead use the <code>unbox</code> function to unbox individual elements. An exception is that objects of class <code>AsIs</code> (i.e. wrapped in <code>I()</code>) are not automatically unboxed. This is a way to mark single values as length-1 arrays.</p> </td> </tr> <tr valign='top'> <td><code>digits</code></td> <td> <p>max number of decimal digits to print for numeric values. Use <code>I()</code> to specify significant digits. Use <code>NA</code> for max precision.</p> </td> </tr> <tr valign='top'> <td><code>pretty</code></td> <td> <p>adds indentation whitespace to JSON output. Can be TRUE/FALSE or a number specifying the number of spaces to indent. See <code>prettify</code></p> </td> </tr> <tr valign='top'> <td><code>force</code></td> <td> <p>unclass/skip objects of classes with no defined JSON mapping</p> </td> </tr> </table> "	FALSE
"fromJSON"	"jsonlite"	"Convert R objects to/from JSON"	"<p>These functions are used to convert between JSON data and <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span> objects. The <code>toJSON</code> and <code>fromJSON</code> functions use a class based mapping, which follows conventions outlined in this paper:  <a href='https://arxiv.org/abs/1403.2805'>https://arxiv.org/abs/1403.2805</a> (also available as vignette). </p>"	"<pre>fromJSON(txt, simplifyVector = TRUE, simplifyDataFrame = simplifyVector,<br />   simplifyMatrix = simplifyVector, flatten = FALSE, ...)<br />toJSON(x, dataframe = c('rows', 'columns', 'values'), matrix = c('rowmajor',<br />   'columnmajor'), Date = c('ISO8601', 'epoch'), POSIXt = c('string',<br />   'ISO8601', 'epoch', 'mongo'), factor = c('string', 'integer'),<br />   complex = c('string', 'list'), raw = c('base64', 'hex', 'mongo'),<br />   null = c('list', 'null'), na = c('null', 'string'), auto_unbox = FALSE,<br />   digits = 4, pretty = FALSE, force = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>txt</code></td> <td> <p>a JSON string, URL or file</p> </td> </tr> <tr valign='top'> <td><code>simplifyVector</code></td> <td> <p>coerce JSON arrays containing only primitives into an atomic vector</p> </td> </tr> <tr valign='top'> <td><code>simplifyDataFrame</code></td> <td> <p>coerce JSON arrays containing only records (JSON objects) into a data frame</p> </td> </tr> <tr valign='top'> <td><code>simplifyMatrix</code></td> <td> <p>coerce JSON arrays containing vectors of equal mode and dimension into matrix or array</p> </td> </tr> <tr valign='top'> <td><code>flatten</code></td> <td> <p>automatically <code>flatten</code> nested data frames into a single non-nested data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments passed on to class specific <code>print</code> methods</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>the object to be encoded</p> </td> </tr> <tr valign='top'> <td><code>dataframe</code></td> <td> <p>how to encode data.frame objects: must be one of 'rows', 'columns' or 'values'</p> </td> </tr> <tr valign='top'> <td><code>matrix</code></td> <td> <p>how to encode matrices and higher dimensional arrays: must be one of 'rowmajor' or 'columnmajor'.</p> </td> </tr> <tr valign='top'> <td><code>Date</code></td> <td> <p>how to encode Date objects: must be one of 'ISO8601' or 'epoch'</p> </td> </tr> <tr valign='top'> <td><code>POSIXt</code></td> <td> <p>how to encode POSIXt (datetime) objects: must be one of 'string', 'ISO8601', 'epoch' or 'mongo'</p> </td> </tr> <tr valign='top'> <td><code>factor</code></td> <td> <p>how to encode factor objects: must be one of 'string' or 'integer'</p> </td> </tr> <tr valign='top'> <td><code>complex</code></td> <td> <p>how to encode complex numbers: must be one of 'string' or 'list'</p> </td> </tr> <tr valign='top'> <td><code>raw</code></td> <td> <p>how to encode raw objects: must be one of 'base64', 'hex' or 'mongo'</p> </td> </tr> <tr valign='top'> <td><code>null</code></td> <td> <p>how to encode NULL values within a list: must be one of 'null' or 'list'</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>how to print NA values: must be one of 'null' or 'string'. Defaults are class specific</p> </td> </tr> <tr valign='top'> <td><code>auto_unbox</code></td> <td> <p>automatically <code>unbox</code> all atomic vectors of length 1. It is usually safer to avoid this and instead use the <code>unbox</code> function to unbox individual elements. An exception is that objects of class <code>AsIs</code> (i.e. wrapped in <code>I()</code>) are not automatically unboxed. This is a way to mark single values as length-1 arrays.</p> </td> </tr> <tr valign='top'> <td><code>digits</code></td> <td> <p>max number of decimal digits to print for numeric values. Use <code>I()</code> to specify significant digits. Use <code>NA</code> for max precision.</p> </td> </tr> <tr valign='top'> <td><code>pretty</code></td> <td> <p>adds indentation whitespace to JSON output. Can be TRUE/FALSE or a number specifying the number of spaces to indent. See <code>prettify</code></p> </td> </tr> <tr valign='top'> <td><code>force</code></td> <td> <p>unclass/skip objects of classes with no defined JSON mapping</p> </td> </tr> </table> "	FALSE
"unbox"	"jsonlite"	"Unbox a vector or data frame"	"<p>This function marks an atomic vector or data frame as a <a href='http://en.wikipedia.org/wiki/Singleton_(mathematics)'>singleton</a>, i.e. a set with exactly 1 element. Thereby, the value will not turn into an <code>array</code> when encoded into JSON. This can only be done for atomic vectors of length 1, or data frames with exactly 1 row. To automatically unbox all vectors of length 1 within an object, use the <code>auto_unbox</code> argument in <code>toJSON</code>. </p>"	"<pre>unbox(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>atomic vector of length 1, or data frame with 1 row.</p> </td> </tr></table> "	FALSE
"serializeJSON"	"jsonlite"	"serialize R objects to JSON"	"<p>The <code>serializeJSON</code> and <code>unserializeJSON</code> functions convert between <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span> objects to JSON data. Instead of using a class based mapping like <code>toJSON</code> and <code>fromJSON</code>, the serialize functions base the encoding schema on the storage type, and capture all data and attributes from any object. Thereby the object can be restored almost perfectly from its JSON representation, but the resulting JSON output is very verbose. Apart from environments, all standard storage types are supported. </p>"	"<pre>serializeJSON(x, digits = 8, pretty = FALSE)<br />unserializeJSON(txt) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an <span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span> object to be serialized</p> </td> </tr> <tr valign='top'> <td><code>digits</code></td> <td> <p>max number of digits (after the dot) to print for numeric values</p> </td> </tr> <tr valign='top'> <td><code>pretty</code></td> <td> <p>add indentation/whitespace to JSON output. See <code>prettify</code></p> </td> </tr> <tr valign='top'> <td><code>txt</code></td> <td> <p>a JSON string which was created using <code>serializeJSON</code></p> </td> </tr> </table> "	FALSE
"validate"	"jsonlite"	"Validate JSON"	"<p>Test if a string contains valid JSON. Characters vectors will be collapsed into a single string. </p>"	"<pre>validate(txt) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>txt</code></td> <td> <p>JSON string</p> </td> </tr></table> "	FALSE
"read_json"	"jsonlite"	"Read/write JSON"	"<p>Convenience wrappers around toJSON and fromJSON to read and write directly to/from disk. </p>"	"<pre>read_json(path, simplifyVector = FALSE, ...)<br />write_json(x, path, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>path</code></td> <td> <p>file on disk</p> </td> </tr> <tr valign='top'> <td><code>simplifyVector</code></td> <td> <p>simplifies nested lists into vectors and data frames. See fromJSON.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments passed to toJSON or fromJSON</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an object to be serialized to JSON</p> </td> </tr> </table> "	FALSE
"lubridate-package"	"lubridate"	"Dates and times made easy with lubridate"	"<p>Lubridate provides tools that make it easier to parse and manipulate dates. These tools are grouped below by common purpose. More information about each function can be found in its help documentation. </p>"	NA	NA	FALSE
"mplus"	"lubridate"	"Add and subtract months to a date without exceeding the last day of the new month"	"<p>Adding months frustrates basic arithmetic because consecutive months have different lengths. With other elements, it is helpful for arithmetic to perform automatic roll over. For example, 12:00:00 + 61 seconds becomes 12:01:01. However, people often prefer that this behavior NOT occur with months. For example, we sometimes want January 31 + 1 month = February 28 and not March 3. %m+% performs this type of arithmetic. Date %m+% months(n) always returns a date in the nth month after Date. If the new date would usually spill over into the n + 1th month, %m+% will return the last day of the nth month (<code>rollback</code>. Date %m-% months(n) always returns a date in the nth month before Date. </p> <p><code>add_with_rollback</code> provides additional functionality to %m+% and %m-%. It allows rollback to first day of the month instead of the last day of the previous month and controls whether HMS component of the end date is preserved or not. </p>"	"<pre>e1 %m+% e2<br />add_with_rollback(e1, e2, roll_to_first = FALSE, preserve_hms = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>e1</code></td> <td> <p>A period or a date-time object of class <code>POSIXlt</code>, <code>POSIXct</code> or <code>Date</code>.</p> </td> </tr> <tr valign='top'> <td><code>e2</code></td> <td> <p>A period or a date-time object of class <code>POSIXlt</code>, <code>POSIXct</code> or <code>Date</code>. Note that one of e1 and e2 must be a period and the other a date-time object.</p> </td> </tr> <tr valign='top'> <td><code>roll_to_first</code></td> <td> <p>rollback to the first day of the month instead of the last day of the previous month (passed to <code>rollback</code>)</p> </td> </tr> <tr valign='top'> <td><code>preserve_hms</code></td> <td> <p>retains the same hour, minute, and second information? If FALSE, the new date will be at 00:00:00 (passed to <code>rollback</code>)</p> </td> </tr> </table> "	FALSE
"am"	"lubridate"	"Does date time occur in the am or pm?"	"<p>Does date time occur in the am or pm? </p>"	"<pre>am(x)<br />pm(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr></table> "	FALSE
"as.duration"	"lubridate"	"Change an object to a duration."	"<p>as.duration changes Interval, Period and numeric class objects to Duration objects. Numeric objects are changed to Duration objects with the seconds unit equal to the numeric value. </p>"	"<pre>as.duration(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Object to be coerced to a duration</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Parameters passed to other methods. Currently unused.</p> </td> </tr> </table> "	FALSE
"as.interval"	"lubridate"	"Change an object to an interval."	"<p>as.interval changes difftime, Duration, Period and numeric class objects to intervals that begin at the specified date-time. Numeric objects are first coerced to timespans equal to the numeric value in seconds. </p>"	"<pre>as.interval(x, start, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a duration, difftime, period, or numeric object that describes the length of the interval</p> </td> </tr> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date object that describes when the interval begins</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass to as.interval</p> </td> </tr> </table> "	FALSE
"as.period"	"lubridate"	"Change an object to a period."	"<p>as.period changes Interval, Duration, difftime and numeric class objects to Period class objects with the specified units. </p>"	"<pre>as.period(x, unit, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>an interval, difftime, or numeric object</p> </td> </tr> <tr valign='top'> <td><code>unit</code></td> <td> <p>A character string that specifies which time units to build period in. unit is only implemented for the as.period.numeric method and the as.period.interval method. For as.period.interval, as.period will convert intervals to units no larger than the specified unit.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass to as.period</p> </td> </tr> </table> "	FALSE
"as_date"	"lubridate"	"Convert an object to a date or date-time"	"<p>Convert an object to a date or date-time </p>"	"<pre>as_date(x, ...)<br />as_datetime(x, ...)<br />## S4 method for signature 'POSIXt' as_date(x, tz = NULL)<br />## S4 method for signature 'numeric' as_date(x, origin = lubridate::origin)<br />## S4 method for signature 'POSIXt' as_datetime(x, tz = 'UTC')<br />## S4 method for signature 'numeric' as_datetime(x, origin = lubridate::origin, tz = 'UTC')<br />## S4 method for signature 'ANY' as_datetime(x, tz = 'UTC') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of <code>POSIXt</code>, numeric or character objects</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>further arguments to be passed to specific methods (see above).</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a time zone name (default: time zone of the POSIXt object <code>x</code>). See <code>OlsonNames</code>.</p> </td> </tr> <tr valign='top'> <td><code>origin</code></td> <td> <p>a Date object, or something which can be coerced by <code>as.Date(origin, ...)</code> to such an object (default: the Unix epoch of '1970-01-01'). Note that in this instance, <code>x</code> is assumed to reflect the number of days since <code>origin</code> at <code>'UTC'</code>.</p> </td> </tr> </table> "	FALSE
"as_date"	"lubridate"	"Convert an object to a date or date-time"	"<p>Convert an object to a date or date-time </p>"	"<pre>as_date(x, ...)<br />as_datetime(x, ...)<br />## S4 method for signature 'POSIXt' as_date(x, tz = NULL)<br />## S4 method for signature 'numeric' as_date(x, origin = lubridate::origin)<br />## S4 method for signature 'POSIXt' as_datetime(x, tz = 'UTC')<br />## S4 method for signature 'numeric' as_datetime(x, origin = lubridate::origin, tz = 'UTC')<br />## S4 method for signature 'ANY' as_datetime(x, tz = 'UTC') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of <code>POSIXt</code>, numeric or character objects</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>further arguments to be passed to specific methods (see above).</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a time zone name (default: time zone of the POSIXt object <code>x</code>). See <code>OlsonNames</code>.</p> </td> </tr> <tr valign='top'> <td><code>origin</code></td> <td> <p>a Date object, or something which can be coerced by <code>as.Date(origin, ...)</code> to such an object (default: the Unix epoch of '1970-01-01'). Note that in this instance, <code>x</code> is assumed to reflect the number of days since <code>origin</code> at <code>'UTC'</code>.</p> </td> </tr> </table> "	FALSE
"round_date"	"lubridate"	"Round, floor and ceiling methods for date-time objects."	"<p>Rounding to the nearest unit or multiple of a unit are supported. All meaningfull specifications in English language are supported - secs, min, mins, 2 minutes, 3 years etc. <br><code>round_date</code> takes a date-time object and rounds it to the nearest value of the specified time unit. For rounding date-times which is exactly halfway between two consecutive units, the convention is to round up. Note that this is in line with the behavior of R's base round.POSIXt function but does not follow the convention of the base round function which 'rounds to the even digit' per IEC 60559. <br><code>floor_date</code> takes a date-time object and rounds it down to the nearest boundary of the specified  time unit. <br><code>ceiling_date</code> takes a date-time object and rounds it up to the nearest boundary of the specified time unit. </p>"	"<pre>round_date(x, unit = 'second')<br />floor_date(x, unit = 'seconds')<br />ceiling_date(x, unit = 'seconds', change_on_boundary = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of date-time objects</p> </td> </tr> <tr valign='top'> <td><code>unit</code></td> <td> <p>a character string specifying the time unit or a multiple of a unit to be rounded to. Valid base units are second, minute, hour, day, week, month, bimonth, quarter, halfyear, or year. Arbitrary unique English abbreviations as in <code>period</code> constructor are also supported. Rounding to multiple of units (except weeks) is supported from <code>v1.6.0</code>.</p> </td> </tr> <tr valign='top'> <td><code>change_on_boundary</code></td> <td> <p>If NULL (the default) don't change instants on the boundary (<code>ceiling_date(ymd_hms('2000-01-01 00:00:00'))</code> is <code>2000-01-01 00:00:00</code>), but round up <code>Date</code> objects to the next boundary (<code>ceiling_date(ymd('2000-01-01'), 'month')</code> is <code>'2000-02-01'</code>). When <code>TRUE</code>, instants on the boundary are rounded up to the next boundary. When <code>FALSE</code>, date-time on the boundary are never rounded up (this was the default for <code>lubridate</code> prior to <code>v1.6.0</code>. See section <code>Rounding Up Date Objects</code> below for more details.</p> </td> </tr> </table> "	FALSE
"date"	"lubridate"	"Get/set Date component of a date-time."	"<p>Date-time must be a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>date(x)<br />date(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>an object for which the <code>date()</code> function is defined</p> </td> </tr> </table> "	FALSE
"date"	"lubridate"	"Get/set Date component of a date-time."	"<p>Date-time must be a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>date(x)<br />date(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>an object for which the <code>date()</code> function is defined</p> </td> </tr> </table> "	FALSE
"DateUpdate"	"lubridate"	"Changes the components of a date object"	"<p><code>update.Date</code> and <code>update.POSIXt</code> return a date with the specified elements updated.  Elements not specified will be left unaltered. update.Date and update.POSIXt do not add the specified values to the existing date, they substitute them for the appropriate parts of the existing date. </p>"	"<pre>## S3 method for class 'POSIXt' update(object, ..., simple = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>object</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>named arguments: years, months, ydays, wdays, mdays, days, hours, minutes, seconds, tzs (time zone compnent)</p> </td> </tr> <tr valign='top'> <td><code>simple</code></td> <td> <p>logical, passed to <code>fit_to_timeline</code>. If TRUE a simple fit to time line is performed and no NA are produced for invalid dates. Invalid dates are converted to meaningful dates by extrapolating the timezones.</p> </td> </tr> </table> "	FALSE
"date_decimal"	"lubridate"	"Converts a decimal to a date."	"<p>Converts a decimal to a date. </p>"	"<pre>date_decimal(decimal, tz = 'UTC') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>decimal</code></td> <td> <p>a numeric object</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>the time zone required</p> </td> </tr> </table> "	FALSE
"day"	"lubridate"	"Get/set days component of a date-time."	"<p>Get/set days component of a date-time. </p>"	"<pre>day(x)<br />mday(x)<br />wday(x, label = FALSE, abbr = TRUE)<br />qday(x)<br />yday(x)<br />day(x) &lt;- value<br />mday(x) &lt;- value<br />qday(x) &lt;- value<br />wday(x) &lt;- value<br />yday(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. Only available for wday. TRUE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' FALSE will display the day of the week as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. Only available for wday. FALSE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' TRUE will display an abbreviated version of the label, such as 'Sun'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"day"	"lubridate"	"Get/set days component of a date-time."	"<p>Get/set days component of a date-time. </p>"	"<pre>day(x)<br />mday(x)<br />wday(x, label = FALSE, abbr = TRUE)<br />qday(x)<br />yday(x)<br />day(x) &lt;- value<br />mday(x) &lt;- value<br />qday(x) &lt;- value<br />wday(x) &lt;- value<br />yday(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. Only available for wday. TRUE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' FALSE will display the day of the week as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. Only available for wday. FALSE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' TRUE will display an abbreviated version of the label, such as 'Sun'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"days_in_month"	"lubridate"	"Get the number of days in the month of a date-time."	"<p>Date-time must be a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>days_in_month(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr></table> "	FALSE
"quick_durations"	"lubridate"	"Quickly create duration objects."	"<p>Quickly create Duration objects for easy date-time manipulation. The units of the duration created depend on the name of the function called. For Duration objects, units are equal to their most common lengths in seconds (i.e. minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800, years = 31536000). </p>"	"<pre>dseconds(x = 1)<br />dminutes(x = 1)<br />dhours(x = 1)<br />ddays(x = 1)<br />dweeks(x = 1)<br />dyears(x = 1)<br />dmilliseconds(x = 1)<br />dmicroseconds(x = 1)<br />dnanoseconds(x = 1)<br />dpicoseconds(x = 1) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the duration.</p> </td> </tr></table> "	FALSE
"decimal_date"	"lubridate"	"Converts a date to a decimal of its year."	"<p>Converts a date to a decimal of its year. </p>"	"<pre>decimal_date(date) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>date</code></td> <td> <p>a POSIXt or Date object</p> </td> </tr></table> "	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"quick_durations"	"lubridate"	"Quickly create duration objects."	"<p>Quickly create Duration objects for easy date-time manipulation. The units of the duration created depend on the name of the function called. For Duration objects, units are equal to their most common lengths in seconds (i.e. minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800, years = 31536000). </p>"	"<pre>dseconds(x = 1)<br />dminutes(x = 1)<br />dhours(x = 1)<br />ddays(x = 1)<br />dweeks(x = 1)<br />dyears(x = 1)<br />dmilliseconds(x = 1)<br />dmicroseconds(x = 1)<br />dnanoseconds(x = 1)<br />dpicoseconds(x = 1) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the duration.</p> </td> </tr></table> "	FALSE
"quick_durations"	"lubridate"	"Quickly create duration objects."	"<p>Quickly create Duration objects for easy date-time manipulation. The units of the duration created depend on the name of the function called. For Duration objects, units are equal to their most common lengths in seconds (i.e. minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800, years = 31536000). </p>"	"<pre>dseconds(x = 1)<br />dminutes(x = 1)<br />dhours(x = 1)<br />ddays(x = 1)<br />dweeks(x = 1)<br />dyears(x = 1)<br />dmilliseconds(x = 1)<br />dmicroseconds(x = 1)<br />dnanoseconds(x = 1)<br />dpicoseconds(x = 1) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the duration.</p> </td> </tr></table> "	FALSE
"quick_durations"	"lubridate"	"Quickly create duration objects."	"<p>Quickly create Duration objects for easy date-time manipulation. The units of the duration created depend on the name of the function called. For Duration objects, units are equal to their most common lengths in seconds (i.e. minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800, years = 31536000). </p>"	"<pre>dseconds(x = 1)<br />dminutes(x = 1)<br />dhours(x = 1)<br />ddays(x = 1)<br />dweeks(x = 1)<br />dyears(x = 1)<br />dmilliseconds(x = 1)<br />dmicroseconds(x = 1)<br />dnanoseconds(x = 1)<br />dpicoseconds(x = 1) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the duration.</p> </td> </tr></table> "	FALSE
"quick_durations"	"lubridate"	"Quickly create duration objects."	"<p>Quickly create Duration objects for easy date-time manipulation. The units of the duration created depend on the name of the function called. For Duration objects, units are equal to their most common lengths in seconds (i.e. minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800, years = 31536000). </p>"	"<pre>dseconds(x = 1)<br />dminutes(x = 1)<br />dhours(x = 1)<br />ddays(x = 1)<br />dweeks(x = 1)<br />dyears(x = 1)<br />dmilliseconds(x = 1)<br />dmicroseconds(x = 1)<br />dnanoseconds(x = 1)<br />dpicoseconds(x = 1) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the duration.</p> </td> </tr></table> "	FALSE
"ymd"	"lubridate"	"Parse dates according to the order in that year, month, and day elementsappear in the input vector."	"<p>Transforms dates stored in character and numeric vectors to Date or POSIXct objects (see <code>tz</code> argument). These functions recognize arbitrary non-digit separators as well as no separator. As long as the order of formats is correct, these functions will parse dates correctly even when the input vectors contain differently formatted dates. See examples. </p>"	"<pre>ymd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />myd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dym(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />yq(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character or numeric vector of suspected dates</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>Time zone indicator. If NULL (default) a Date object is returned. Otherwise a POSIXct with time zone attribute set to <code>tz</code>.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer. Number of formats that can be truncated.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"quick_durations"	"lubridate"	"Quickly create duration objects."	"<p>Quickly create Duration objects for easy date-time manipulation. The units of the duration created depend on the name of the function called. For Duration objects, units are equal to their most common lengths in seconds (i.e. minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800, years = 31536000). </p>"	"<pre>dseconds(x = 1)<br />dminutes(x = 1)<br />dhours(x = 1)<br />ddays(x = 1)<br />dweeks(x = 1)<br />dyears(x = 1)<br />dmilliseconds(x = 1)<br />dmicroseconds(x = 1)<br />dnanoseconds(x = 1)<br />dpicoseconds(x = 1) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the duration.</p> </td> </tr></table> "	FALSE
"quick_durations"	"lubridate"	"Quickly create duration objects."	"<p>Quickly create Duration objects for easy date-time manipulation. The units of the duration created depend on the name of the function called. For Duration objects, units are equal to their most common lengths in seconds (i.e. minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800, years = 31536000). </p>"	"<pre>dseconds(x = 1)<br />dminutes(x = 1)<br />dhours(x = 1)<br />ddays(x = 1)<br />dweeks(x = 1)<br />dyears(x = 1)<br />dmilliseconds(x = 1)<br />dmicroseconds(x = 1)<br />dnanoseconds(x = 1)<br />dpicoseconds(x = 1) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the duration.</p> </td> </tr></table> "	FALSE
"quick_durations"	"lubridate"	"Quickly create duration objects."	"<p>Quickly create Duration objects for easy date-time manipulation. The units of the duration created depend on the name of the function called. For Duration objects, units are equal to their most common lengths in seconds (i.e. minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800, years = 31536000). </p>"	"<pre>dseconds(x = 1)<br />dminutes(x = 1)<br />dhours(x = 1)<br />ddays(x = 1)<br />dweeks(x = 1)<br />dyears(x = 1)<br />dmilliseconds(x = 1)<br />dmicroseconds(x = 1)<br />dnanoseconds(x = 1)<br />dpicoseconds(x = 1) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the duration.</p> </td> </tr></table> "	FALSE
"dst"	"lubridate"	"Get Daylight Savings Time indicator of a date-time."	"<p>Date-time must be a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>dst(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr></table> "	FALSE
"duration"	"lubridate"	"Create a duration object."	"<p><code>duration</code> creates a duration object with the specified values. Entries for different units are cumulative. durations display as the number of seconds in a time span. When this number is large, durations also display an estimate in larger units,; however, the underlying object is always recorded as a fixed number of seconds. For display and creation purposes, units are converted to seconds using their most common lengths in seconds. Minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800. Units larger than weeks are not used due to their variability. </p>"	"<pre>duration(num = NULL, units = 'seconds', ...)<br />is.duration(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>num</code></td> <td> <p>the number of time units to include in the duration. From v1.6.0 <code>num</code> can also be a character vector that specifies durations in a convenient shorthand format. All unambiguous name units and abbreviations are supported. See examples.</p> </td> </tr> <tr valign='top'> <td><code>units</code></td> <td> <p>a character string that specifies the type of units that num refers to. When <code>num</code> is character, this argument is ignored.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>a list of time units to be included in the duration and their amounts. Seconds, minutes, hours, days, and weeks are supported.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> </table> "	FALSE
"Duration-class"	"lubridate"	"Duration class"	"<p>Duration is an S4 class that extends the <code>Timespan-class</code> class. Durations record the exact number of seconds in a time span. They measure the exact passage of time but do not always align with measurements made in larger units of time such as hours, months and years. This is because the exact length of larger time units can be affected by conventions such as leap years and Daylight Savings Time. </p>"	NA	NA	FALSE
"quick_durations"	"lubridate"	"Quickly create duration objects."	"<p>Quickly create Duration objects for easy date-time manipulation. The units of the duration created depend on the name of the function called. For Duration objects, units are equal to their most common lengths in seconds (i.e. minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800, years = 31536000). </p>"	"<pre>dseconds(x = 1)<br />dminutes(x = 1)<br />dhours(x = 1)<br />ddays(x = 1)<br />dweeks(x = 1)<br />dyears(x = 1)<br />dmilliseconds(x = 1)<br />dmicroseconds(x = 1)<br />dnanoseconds(x = 1)<br />dpicoseconds(x = 1) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the duration.</p> </td> </tr></table> "	FALSE
"quick_durations"	"lubridate"	"Quickly create duration objects."	"<p>Quickly create Duration objects for easy date-time manipulation. The units of the duration created depend on the name of the function called. For Duration objects, units are equal to their most common lengths in seconds (i.e. minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800, years = 31536000). </p>"	"<pre>dseconds(x = 1)<br />dminutes(x = 1)<br />dhours(x = 1)<br />ddays(x = 1)<br />dweeks(x = 1)<br />dyears(x = 1)<br />dmilliseconds(x = 1)<br />dmicroseconds(x = 1)<br />dnanoseconds(x = 1)<br />dpicoseconds(x = 1) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the duration.</p> </td> </tr></table> "	FALSE
"ymd"	"lubridate"	"Parse dates according to the order in that year, month, and day elementsappear in the input vector."	"<p>Transforms dates stored in character and numeric vectors to Date or POSIXct objects (see <code>tz</code> argument). These functions recognize arbitrary non-digit separators as well as no separator. As long as the order of formats is correct, these functions will parse dates correctly even when the input vectors contain differently formatted dates. See examples. </p>"	"<pre>ymd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />myd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dym(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />yq(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character or numeric vector of suspected dates</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>Time zone indicator. If NULL (default) a Date object is returned. Otherwise a POSIXct with time zone attribute set to <code>tz</code>.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer. Number of formats that can be truncated.</p> </td> </tr> </table> "	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"parse_date_time"	"lubridate"	"Parse character and numeric date-time vectors with user friendly orderformats."	"<p><code>parse_date_time</code> parses an input vector into POSIXct date-time object. It differs from <code>strptime</code> in two respects. First, it allows specification of the order in which the formats occur without the need to include separators and '%' prefix. Such a formating argument is refered to as 'order'. Second, it allows the user to specify several format-orders to handle heterogeneous date-time character representations. <br><code>parse_date_time2</code> is a fast C parser of numeric orders. <br><code>fast_strptime</code> is a fast C parser of numeric formats only that accepts explicit format arguments, just as <code>strptime</code>. </p>"	"<pre>parse_date_time(x, orders, tz = 'UTC', truncated = 0, quiet = FALSE,<br />   locale = Sys.getlocale('LC_TIME'), select_formats = .select_formats,<br />   exact = FALSE)<br />parse_date_time2(x, orders, tz = 'UTC', exact = FALSE, lt = FALSE)<br />fast_strptime(x, format, tz = 'UTC', lt = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a character or numeric vector of dates</p> </td> </tr> <tr valign='top'> <td><code>orders</code></td> <td> <p>a character vector of date-time formats. Each order string is series of formatting characters as listed <code>strptime</code> but might not include the '%' prefix, for example 'ymd' will match all the possible dates in year, month, day order.  Formatting orders might include arbitrary separators. These are discarded.  See details for implemented formats.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies the time zone with which to parse the dates</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, number of formats that can be missing. The most common type of irregularity in date-time data is the truncation due to rounding or unavailability of the time stamp. If <code>truncated</code> parameter is non-zero <code>parse_date_time</code> also checks for truncated formats. For example,  if the format order is 'ymdHMS' and <code>truncated = 3</code>, <code>parse_date_time</code> will correctly parse incomplete dates like <code>2012-06-01 12:23</code>, <code>2012-06-01 12</code> and <code>2012-06-01</code>. <b>NOTE:</b> <code>ymd</code> family of functions are based on <code>strptime</code> which currently fails to parse <code>%y-%m</code> formats.</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE progress messages are not printed, and 'no formats found' error is surpresed and the function simply returns a vector of NAs.  This mirrors the behavior of base R functions <code>strptime</code> and <code>as.POSIXct</code>. Default is FALSE.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>select_formats</code></td> <td> <p>A function to select actual formats for parsing from a set of formats which matched a training subset of <code>x</code>. it receives a named integer vector and returns a character vector of selected formats. Names of the input vector are formats (not orders) that matched the training set. Numeric values are the number of dates (in the training set) that matched the corresponding format. You should use this argument if the default selection method fails to select the formats in the right order. By default the formats with most formating tockens (%) are selected and %Y counts as 2.5 tockens (so that it has a priority over %y%m). Se examples.</p> </td> </tr> <tr valign='top'> <td><code>exact</code></td> <td> <p>logical. If <code>TRUE</code>, <code>orders</code> parameter is interpreted as an exact <code>strptime</code> format and no trainign or guessing are performed.</p> </td> </tr> <tr valign='top'> <td><code>lt</code></td> <td> <p>logical. If TRUE returned object is of class POSIXlt, and POSIXct otherwise. For compatibility with base 'strptime' function default is TRUE for 'fast_strptime' and FALSE for 'parse_date_time2'.</p> </td> </tr> <tr valign='top'> <td><code>format</code></td> <td> <p>a character string of formats. It should include all the separators and each format must be prefixed with  argument of <code>strptime</code>.</p> </td> </tr> </table> "	FALSE
"fit_to_timeline"	"lubridate"	"Fit a POSIXlt date-time to the timeline"	"<p>The POSIXlt format allows you to create instants that do not exist in real life due to daylight savings time and other conventions. fit_to_timeline matches POSIXlt date-times to a real times. If an instant does not exist, fit to timeline will replace it with an NA. If an instant does exist, but has been paired with an incorrect timezone/daylight savings time combination, fit_to_timeline returns the instant with the correct combination. </p>"	"<pre>fit_to_timeline(lt, class = 'POSIXct', simple = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>lt</code></td> <td> <p>a POSIXlt date-time object.</p> </td> </tr> <tr valign='top'> <td><code>class</code></td> <td> <p>a character string that describes what type of object to return, POSIXlt or POSIXct. Defaults to POSIXct. This is an optimization to avoid needless conversions.</p> </td> </tr> <tr valign='top'> <td><code>simple</code></td> <td> <p>if TRUE, <code>lubridate</code> makes no attempt to detect meaningless time-dates or to correct time zones. No NAs are produced and the most meaningful valid dates are returned instead. See examples.</p> </td> </tr> </table> "	FALSE
"round_date"	"lubridate"	"Round, floor and ceiling methods for date-time objects."	"<p>Rounding to the nearest unit or multiple of a unit are supported. All meaningfull specifications in English language are supported - secs, min, mins, 2 minutes, 3 years etc. <br><code>round_date</code> takes a date-time object and rounds it to the nearest value of the specified time unit. For rounding date-times which is exactly halfway between two consecutive units, the convention is to round up. Note that this is in line with the behavior of R's base round.POSIXt function but does not follow the convention of the base round function which 'rounds to the even digit' per IEC 60559. <br><code>floor_date</code> takes a date-time object and rounds it down to the nearest boundary of the specified  time unit. <br><code>ceiling_date</code> takes a date-time object and rounds it up to the nearest boundary of the specified time unit. </p>"	"<pre>round_date(x, unit = 'second')<br />floor_date(x, unit = 'seconds')<br />ceiling_date(x, unit = 'seconds', change_on_boundary = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of date-time objects</p> </td> </tr> <tr valign='top'> <td><code>unit</code></td> <td> <p>a character string specifying the time unit or a multiple of a unit to be rounded to. Valid base units are second, minute, hour, day, week, month, bimonth, quarter, halfyear, or year. Arbitrary unique English abbreviations as in <code>period</code> constructor are also supported. Rounding to multiple of units (except weeks) is supported from <code>v1.6.0</code>.</p> </td> </tr> <tr valign='top'> <td><code>change_on_boundary</code></td> <td> <p>If NULL (the default) don't change instants on the boundary (<code>ceiling_date(ymd_hms('2000-01-01 00:00:00'))</code> is <code>2000-01-01 00:00:00</code>), but round up <code>Date</code> objects to the next boundary (<code>ceiling_date(ymd('2000-01-01'), 'month')</code> is <code>'2000-02-01'</code>). When <code>TRUE</code>, instants on the boundary are rounded up to the next boundary. When <code>FALSE</code>, date-time on the boundary are never rounded up (this was the default for <code>lubridate</code> prior to <code>v1.6.0</code>. See section <code>Rounding Up Date Objects</code> below for more details.</p> </td> </tr> </table> "	FALSE
"force_tz"	"lubridate"	"Replace time zone to create new date-time"	"<p>force_tz returns a the date-time that has the same clock time as x in the new time zone. Although the new date-time has the same clock time (e.g. the same values in the year, month, days, etc. elements) it is a different moment of time than the input date-time. force_tz defaults to the Universal Coordinated time zone (UTC) when an unrecognized time zone is inputted. See <code>Sys.timezone</code> for more information on how R recognizes time zones. </p>"	"<pre>force_tz(time, tzone = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>time</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron date-time object, or a data.frame object. When a data.frame all POSIXt elements of a data.frame are processed with <code>force_tz</code> and new data.frame is returned.</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a character string containing the time zone to convert to. R must recognize the name contained in the string as a time zone on your system.</p> </td> </tr> </table> "	FALSE
"guess_formats"	"lubridate"	"Guess formats from the supplied date-time character vector."	"<p>Guess formats from the supplied date-time character vector. </p>"	"<pre>guess_formats(x, orders, locale = Sys.getlocale('LC_TIME'),<br />   preproc_wday = TRUE, print_matches = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>input vector of date-times</p> </td> </tr> <tr valign='top'> <td><code>orders</code></td> <td> <p>format orders to look for. See examples.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to use, default to the current locale</p> </td> </tr> <tr valign='top'> <td><code>preproc_wday</code></td> <td> <p>whether to preprocess week days names. Internal optimization used by ymd_hms family of functions. If true week days are substituted with  this format explicitly.</p> </td> </tr> <tr valign='top'> <td><code>print_matches</code></td> <td> <p>for development purpose mainly. If TRUE prints a matrix of matched templates.</p> </td> </tr> </table> "	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"hms"	"lubridate"	"Create a period with the specified hours, minutes, and seconds"	"<p>Transforms a character or numeric vector into a period object with the specified number of hours, minutes, and seconds. hms() recognizes all non-numeric characters except '-' as separators ('-' is used for negative durations).  After hours, minutes and seconds have been parsed, the remaining input is ingored. </p>"	"<pre>ms(..., quiet = FALSE, roll = FALSE)<br />hm(..., quiet = FALSE, roll = FALSE)<br />hms(..., quiet = FALSE, roll = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of hour minute second triples</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>roll</code></td> <td> <p>logica. When TRUE smaller units are rolled over to higher units if they exceed the conventional limit. For example <code>hms('01:59:120', roll=TRUE)</code> produces period '2H 1M 0S'.</p> </td> </tr> </table> "	FALSE
"hms"	"lubridate"	"Create a period with the specified hours, minutes, and seconds"	"<p>Transforms a character or numeric vector into a period object with the specified number of hours, minutes, and seconds. hms() recognizes all non-numeric characters except '-' as separators ('-' is used for negative durations).  After hours, minutes and seconds have been parsed, the remaining input is ingored. </p>"	"<pre>ms(..., quiet = FALSE, roll = FALSE)<br />hm(..., quiet = FALSE, roll = FALSE)<br />hms(..., quiet = FALSE, roll = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of hour minute second triples</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>roll</code></td> <td> <p>logica. When TRUE smaller units are rolled over to higher units if they exceed the conventional limit. For example <code>hms('01:59:120', roll=TRUE)</code> produces period '2H 1M 0S'.</p> </td> </tr> </table> "	FALSE
"hour"	"lubridate"	"Get/set hours component of a date-time."	"<p>Date-time must be a POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>hour(x)<br />hour(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>numeric value to be assigned to <code>hour</code> component</p> </td> </tr> </table> "	FALSE
"hour"	"lubridate"	"Get/set hours component of a date-time."	"<p>Date-time must be a POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>hour(x)<br />hour(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>numeric value to be assigned to <code>hour</code> component</p> </td> </tr> </table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"is.instant"	"lubridate"	"Is x a date-time object?"	"<p>An instant is a specific moment in time. Most common date-time objects (e.g, POSIXct, POSIXlt, and Date objects) are instants. </p>"	"<pre>is.instant(x)<br />is.timepoint(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr></table> "	FALSE
"is.instant"	"lubridate"	"Is x a date-time object?"	"<p>An instant is a specific moment in time. Most common date-time objects (e.g, POSIXct, POSIXlt, and Date objects) are instants. </p>"	"<pre>is.instant(x)<br />is.timepoint(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr></table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"Interval-class"	"lubridate"	"Interval class"	"<p>Interval is an S4 class that extends the <code>Timespan-class</code> class. An Interval object records one or more spans of time. Intervals record these timespans as a sequence of seconds that begin at a specified date. Since intervals are anchored to a precise moment of time, they can accurately be converted to <code>Period-class</code> or <code>Duration-class</code> class objects. This is because we can observe the length in seconds of each period that begins on a specific date. Contrast this to a generalized period, which may not have a consistent length in seconds (e.g. the number of seconds in a year will change if it is a leap year). </p>"	NA	NA	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"is.Date"	"lubridate"	"Is x a Date object?"	"<p>Is x a Date object? </p>"	"<pre>is.Date(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr></table> "	FALSE
"is.difftime"	"lubridate"	"Is x a difftime object?"	"<p>Is x a difftime object? </p>"	"<pre>is.difftime(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr></table> "	FALSE
"duration"	"lubridate"	"Create a duration object."	"<p><code>duration</code> creates a duration object with the specified values. Entries for different units are cumulative. durations display as the number of seconds in a time span. When this number is large, durations also display an estimate in larger units,; however, the underlying object is always recorded as a fixed number of seconds. For display and creation purposes, units are converted to seconds using their most common lengths in seconds. Minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800. Units larger than weeks are not used due to their variability. </p>"	"<pre>duration(num = NULL, units = 'seconds', ...)<br />is.duration(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>num</code></td> <td> <p>the number of time units to include in the duration. From v1.6.0 <code>num</code> can also be a character vector that specifies durations in a convenient shorthand format. All unambiguous name units and abbreviations are supported. See examples.</p> </td> </tr> <tr valign='top'> <td><code>units</code></td> <td> <p>a character string that specifies the type of units that num refers to. When <code>num</code> is character, this argument is ignored.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>a list of time units to be included in the duration and their amounts. Seconds, minutes, hours, days, and weeks are supported.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> </table> "	FALSE
"is.instant"	"lubridate"	"Is x a date-time object?"	"<p>An instant is a specific moment in time. Most common date-time objects (e.g, POSIXct, POSIXlt, and Date objects) are instants. </p>"	"<pre>is.instant(x)<br />is.timepoint(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr></table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"period"	"lubridate"	"Create a period object."	"<p><code>period</code> creates a period object with the specified values. period provides the behaviour of <code>period</code> in a way that is more suitable for automating within a function. </p>"	"<pre>period(num = NULL, units = 'second', ...)<br />is.period(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>num</code></td> <td> <p>a numeric vector that lists the number of time units to be included in the period. From v1.6.0 <code>num</code> can also be a character vector that specifies durations in a convenient shorthand format. All unambiguous name units and abbreviations are supported. One letter 'm' stands for months, 'M' stands for minutes. See examples.</p> </td> </tr> <tr valign='top'> <td><code>units</code></td> <td> <p>a character vector that lists the type of units to be used. The units in units are matched to the values in num according to their order. When <code>num</code> is character, this argument is ignored.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>a list of time units to be included in the period and their amounts. Seconds, minutes,  hours, days, weeks, months, and years are supported. Normally only one of <code>num</code> or <code>...</code> are present. If both are present, the periods are concatenated.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> </table> "	FALSE
"is.POSIXt"	"lubridate"	"Is x a POSIXct or POSIXlt object?"	"<p>Is x a POSIXct or POSIXlt object? </p>"	"<pre>is.POSIXt(x)<br />is.POSIXlt(x)<br />is.POSIXct(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr></table> "	FALSE
"is.POSIXt"	"lubridate"	"Is x a POSIXct or POSIXlt object?"	"<p>Is x a POSIXct or POSIXlt object? </p>"	"<pre>is.POSIXt(x)<br />is.POSIXlt(x)<br />is.POSIXct(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr></table> "	FALSE
"is.POSIXt"	"lubridate"	"Is x a POSIXct or POSIXlt object?"	"<p>Is x a POSIXct or POSIXlt object? </p>"	"<pre>is.POSIXt(x)<br />is.POSIXlt(x)<br />is.POSIXct(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr></table> "	FALSE
"is.instant"	"lubridate"	"Is x a date-time object?"	"<p>An instant is a specific moment in time. Most common date-time objects (e.g, POSIXct, POSIXlt, and Date objects) are instants. </p>"	"<pre>is.instant(x)<br />is.timepoint(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr></table> "	FALSE
"is.timespan"	"lubridate"	"Is x a length of time?"	"<p>Is x a length of time? </p>"	"<pre>is.timespan(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr></table> "	FALSE
"week"	"lubridate"	"Get/set weeks component of a date-time."	"<p><code>week</code> returns the number of complete seven day periods that have occured between the date and January 1st, plus one.<br><code>isoweek</code> returns the week as it would appear in the ISO 8601 system, which uses a reoccuring leap week. </p>"	"<pre>week(x)<br />week(x) &lt;- value<br />isoweek(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object. Must be a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"year"	"lubridate"	"Get/set years component of a date-time."	"<p>Date-time must be a POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>year(x)<br />year(x) &lt;- value<br />isoyear(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"lakers"	"lubridate"	"Lakers 2008-2009 basketball data set"	"<p>This data set contains play by play statistics of each Los Angeles Lakers basketball game in the 2008-2009 season. Data includes the date, opponent, and type of each game (home or away). Each play is described by the time on the game clock when the play was made, the period in which the play was attempted, the type of play, the player and team who made the play, the result of the play, and the location on the court where each play was made. </p>"	NA	NA	FALSE
"leap_year"	"lubridate"	"Is a year a leap year?"	"<p>If x is a recognized date-time object, leap_year will return whether x occurs during a leap year. If x is a number, leap_year returns whether it would be a leap year under the Gregorian calendar. </p>"	"<pre>leap_year(date) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>date</code></td> <td> <p>a date-time object or a year</p> </td> </tr></table> "	FALSE
"lubridate-package"	"lubridate"	"Dates and times made easy with lubridate"	"<p>Lubridate provides tools that make it easier to parse and manipulate dates. These tools are grouped below by common purpose. More information about each function can be found in its help documentation. </p>"	NA	NA	FALSE
"mplus"	"lubridate"	"Add and subtract months to a date without exceeding the last day of the new month"	"<p>Adding months frustrates basic arithmetic because consecutive months have different lengths. With other elements, it is helpful for arithmetic to perform automatic roll over. For example, 12:00:00 + 61 seconds becomes 12:01:01. However, people often prefer that this behavior NOT occur with months. For example, we sometimes want January 31 + 1 month = February 28 and not March 3. %m+% performs this type of arithmetic. Date %m+% months(n) always returns a date in the nth month after Date. If the new date would usually spill over into the n + 1th month, %m+% will return the last day of the nth month (<code>rollback</code>. Date %m-% months(n) always returns a date in the nth month before Date. </p> <p><code>add_with_rollback</code> provides additional functionality to %m+% and %m-%. It allows rollback to first day of the month instead of the last day of the previous month and controls whether HMS component of the end date is preserved or not. </p>"	"<pre>e1 %m+% e2<br />add_with_rollback(e1, e2, roll_to_first = FALSE, preserve_hms = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>e1</code></td> <td> <p>A period or a date-time object of class <code>POSIXlt</code>, <code>POSIXct</code> or <code>Date</code>.</p> </td> </tr> <tr valign='top'> <td><code>e2</code></td> <td> <p>A period or a date-time object of class <code>POSIXlt</code>, <code>POSIXct</code> or <code>Date</code>. Note that one of e1 and e2 must be a period and the other a date-time object.</p> </td> </tr> <tr valign='top'> <td><code>roll_to_first</code></td> <td> <p>rollback to the first day of the month instead of the last day of the previous month (passed to <code>rollback</code>)</p> </td> </tr> <tr valign='top'> <td><code>preserve_hms</code></td> <td> <p>retains the same hour, minute, and second information? If FALSE, the new date will be at 00:00:00 (passed to <code>rollback</code>)</p> </td> </tr> </table> "	FALSE
"mplus"	"lubridate"	"Add and subtract months to a date without exceeding the last day of the new month"	"<p>Adding months frustrates basic arithmetic because consecutive months have different lengths. With other elements, it is helpful for arithmetic to perform automatic roll over. For example, 12:00:00 + 61 seconds becomes 12:01:01. However, people often prefer that this behavior NOT occur with months. For example, we sometimes want January 31 + 1 month = February 28 and not March 3. %m+% performs this type of arithmetic. Date %m+% months(n) always returns a date in the nth month after Date. If the new date would usually spill over into the n + 1th month, %m+% will return the last day of the nth month (<code>rollback</code>. Date %m-% months(n) always returns a date in the nth month before Date. </p> <p><code>add_with_rollback</code> provides additional functionality to %m+% and %m-%. It allows rollback to first day of the month instead of the last day of the previous month and controls whether HMS component of the end date is preserved or not. </p>"	"<pre>e1 %m+% e2<br />add_with_rollback(e1, e2, roll_to_first = FALSE, preserve_hms = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>e1</code></td> <td> <p>A period or a date-time object of class <code>POSIXlt</code>, <code>POSIXct</code> or <code>Date</code>.</p> </td> </tr> <tr valign='top'> <td><code>e2</code></td> <td> <p>A period or a date-time object of class <code>POSIXlt</code>, <code>POSIXct</code> or <code>Date</code>. Note that one of e1 and e2 must be a period and the other a date-time object.</p> </td> </tr> <tr valign='top'> <td><code>roll_to_first</code></td> <td> <p>rollback to the first day of the month instead of the last day of the previous month (passed to <code>rollback</code>)</p> </td> </tr> <tr valign='top'> <td><code>preserve_hms</code></td> <td> <p>retains the same hour, minute, and second information? If FALSE, the new date will be at 00:00:00 (passed to <code>rollback</code>)</p> </td> </tr> </table> "	FALSE
"make_datetime"	"lubridate"	"Efficient creation of date-times from numeric representations"	"<p><code>make_datetime</code> is a very fast drop-in replacement for <code>base::ISOdate</code> and <code>base::ISOdatetime</code>. <code>make_date</code> produces objects of class <code>Date</code>. </p>"	"<pre>make_datetime(year = 1970L, month = 1L, day = 1L, hour = 0L, min = 0L,<br />   sec = 0, tz = 'UTC')<br />make_date(year = 1970L, month = 1L, day = 1L) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>year</code></td> <td> <p>numeric year</p> </td> </tr> <tr valign='top'> <td><code>month</code></td> <td> <p>numeric month</p> </td> </tr> <tr valign='top'> <td><code>day</code></td> <td> <p>numeric day</p> </td> </tr> <tr valign='top'> <td><code>hour</code></td> <td> <p>numeric hour</p> </td> </tr> <tr valign='top'> <td><code>min</code></td> <td> <p>numeric minute</p> </td> </tr> <tr valign='top'> <td><code>sec</code></td> <td> <p>numeric second</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>time zone. Defaults to UTC.</p> </td> </tr> </table> "	FALSE
"make_datetime"	"lubridate"	"Efficient creation of date-times from numeric representations"	"<p><code>make_datetime</code> is a very fast drop-in replacement for <code>base::ISOdate</code> and <code>base::ISOdatetime</code>. <code>make_date</code> produces objects of class <code>Date</code>. </p>"	"<pre>make_datetime(year = 1970L, month = 1L, day = 1L, hour = 0L, min = 0L,<br />   sec = 0, tz = 'UTC')<br />make_date(year = 1970L, month = 1L, day = 1L) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>year</code></td> <td> <p>numeric year</p> </td> </tr> <tr valign='top'> <td><code>month</code></td> <td> <p>numeric month</p> </td> </tr> <tr valign='top'> <td><code>day</code></td> <td> <p>numeric day</p> </td> </tr> <tr valign='top'> <td><code>hour</code></td> <td> <p>numeric hour</p> </td> </tr> <tr valign='top'> <td><code>min</code></td> <td> <p>numeric minute</p> </td> </tr> <tr valign='top'> <td><code>sec</code></td> <td> <p>numeric second</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>time zone. Defaults to UTC.</p> </td> </tr> </table> "	FALSE
"make_difftime"	"lubridate"	"Create a difftime object."	"<p><code>make_difftime</code> creates a difftime object with the specified number of units. Entries for different units are cumulative. difftime displays durations in various units,  but these units are estimates given for convenience. The underlying object is always recorded as a fixed number of seconds. </p>"	"<pre>make_difftime(num = NULL, units = 'auto', ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>num</code></td> <td> <p>Optional number of seconds</p> </td> </tr> <tr valign='top'> <td><code>units</code></td> <td> <p>a character vector that lists the type of units to use for the display of the return value (see examples). If <code>units</code> is 'auto' (the default) the display units are computed automatically. This might create undesirable effects when converting <code>difftime</code> objects to numeric values in data processing.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>a list of time units to be included in the difftime and their amounts. Seconds, minutes, hours, days, and weeks are supported. Normally only one of <code>num</code> or <code>...</code> are present. If both are present, the <code>difftime</code> objects are concatenated.</p> </td> </tr> </table> "	FALSE
"day"	"lubridate"	"Get/set days component of a date-time."	"<p>Get/set days component of a date-time. </p>"	"<pre>day(x)<br />mday(x)<br />wday(x, label = FALSE, abbr = TRUE)<br />qday(x)<br />yday(x)<br />day(x) &lt;- value<br />mday(x) &lt;- value<br />qday(x) &lt;- value<br />wday(x) &lt;- value<br />yday(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. Only available for wday. TRUE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' FALSE will display the day of the week as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. Only available for wday. FALSE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' TRUE will display an abbreviated version of the label, such as 'Sun'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"day"	"lubridate"	"Get/set days component of a date-time."	"<p>Get/set days component of a date-time. </p>"	"<pre>day(x)<br />mday(x)<br />wday(x, label = FALSE, abbr = TRUE)<br />qday(x)<br />yday(x)<br />day(x) &lt;- value<br />mday(x) &lt;- value<br />qday(x) &lt;- value<br />wday(x) &lt;- value<br />yday(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. Only available for wday. TRUE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' FALSE will display the day of the week as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. Only available for wday. FALSE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' TRUE will display an abbreviated version of the label, such as 'Sun'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"ymd"	"lubridate"	"Parse dates according to the order in that year, month, and day elementsappear in the input vector."	"<p>Transforms dates stored in character and numeric vectors to Date or POSIXct objects (see <code>tz</code> argument). These functions recognize arbitrary non-digit separators as well as no separator. As long as the order of formats is correct, these functions will parse dates correctly even when the input vectors contain differently formatted dates. See examples. </p>"	"<pre>ymd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />myd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dym(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />yq(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character or numeric vector of suspected dates</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>Time zone indicator. If NULL (default) a Date object is returned. Otherwise a POSIXct with time zone attribute set to <code>tz</code>.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer. Number of formats that can be truncated.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"minute"	"lubridate"	"Get/set minutes component of a date-time."	"<p>Date-time must be a  POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>minute(x)<br />minute(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>numeric value to be assigned</p> </td> </tr> </table> "	FALSE
"minute"	"lubridate"	"Get/set minutes component of a date-time."	"<p>Date-time must be a  POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>minute(x)<br />minute(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>numeric value to be assigned</p> </td> </tr> </table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"month"	"lubridate"	"Get/set months component of a date-time."	"<p>Date-time must be a POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>month(x, label = FALSE, abbr = TRUE)<br />month(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. TRUE will display the month as a character string such as 'January.' FALSE will display the month as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. FALSE will display the month as a character string label, such as 'January'. TRUE will display an abbreviated version of the label, such as 'Jan'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"month"	"lubridate"	"Get/set months component of a date-time."	"<p>Date-time must be a POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>month(x, label = FALSE, abbr = TRUE)<br />month(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. TRUE will display the month as a character string such as 'January.' FALSE will display the month as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. FALSE will display the month as a character string label, such as 'January'. TRUE will display an abbreviated version of the label, such as 'Jan'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"hms"	"lubridate"	"Create a period with the specified hours, minutes, and seconds"	"<p>Transforms a character or numeric vector into a period object with the specified number of hours, minutes, and seconds. hms() recognizes all non-numeric characters except '-' as separators ('-' is used for negative durations).  After hours, minutes and seconds have been parsed, the remaining input is ingored. </p>"	"<pre>ms(..., quiet = FALSE, roll = FALSE)<br />hm(..., quiet = FALSE, roll = FALSE)<br />hms(..., quiet = FALSE, roll = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of hour minute second triples</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>roll</code></td> <td> <p>logica. When TRUE smaller units are rolled over to higher units if they exceed the conventional limit. For example <code>hms('01:59:120', roll=TRUE)</code> produces period '2H 1M 0S'.</p> </td> </tr> </table> "	FALSE
"ymd"	"lubridate"	"Parse dates according to the order in that year, month, and day elementsappear in the input vector."	"<p>Transforms dates stored in character and numeric vectors to Date or POSIXct objects (see <code>tz</code> argument). These functions recognize arbitrary non-digit separators as well as no separator. As long as the order of formats is correct, these functions will parse dates correctly even when the input vectors contain differently formatted dates. See examples. </p>"	"<pre>ymd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />myd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dym(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />yq(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character or numeric vector of suspected dates</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>Time zone indicator. If NULL (default) a Date object is returned. Otherwise a POSIXct with time zone attribute set to <code>tz</code>.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer. Number of formats that can be truncated.</p> </td> </tr> </table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"now"	"lubridate"	"The current time"	"<p>The current time </p>"	"<pre>now(tzone = '') </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>tzone</code></td> <td> <p>a character vector specifying which time zone you would like the current time in. tzone defaults to your computer's system timezone. You can retrieve the current time in the Universal Coordinated Time (UTC) with now('UTC').</p> </td> </tr></table> "	FALSE
"Deprecated"	"lubridate"	"Deprecated function in lubridate package"	"<p>Deprecated function in <code>lubridate</code> package </p>"	"<pre>new_period(...)<br />new_interval(...)<br />new_duration(...)<br />new_difftime(...)<br />eseconds(x = 1)<br />eminutes(x = 1)<br />ehours(x = 1)<br />edays(x = 1)<br />eweeks(x = 1)<br />eyears(x = 1)<br />emilliseconds(x = 1)<br />emicroseconds(x = 1)<br />enanoseconds(x = 1)<br />epicoseconds(x = 1)<br />here()<br />olson_time_zones(order_by = c('name', 'longitude')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>arguments to be passed to the functions (obscured to enforce the usage of new functions)</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value to be converted into duration</p> </td> </tr> <tr valign='top'> <td><code>order_by</code></td> <td> <p>Return names alphabetically (the default) or from West to East.</p> </td> </tr> </table>"	FALSE
"origin"	"lubridate"	"1970-01-01 UTC"	"<p>Origin is the date-time for 1970-01-01 UTC in POSIXct format. This date-time is the origin for the numbering system used by POSIXct, POSIXlt, chron, and Date classes. </p>"	"<pre>origin </pre>"	NA	FALSE
"parse_date_time"	"lubridate"	"Parse character and numeric date-time vectors with user friendly orderformats."	"<p><code>parse_date_time</code> parses an input vector into POSIXct date-time object. It differs from <code>strptime</code> in two respects. First, it allows specification of the order in which the formats occur without the need to include separators and '%' prefix. Such a formating argument is refered to as 'order'. Second, it allows the user to specify several format-orders to handle heterogeneous date-time character representations. <br><code>parse_date_time2</code> is a fast C parser of numeric orders. <br><code>fast_strptime</code> is a fast C parser of numeric formats only that accepts explicit format arguments, just as <code>strptime</code>. </p>"	"<pre>parse_date_time(x, orders, tz = 'UTC', truncated = 0, quiet = FALSE,<br />   locale = Sys.getlocale('LC_TIME'), select_formats = .select_formats,<br />   exact = FALSE)<br />parse_date_time2(x, orders, tz = 'UTC', exact = FALSE, lt = FALSE)<br />fast_strptime(x, format, tz = 'UTC', lt = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a character or numeric vector of dates</p> </td> </tr> <tr valign='top'> <td><code>orders</code></td> <td> <p>a character vector of date-time formats. Each order string is series of formatting characters as listed <code>strptime</code> but might not include the '%' prefix, for example 'ymd' will match all the possible dates in year, month, day order.  Formatting orders might include arbitrary separators. These are discarded.  See details for implemented formats.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies the time zone with which to parse the dates</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, number of formats that can be missing. The most common type of irregularity in date-time data is the truncation due to rounding or unavailability of the time stamp. If <code>truncated</code> parameter is non-zero <code>parse_date_time</code> also checks for truncated formats. For example,  if the format order is 'ymdHMS' and <code>truncated = 3</code>, <code>parse_date_time</code> will correctly parse incomplete dates like <code>2012-06-01 12:23</code>, <code>2012-06-01 12</code> and <code>2012-06-01</code>. <b>NOTE:</b> <code>ymd</code> family of functions are based on <code>strptime</code> which currently fails to parse <code>%y-%m</code> formats.</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE progress messages are not printed, and 'no formats found' error is surpresed and the function simply returns a vector of NAs.  This mirrors the behavior of base R functions <code>strptime</code> and <code>as.POSIXct</code>. Default is FALSE.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>select_formats</code></td> <td> <p>A function to select actual formats for parsing from a set of formats which matched a training subset of <code>x</code>. it receives a named integer vector and returns a character vector of selected formats. Names of the input vector are formats (not orders) that matched the training set. Numeric values are the number of dates (in the training set) that matched the corresponding format. You should use this argument if the default selection method fails to select the formats in the right order. By default the formats with most formating tockens (%) are selected and %Y counts as 2.5 tockens (so that it has a priority over %y%m). Se examples.</p> </td> </tr> <tr valign='top'> <td><code>exact</code></td> <td> <p>logical. If <code>TRUE</code>, <code>orders</code> parameter is interpreted as an exact <code>strptime</code> format and no trainign or guessing are performed.</p> </td> </tr> <tr valign='top'> <td><code>lt</code></td> <td> <p>logical. If TRUE returned object is of class POSIXlt, and POSIXct otherwise. For compatibility with base 'strptime' function default is TRUE for 'fast_strptime' and FALSE for 'parse_date_time2'.</p> </td> </tr> <tr valign='top'> <td><code>format</code></td> <td> <p>a character string of formats. It should include all the separators and each format must be prefixed with  argument of <code>strptime</code>.</p> </td> </tr> </table> "	FALSE
"parse_date_time"	"lubridate"	"Parse character and numeric date-time vectors with user friendly orderformats."	"<p><code>parse_date_time</code> parses an input vector into POSIXct date-time object. It differs from <code>strptime</code> in two respects. First, it allows specification of the order in which the formats occur without the need to include separators and '%' prefix. Such a formating argument is refered to as 'order'. Second, it allows the user to specify several format-orders to handle heterogeneous date-time character representations. <br><code>parse_date_time2</code> is a fast C parser of numeric orders. <br><code>fast_strptime</code> is a fast C parser of numeric formats only that accepts explicit format arguments, just as <code>strptime</code>. </p>"	"<pre>parse_date_time(x, orders, tz = 'UTC', truncated = 0, quiet = FALSE,<br />   locale = Sys.getlocale('LC_TIME'), select_formats = .select_formats,<br />   exact = FALSE)<br />parse_date_time2(x, orders, tz = 'UTC', exact = FALSE, lt = FALSE)<br />fast_strptime(x, format, tz = 'UTC', lt = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a character or numeric vector of dates</p> </td> </tr> <tr valign='top'> <td><code>orders</code></td> <td> <p>a character vector of date-time formats. Each order string is series of formatting characters as listed <code>strptime</code> but might not include the '%' prefix, for example 'ymd' will match all the possible dates in year, month, day order.  Formatting orders might include arbitrary separators. These are discarded.  See details for implemented formats.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies the time zone with which to parse the dates</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, number of formats that can be missing. The most common type of irregularity in date-time data is the truncation due to rounding or unavailability of the time stamp. If <code>truncated</code> parameter is non-zero <code>parse_date_time</code> also checks for truncated formats. For example,  if the format order is 'ymdHMS' and <code>truncated = 3</code>, <code>parse_date_time</code> will correctly parse incomplete dates like <code>2012-06-01 12:23</code>, <code>2012-06-01 12</code> and <code>2012-06-01</code>. <b>NOTE:</b> <code>ymd</code> family of functions are based on <code>strptime</code> which currently fails to parse <code>%y-%m</code> formats.</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE progress messages are not printed, and 'no formats found' error is surpresed and the function simply returns a vector of NAs.  This mirrors the behavior of base R functions <code>strptime</code> and <code>as.POSIXct</code>. Default is FALSE.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>select_formats</code></td> <td> <p>A function to select actual formats for parsing from a set of formats which matched a training subset of <code>x</code>. it receives a named integer vector and returns a character vector of selected formats. Names of the input vector are formats (not orders) that matched the training set. Numeric values are the number of dates (in the training set) that matched the corresponding format. You should use this argument if the default selection method fails to select the formats in the right order. By default the formats with most formating tockens (%) are selected and %Y counts as 2.5 tockens (so that it has a priority over %y%m). Se examples.</p> </td> </tr> <tr valign='top'> <td><code>exact</code></td> <td> <p>logical. If <code>TRUE</code>, <code>orders</code> parameter is interpreted as an exact <code>strptime</code> format and no trainign or guessing are performed.</p> </td> </tr> <tr valign='top'> <td><code>lt</code></td> <td> <p>logical. If TRUE returned object is of class POSIXlt, and POSIXct otherwise. For compatibility with base 'strptime' function default is TRUE for 'fast_strptime' and FALSE for 'parse_date_time2'.</p> </td> </tr> <tr valign='top'> <td><code>format</code></td> <td> <p>a character string of formats. It should include all the separators and each format must be prefixed with  argument of <code>strptime</code>.</p> </td> </tr> </table> "	FALSE
"period"	"lubridate"	"Create a period object."	"<p><code>period</code> creates a period object with the specified values. period provides the behaviour of <code>period</code> in a way that is more suitable for automating within a function. </p>"	"<pre>period(num = NULL, units = 'second', ...)<br />is.period(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>num</code></td> <td> <p>a numeric vector that lists the number of time units to be included in the period. From v1.6.0 <code>num</code> can also be a character vector that specifies durations in a convenient shorthand format. All unambiguous name units and abbreviations are supported. One letter 'm' stands for months, 'M' stands for minutes. See examples.</p> </td> </tr> <tr valign='top'> <td><code>units</code></td> <td> <p>a character vector that lists the type of units to be used. The units in units are matched to the values in num according to their order. When <code>num</code> is character, this argument is ignored.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>a list of time units to be included in the period and their amounts. Seconds, minutes,  hours, days, weeks, months, and years are supported. Normally only one of <code>num</code> or <code>...</code> are present. If both are present, the periods are concatenated.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> </table> "	FALSE
"Period-class"	"lubridate"	"Period class"	"<p>Period is an S4 class that extends the <code>Timespan-class</code> class. Periods track the change in the 'clock time' between two date-times. They are measured in common time related units: years, months, days, hours, minutes, and seconds. Each unit except for seconds must be expressed in integer values. </p>"	NA	NA	FALSE
"period_to_seconds"	"lubridate"	"Contrive a period to/from a given number of seconds."	"<p><code>period_to_seconds</code> approximately converts a period to seconds assuming there are 364.25 days in a calendar year and 365.25/12 days in a month. <br><code>seconds_to_period</code> create a period that has the maximum number of non-zero elements (days, hours, minutes, seconds). This computation is exact because it doesn't involve years or months. </p>"	"<pre>period_to_seconds(x)<br />seconds_to_period(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A numeric object. The number of seconds to coerce into a period.</p> </td> </tr></table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"am"	"lubridate"	"Does date time occur in the am or pm?"	"<p>Does date time occur in the am or pm? </p>"	"<pre>am(x)<br />pm(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr></table> "	FALSE
"pretty_dates"	"lubridate"	"Computes attractive axis breaks for date-time data"	"<p>pretty.dates indentifies which unit of time the sub-intervals should be measured in to provide approximately n breaks. It then chooses a 'pretty' length for the sub-intervals and sets start and endpoints that 1) span the entire range of the data, and 2) allow the breaks to occur on important date-times (i.e. on the hour, on the first of the month, etc.) </p>"	"<pre>pretty_dates(x, n, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of POSIXct, POSIXlt, Date, or chron date-time objects</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>integer value of the desired number of breaks</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments to pass to function</p> </td> </tr> </table> "	FALSE
"day"	"lubridate"	"Get/set days component of a date-time."	"<p>Get/set days component of a date-time. </p>"	"<pre>day(x)<br />mday(x)<br />wday(x, label = FALSE, abbr = TRUE)<br />qday(x)<br />yday(x)<br />day(x) &lt;- value<br />mday(x) &lt;- value<br />qday(x) &lt;- value<br />wday(x) &lt;- value<br />yday(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. Only available for wday. TRUE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' FALSE will display the day of the week as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. Only available for wday. FALSE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' TRUE will display an abbreviated version of the label, such as 'Sun'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"day"	"lubridate"	"Get/set days component of a date-time."	"<p>Get/set days component of a date-time. </p>"	"<pre>day(x)<br />mday(x)<br />wday(x, label = FALSE, abbr = TRUE)<br />qday(x)<br />yday(x)<br />day(x) &lt;- value<br />mday(x) &lt;- value<br />qday(x) &lt;- value<br />wday(x) &lt;- value<br />yday(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. Only available for wday. TRUE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' FALSE will display the day of the week as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. Only available for wday. FALSE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' TRUE will display an abbreviated version of the label, such as 'Sun'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"quarter"	"lubridate"	"Get the fiscal quarter and semester of a date-time."	"<p>Quarters divide the year into fourths. Semesters divide the year into halfs. </p>"	"<pre>quarter(x, with_year = FALSE)<br />semester(x, with_year = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object of class POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, fts or anything else that can be converted with as.POSIXlt</p> </td> </tr> <tr valign='top'> <td><code>with_year</code></td> <td> <p>logical indicating whether or not to include the quarter's year.</p> </td> </tr> </table> "	FALSE
"quick_durations"	"lubridate"	"Quickly create duration objects."	"<p>Quickly create Duration objects for easy date-time manipulation. The units of the duration created depend on the name of the function called. For Duration objects, units are equal to their most common lengths in seconds (i.e. minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800, years = 31536000). </p>"	"<pre>dseconds(x = 1)<br />dminutes(x = 1)<br />dhours(x = 1)<br />ddays(x = 1)<br />dweeks(x = 1)<br />dyears(x = 1)<br />dmilliseconds(x = 1)<br />dmicroseconds(x = 1)<br />dnanoseconds(x = 1)<br />dpicoseconds(x = 1) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the duration.</p> </td> </tr></table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"rollback"	"lubridate"	"Roll back date to last day of previous month"	"<p>rollback changes a date to the last day of the previous month or to the first day of the month. Optionally, the new date can retain the same hour, minute, and second information. </p>"	"<pre>rollback(dates, roll_to_first = FALSE, preserve_hms = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>dates</code></td> <td> <p>A POSIXct, POSIXlt or Date class object.</p> </td> </tr> <tr valign='top'> <td><code>roll_to_first</code></td> <td> <p>Rollback to the first day of the month instead of the last day of the previous month</p> </td> </tr> <tr valign='top'> <td><code>preserve_hms</code></td> <td> <p>Retains the same hour, minute, and second information? If FALSE, the new date will be at 00:00:00.</p> </td> </tr> </table> "	FALSE
"round_date"	"lubridate"	"Round, floor and ceiling methods for date-time objects."	"<p>Rounding to the nearest unit or multiple of a unit are supported. All meaningfull specifications in English language are supported - secs, min, mins, 2 minutes, 3 years etc. <br><code>round_date</code> takes a date-time object and rounds it to the nearest value of the specified time unit. For rounding date-times which is exactly halfway between two consecutive units, the convention is to round up. Note that this is in line with the behavior of R's base round.POSIXt function but does not follow the convention of the base round function which 'rounds to the even digit' per IEC 60559. <br><code>floor_date</code> takes a date-time object and rounds it down to the nearest boundary of the specified  time unit. <br><code>ceiling_date</code> takes a date-time object and rounds it up to the nearest boundary of the specified time unit. </p>"	"<pre>round_date(x, unit = 'second')<br />floor_date(x, unit = 'seconds')<br />ceiling_date(x, unit = 'seconds', change_on_boundary = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a vector of date-time objects</p> </td> </tr> <tr valign='top'> <td><code>unit</code></td> <td> <p>a character string specifying the time unit or a multiple of a unit to be rounded to. Valid base units are second, minute, hour, day, week, month, bimonth, quarter, halfyear, or year. Arbitrary unique English abbreviations as in <code>period</code> constructor are also supported. Rounding to multiple of units (except weeks) is supported from <code>v1.6.0</code>.</p> </td> </tr> <tr valign='top'> <td><code>change_on_boundary</code></td> <td> <p>If NULL (the default) don't change instants on the boundary (<code>ceiling_date(ymd_hms('2000-01-01 00:00:00'))</code> is <code>2000-01-01 00:00:00</code>), but round up <code>Date</code> objects to the next boundary (<code>ceiling_date(ymd('2000-01-01'), 'month')</code> is <code>'2000-02-01'</code>). When <code>TRUE</code>, instants on the boundary are rounded up to the next boundary. When <code>FALSE</code>, date-time on the boundary are never rounded up (this was the default for <code>lubridate</code> prior to <code>v1.6.0</code>. See section <code>Rounding Up Date Objects</code> below for more details.</p> </td> </tr> </table> "	FALSE
"second"	"lubridate"	"Get/set seconds component of a date-time."	"<p>Date-time must be a  POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>second(x)<br />second(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>numeric value to be assigned</p> </td> </tr> </table> "	FALSE
"second"	"lubridate"	"Get/set seconds component of a date-time."	"<p>Date-time must be a  POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>second(x)<br />second(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>numeric value to be assigned</p> </td> </tr> </table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"period_to_seconds"	"lubridate"	"Contrive a period to/from a given number of seconds."	"<p><code>period_to_seconds</code> approximately converts a period to seconds assuming there are 364.25 days in a calendar year and 365.25/12 days in a month. <br><code>seconds_to_period</code> create a period that has the maximum number of non-zero elements (days, hours, minutes, seconds). This computation is exact because it doesn't involve years or months. </p>"	"<pre>period_to_seconds(x)<br />seconds_to_period(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A numeric object. The number of seconds to coerce into a period.</p> </td> </tr></table> "	FALSE
"quarter"	"lubridate"	"Get the fiscal quarter and semester of a date-time."	"<p>Quarters divide the year into fourths. Semesters divide the year into halfs. </p>"	"<pre>quarter(x, with_year = FALSE)<br />semester(x, with_year = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object of class POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, fts or anything else that can be converted with as.POSIXlt</p> </td> </tr> <tr valign='top'> <td><code>with_year</code></td> <td> <p>logical indicating whether or not to include the quarter's year.</p> </td> </tr> </table> "	FALSE
"stamp"	"lubridate"	"Format dates and times based on human-friendly templates."	"<p>Stamps are just like <code>format</code>, but based on human-frendly templates like 'Recorded at 10 am, September 2002' or 'Meeting, Sunday May 1, 2000, at 10:20 pm'. </p>"	"<pre>stamp(x, orders = lubridate_formats, locale = Sys.getlocale('LC_TIME'),<br />   quiet = FALSE)<br />stamp_date(x, locale = Sys.getlocale('LC_TIME'))<br />stamp_time(x, locale = Sys.getlocale('LC_TIME')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a character vector of templates.</p> </td> </tr> <tr valign='top'> <td><code>orders</code></td> <td> <p>orders are sequences of formatting characters which might be used for disambiguation. For example 'ymd hms', 'aym' etc. See <code>guess_formats</code> for a list of available formats.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale in which <code>x</code> is encoded. On linux like systems use <code>locale -a</code> in terminal to list available locales.</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>whether to output informative messages.</p> </td> </tr> </table> "	FALSE
"stamp"	"lubridate"	"Format dates and times based on human-friendly templates."	"<p>Stamps are just like <code>format</code>, but based on human-frendly templates like 'Recorded at 10 am, September 2002' or 'Meeting, Sunday May 1, 2000, at 10:20 pm'. </p>"	"<pre>stamp(x, orders = lubridate_formats, locale = Sys.getlocale('LC_TIME'),<br />   quiet = FALSE)<br />stamp_date(x, locale = Sys.getlocale('LC_TIME'))<br />stamp_time(x, locale = Sys.getlocale('LC_TIME')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a character vector of templates.</p> </td> </tr> <tr valign='top'> <td><code>orders</code></td> <td> <p>orders are sequences of formatting characters which might be used for disambiguation. For example 'ymd hms', 'aym' etc. See <code>guess_formats</code> for a list of available formats.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale in which <code>x</code> is encoded. On linux like systems use <code>locale -a</code> in terminal to list available locales.</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>whether to output informative messages.</p> </td> </tr> </table> "	FALSE
"stamp"	"lubridate"	"Format dates and times based on human-friendly templates."	"<p>Stamps are just like <code>format</code>, but based on human-frendly templates like 'Recorded at 10 am, September 2002' or 'Meeting, Sunday May 1, 2000, at 10:20 pm'. </p>"	"<pre>stamp(x, orders = lubridate_formats, locale = Sys.getlocale('LC_TIME'),<br />   quiet = FALSE)<br />stamp_date(x, locale = Sys.getlocale('LC_TIME'))<br />stamp_time(x, locale = Sys.getlocale('LC_TIME')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a character vector of templates.</p> </td> </tr> <tr valign='top'> <td><code>orders</code></td> <td> <p>orders are sequences of formatting characters which might be used for disambiguation. For example 'ymd hms', 'aym' etc. See <code>guess_formats</code> for a list of available formats.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale in which <code>x</code> is encoded. On linux like systems use <code>locale -a</code> in terminal to list available locales.</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>whether to output informative messages.</p> </td> </tr> </table> "	FALSE
"timespan"	"lubridate"	"Description of time span classes in lubridate."	"<p>A time span can be measured in three ways: as a duration, an interval, or a period. </p>"	NA	NA	FALSE
"Timespan-class"	"lubridate"	"Timespan class"	"<p>Timespan is an S4 class with no slots. It is extended by the <code>Interval-class</code>, <code>Period-class</code>, and <code>Duration-class</code> classes. </p>"	NA	NA	FALSE
"timespan"	"lubridate"	"Description of time span classes in lubridate."	"<p>A time span can be measured in three ways: as a duration, an interval, or a period. </p>"	NA	NA	FALSE
"time_length"	"lubridate"	"Compute the exact length of a time span."	"<p>Compute the exact length of a time span. </p>"	"<pre>time_length(x, unit = 'second')<br />## S4 method for signature 'Interval' time_length(x, unit = 'second') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a duration, period, difftime or interval</p> </td> </tr> <tr valign='top'> <td><code>unit</code></td> <td> <p>a character string that specifies with time units to use</p> </td> </tr> </table> "	FALSE
"today"	"lubridate"	"The current date"	"<p>The current date </p>"	"<pre>today(tzone = '') </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>tzone</code></td> <td> <p>a character vector specifying which time zone you would like to find the current date of. tzone defaults to the system time zone set on your computer.</p> </td> </tr></table> "	FALSE
"tz"	"lubridate"	"Get/set time zone component of a date-time."	"<p>Time zones are stored as character strings in an attribute of date-time objects. tz returns a date's time zone attribute. When used as a settor, it changes the time zone attribute. R does not come with a predefined list zone names, but relies on the user's OS to interpret time zone names. As a result, some names will be recognized on some computers but not others. Most computers, however, will recognize names in the timezone data base originally compiled by Arthur Olson. These names normally take the form 'Country/City.' A convenient listing of these timezones can be found at <a href='http://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>http://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>. </p>"	"<pre>tz(x)<br />tz(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object of class a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, fts or anything else that can be coerced to POSIXlt with as.POSIXlt</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>timezone value to be assigned to <code>x</code>'s <code>tzone</code> attribute</p> </td> </tr> </table> "	FALSE
"tz"	"lubridate"	"Get/set time zone component of a date-time."	"<p>Time zones are stored as character strings in an attribute of date-time objects. tz returns a date's time zone attribute. When used as a settor, it changes the time zone attribute. R does not come with a predefined list zone names, but relies on the user's OS to interpret time zone names. As a result, some names will be recognized on some computers but not others. Most computers, however, will recognize names in the timezone data base originally compiled by Arthur Olson. These names normally take the form 'Country/City.' A convenient listing of these timezones can be found at <a href='http://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>http://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>. </p>"	"<pre>tz(x)<br />tz(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object of class a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, fts or anything else that can be coerced to POSIXlt with as.POSIXlt</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>timezone value to be assigned to <code>x</code>'s <code>tzone</code> attribute</p> </td> </tr> </table> "	FALSE
"DateUpdate"	"lubridate"	"Changes the components of a date object"	"<p><code>update.Date</code> and <code>update.POSIXt</code> return a date with the specified elements updated.  Elements not specified will be left unaltered. update.Date and update.POSIXt do not add the specified values to the existing date, they substitute them for the appropriate parts of the existing date. </p>"	"<pre>## S3 method for class 'POSIXt' update(object, ..., simple = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>object</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>named arguments: years, months, ydays, wdays, mdays, days, hours, minutes, seconds, tzs (time zone compnent)</p> </td> </tr> <tr valign='top'> <td><code>simple</code></td> <td> <p>logical, passed to <code>fit_to_timeline</code>. If TRUE a simple fit to time line is performed and no NA are produced for invalid dates. Invalid dates are converted to meaningful dates by extrapolating the timezones.</p> </td> </tr> </table> "	FALSE
"day"	"lubridate"	"Get/set days component of a date-time."	"<p>Get/set days component of a date-time. </p>"	"<pre>day(x)<br />mday(x)<br />wday(x, label = FALSE, abbr = TRUE)<br />qday(x)<br />yday(x)<br />day(x) &lt;- value<br />mday(x) &lt;- value<br />qday(x) &lt;- value<br />wday(x) &lt;- value<br />yday(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. Only available for wday. TRUE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' FALSE will display the day of the week as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. Only available for wday. FALSE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' TRUE will display an abbreviated version of the label, such as 'Sun'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"day"	"lubridate"	"Get/set days component of a date-time."	"<p>Get/set days component of a date-time. </p>"	"<pre>day(x)<br />mday(x)<br />wday(x, label = FALSE, abbr = TRUE)<br />qday(x)<br />yday(x)<br />day(x) &lt;- value<br />mday(x) &lt;- value<br />qday(x) &lt;- value<br />wday(x) &lt;- value<br />yday(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. Only available for wday. TRUE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' FALSE will display the day of the week as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. Only available for wday. FALSE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' TRUE will display an abbreviated version of the label, such as 'Sun'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"week"	"lubridate"	"Get/set weeks component of a date-time."	"<p><code>week</code> returns the number of complete seven day periods that have occured between the date and January 1st, plus one.<br><code>isoweek</code> returns the week as it would appear in the ISO 8601 system, which uses a reoccuring leap week. </p>"	"<pre>week(x)<br />week(x) &lt;- value<br />isoweek(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object. Must be a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"week"	"lubridate"	"Get/set weeks component of a date-time."	"<p><code>week</code> returns the number of complete seven day periods that have occured between the date and January 1st, plus one.<br><code>isoweek</code> returns the week as it would appear in the ISO 8601 system, which uses a reoccuring leap week. </p>"	"<pre>week(x)<br />week(x) &lt;- value<br />isoweek(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object. Must be a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"with_tz"	"lubridate"	"Get date-time in a different time zone"	"<p>with_tz returns a date-time as it would appear in a different time zone. The actual moment of time measured does not change, just the time zone it is measured in. with_tz defaults to the Universal Coordinated time zone (UTC) when an unrecognized time zone is inputted. See <code>Sys.timezone</code> for more information on how R recognizes time zones. </p>"	"<pre>with_tz(time, tzone = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>time</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron date-time object or a data.frame object. When a data.frame all POSIXt elements of a data.frame are processed with <code>with_tz</code> and new data.frame is returned.</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a character string containing the time zone to convert to. R must recognize the name contained in the string as a time zone on your system.</p> </td> </tr> </table> "	FALSE
"day"	"lubridate"	"Get/set days component of a date-time."	"<p>Get/set days component of a date-time. </p>"	"<pre>day(x)<br />mday(x)<br />wday(x, label = FALSE, abbr = TRUE)<br />qday(x)<br />yday(x)<br />day(x) &lt;- value<br />mday(x) &lt;- value<br />qday(x) &lt;- value<br />wday(x) &lt;- value<br />yday(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. Only available for wday. TRUE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' FALSE will display the day of the week as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. Only available for wday. FALSE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' TRUE will display an abbreviated version of the label, such as 'Sun'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"day"	"lubridate"	"Get/set days component of a date-time."	"<p>Get/set days component of a date-time. </p>"	"<pre>day(x)<br />mday(x)<br />wday(x, label = FALSE, abbr = TRUE)<br />qday(x)<br />yday(x)<br />day(x) &lt;- value<br />mday(x) &lt;- value<br />qday(x) &lt;- value<br />wday(x) &lt;- value<br />yday(x) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a POSIXct, POSIXlt, Date, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, or fts object.</p> </td> </tr> <tr valign='top'> <td><code>label</code></td> <td> <p>logical. Only available for wday. TRUE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' FALSE will display the day of the week as a number.</p> </td> </tr> <tr valign='top'> <td><code>abbr</code></td> <td> <p>logical. Only available for wday. FALSE will display the day of the week as an ordered factor of character strings, such as 'Sunday.' TRUE will display an abbreviated version of the label, such as 'Sun'. abbr is disregarded if label = FALSE.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"ymd"	"lubridate"	"Parse dates according to the order in that year, month, and day elementsappear in the input vector."	"<p>Transforms dates stored in character and numeric vectors to Date or POSIXct objects (see <code>tz</code> argument). These functions recognize arbitrary non-digit separators as well as no separator. As long as the order of formats is correct, these functions will parse dates correctly even when the input vectors contain differently formatted dates. See examples. </p>"	"<pre>ymd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />myd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dym(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />yq(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character or numeric vector of suspected dates</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>Time zone indicator. If NULL (default) a Date object is returned. Otherwise a POSIXct with time zone attribute set to <code>tz</code>.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer. Number of formats that can be truncated.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"year"	"lubridate"	"Get/set years component of a date-time."	"<p>Date-time must be a POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>year(x)<br />year(x) &lt;- value<br />isoyear(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"year"	"lubridate"	"Get/set years component of a date-time."	"<p>Date-time must be a POSIXct, POSIXlt, Date, Period, chron, yearmon, yearqtr, zoo, zooreg, timeDate, xts, its, ti, jul, timeSeries, and fts objects. </p>"	"<pre>year(x)<br />year(x) &lt;- value<br />isoyear(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>a date-time object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a numeric object</p> </td> </tr> </table> "	FALSE
"quick_periods"	"lubridate"	"Quickly create period objects."	"<p>Quickly create Period objects for easy date-time manipulation. The units of the period created depend on the name of the function called. For Period objects, units do not have a fixed length until they are added to a specific date time, contrast this with <code>duration</code>. This makes periods useful for manipulations with clock times because units expand or contract in length to accomodate conventions such as leap years, leap seconds, and Daylight Savings Time. </p>"	"<pre>seconds(x = 1)<br />minutes(x = 1)<br />hours(x = 1)<br />days(x = 1)<br />weeks(x = 1)<br />years(x = 1)<br />milliseconds(x = 1)<br />microseconds(x = 1)<br />nanoseconds(x = 1)<br />picoseconds(x = 1)<br />## S3 method for class 'numeric' months(x, abbreviate) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>numeric value of the number of units to be contained in the period. With the exception of seconds(), x must be an integer.</p> </td> </tr> <tr valign='top'> <td><code>abbreviate</code></td> <td> <p>Ignored. For consistency with S3 generic in base namespace.</p> </td> </tr> </table> "	FALSE
"ymd"	"lubridate"	"Parse dates according to the order in that year, month, and day elementsappear in the input vector."	"<p>Transforms dates stored in character and numeric vectors to Date or POSIXct objects (see <code>tz</code> argument). These functions recognize arbitrary non-digit separators as well as no separator. As long as the order of formats is correct, these functions will parse dates correctly even when the input vectors contain differently formatted dates. See examples. </p>"	"<pre>ymd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />myd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dym(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />yq(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character or numeric vector of suspected dates</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>Time zone indicator. If NULL (default) a Date object is returned. Otherwise a POSIXct with time zone attribute set to <code>tz</code>.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer. Number of formats that can be truncated.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"ymd_hms"	"lubridate"	"Parse dates that have hours, minutes, or seconds elements."	"<p>Transform dates stored as character or numeric vectors to POSIXct objects. ymd_hms family of functions recognize all non-alphanumeric separators (with the exception of '.' if <code>frac = TRUE</code>) and correctly handle heterogeneous date-time representations. For more flexibility in treatment of heterogeneous formats, see low level parser <code>parse_date_time</code>. </p>"	"<pre>ymd_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ymd_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hms(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_hm(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm_h(..., quiet = FALSE, tz = 'UTC', locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character vector of dates in year, month, day, hour, minute, second format</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>a character string that specifies which time zone to parse the date with. The string must be a time zone that is recognized by the user's OS.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer, indicating how many formats can be missing. See details.</p> </td> </tr> </table> "	FALSE
"ymd"	"lubridate"	"Parse dates according to the order in that year, month, and day elementsappear in the input vector."	"<p>Transforms dates stored in character and numeric vectors to Date or POSIXct objects (see <code>tz</code> argument). These functions recognize arbitrary non-digit separators as well as no separator. As long as the order of formats is correct, these functions will parse dates correctly even when the input vectors contain differently formatted dates. See examples. </p>"	"<pre>ymd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />ydm(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />mdy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />myd(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dmy(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />dym(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME'),<br />   truncated = 0)<br />yq(..., quiet = FALSE, tz = NULL, locale = Sys.getlocale('LC_TIME')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>a character or numeric vector of suspected dates</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>logical. When TRUE function evalueates without displaying customary messages.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>Time zone indicator. If NULL (default) a Date object is returned. Otherwise a POSIXct with time zone attribute set to <code>tz</code>.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>locale to be used, see locales. On linux systems you can use <code>system('locale -a')</code> to list all the installed locales.</p> </td> </tr> <tr valign='top'> <td><code>truncated</code></td> <td> <p>integer. Number of formats that can be truncated.</p> </td> </tr> </table> "	FALSE
"interval"	"lubridate"	"Utilities for creation and manipulation of Interval objects."	"<p><code>interval</code> creates an <code>Interval-class</code> object with the specified start and end dates. If the start date occurs before the end date, the interval will be positive. Otherwise, it will be negative. </p> <p><code>%--%</code> Creates an interval that covers the range spanned by two dates. It replaces the original behavior of lubridate, which created an interval by default whenever two date-times were subtracted. </p> <p><code>int_start</code> and <code>int_start&lt;-</code> are accessors the start date of an interval. Note that changing the start date of an interval will change the length of the interval, since the end date will remain the same. </p> <p><code>int_flip</code> reverses the order of the start date and end date in an interval. The new interval takes place during the same timespan as the original interval, but has the opposite direction. </p> <p><code>int_shift</code> shifts the start and end dates of an interval up or down the timeline by a specified amount. Note that this may change the exact length of the interval if the interval is shifted by a Period object. Intervals shifted by a Duration or difftime object will retain their exact length in seconds. </p> <p><code>int_overlaps</code> tests if two intervals overlap. </p> <p><code>int_standardize</code> ensures all intervals in an interval object are positive. If an interval is not positive, flip it so that it retains its endpoints but becomes positive. </p> <p><code>int_aligns</code> tests if two intervals share an endpoint. The direction of each interval is ignored. int_align tests whether the earliest or latest moments of each interval occur at the same time. </p> <p><code>int_diff</code> returns the intervals that occur between the elements of a vector of date-times. <code>int_diff</code> is similar to the POSIXt and Date methods of <code>diff</code>, but returns an <code>Interval</code> object instead of a difftime object. </p>"	"<pre>interval(start, end, tzone = attr(start, 'tzone'))<br />start %--% end<br />is.interval(x)<br />int_start(int)<br />int_start(int) &lt;- value<br />int_end(int)<br />int_end(int) &lt;- value<br />int_length(int)<br />int_flip(int)<br />int_shift(int, by)<br />int_overlaps(int1, int2)<br />int_standardize(int)<br />int_aligns(int1, int2)<br />int_diff(times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>start</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>a POSIXt or Date date-time object</p> </td> </tr> <tr valign='top'> <td><code>tzone</code></td> <td> <p>a recognized timezone to display the interval in</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>an R object</p> </td> </tr> <tr valign='top'> <td><code>int</code></td> <td> <p>an interval object</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>interval's start/end to be assigned to <code>int</code></p> </td> </tr> <tr valign='top'> <td><code>by</code></td> <td> <p>A period or duration object to shift by (for <code>int_shift</code>)</p> </td> </tr> <tr valign='top'> <td><code>int1</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>int2</code></td> <td> <p>an Interval object (for <code>int_overlaps</code>, <code>int_aligns</code>)</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>A vector of POSIXct, POSIXlt or Date class date-times (for <code>int_diff</code>)</p> </td> </tr> </table> "	FALSE
"mplus"	"lubridate"	"Add and subtract months to a date without exceeding the last day of the new month"	"<p>Adding months frustrates basic arithmetic because consecutive months have different lengths. With other elements, it is helpful for arithmetic to perform automatic roll over. For example, 12:00:00 + 61 seconds becomes 12:01:01. However, people often prefer that this behavior NOT occur with months. For example, we sometimes want January 31 + 1 month = February 28 and not March 3. %m+% performs this type of arithmetic. Date %m+% months(n) always returns a date in the nth month after Date. If the new date would usually spill over into the n + 1th month, %m+% will return the last day of the nth month (<code>rollback</code>. Date %m-% months(n) always returns a date in the nth month before Date. </p> <p><code>add_with_rollback</code> provides additional functionality to %m+% and %m-%. It allows rollback to first day of the month instead of the last day of the previous month and controls whether HMS component of the end date is preserved or not. </p>"	"<pre>e1 %m+% e2<br />add_with_rollback(e1, e2, roll_to_first = FALSE, preserve_hms = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>e1</code></td> <td> <p>A period or a date-time object of class <code>POSIXlt</code>, <code>POSIXct</code> or <code>Date</code>.</p> </td> </tr> <tr valign='top'> <td><code>e2</code></td> <td> <p>A period or a date-time object of class <code>POSIXlt</code>, <code>POSIXct</code> or <code>Date</code>. Note that one of e1 and e2 must be a period and the other a date-time object.</p> </td> </tr> <tr valign='top'> <td><code>roll_to_first</code></td> <td> <p>rollback to the first day of the month instead of the last day of the previous month (passed to <code>rollback</code>)</p> </td> </tr> <tr valign='top'> <td><code>preserve_hms</code></td> <td> <p>retains the same hour, minute, and second information? If FALSE, the new date will be at 00:00:00 (passed to <code>rollback</code>)</p> </td> </tr> </table> "	FALSE
"mplus"	"lubridate"	"Add and subtract months to a date without exceeding the last day of the new month"	"<p>Adding months frustrates basic arithmetic because consecutive months have different lengths. With other elements, it is helpful for arithmetic to perform automatic roll over. For example, 12:00:00 + 61 seconds becomes 12:01:01. However, people often prefer that this behavior NOT occur with months. For example, we sometimes want January 31 + 1 month = February 28 and not March 3. %m+% performs this type of arithmetic. Date %m+% months(n) always returns a date in the nth month after Date. If the new date would usually spill over into the n + 1th month, %m+% will return the last day of the nth month (<code>rollback</code>. Date %m-% months(n) always returns a date in the nth month before Date. </p> <p><code>add_with_rollback</code> provides additional functionality to %m+% and %m-%. It allows rollback to first day of the month instead of the last day of the previous month and controls whether HMS component of the end date is preserved or not. </p>"	"<pre>e1 %m+% e2<br />add_with_rollback(e1, e2, roll_to_first = FALSE, preserve_hms = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>e1</code></td> <td> <p>A period or a date-time object of class <code>POSIXlt</code>, <code>POSIXct</code> or <code>Date</code>.</p> </td> </tr> <tr valign='top'> <td><code>e2</code></td> <td> <p>A period or a date-time object of class <code>POSIXlt</code>, <code>POSIXct</code> or <code>Date</code>. Note that one of e1 and e2 must be a period and the other a date-time object.</p> </td> </tr> <tr valign='top'> <td><code>roll_to_first</code></td> <td> <p>rollback to the first day of the month instead of the last day of the previous month (passed to <code>rollback</code>)</p> </td> </tr> <tr valign='top'> <td><code>preserve_hms</code></td> <td> <p>retains the same hour, minute, and second information? If FALSE, the new date will be at 00:00:00 (passed to <code>rollback</code>)</p> </td> </tr> </table> "	FALSE
"within-interval"	"lubridate"	"Tests whether a date or interval falls within an interval"	"<p>If a is an interval, both its start and end dates must fall within b to return TRUE. </p>"	"<pre>a %within% b </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>a</code></td> <td> <p>An interval or date-time object</p> </td> </tr> <tr valign='top'> <td><code>b</code></td> <td> <p>An interval</p> </td> </tr> </table> "	FALSE
"magrittr"	"magrittr"	"magrittr - Ceci n'est pas un pipe"	"<p>The magrittr package offers a set of operators which promote semantics that will improve your code by </p> <ul> <li> <p> structuring sequences of data operations left-to-right (as opposed to from the inside and out), </p> </li> <li> <p> avoiding nested function calls, </p> </li> <li> <p> minimizing the need for local variables and function definitions, and </p> </li> <li> <p> making it easy to add steps anywhere in the sequence of operations. </p> </li> </ul>  <p>The operators pipe their left-hand side values forward into expressions that appear on the right-hand side, i.e. one can replace <code>f(x)</code> with <code>x %&gt;% f</code>, where <code>%&gt;%</code> is the (main) pipe-operator. <br><br> Consider the example below. Four operations are performed to arrive at the desired data set, and they are written in a natural order: the same as the order of execution. Also, no temporary variables are needed. If yet another operation is required, it is straight-forward to add to the sequence of operations whereever it may be needed. <br><br> For a more detailed introduction see the vignette (<code>vignette('magrittr')</code>) or the documentation pages for the available operators:<br></p> <table summary='Rd table'> <tr> <td style='text-align: left;'><br />    <code>%&gt;%</code>  </td> <td style='text-align: left;'> forward-pipe operator.</td> </tr> <tr> <td style='text-align: left;'><br />    <code>%T&gt;%</code> </td> <td style='text-align: left;'> tee operator.</td> </tr> <tr> <td style='text-align: left;'><br />    <code>%&lt;&gt;%</code> </td> <td style='text-align: left;'> compound assignment pipe-operator.</td> </tr> <tr> <td style='text-align: left;'><br />    <code>%$%</code>  </td> <td style='text-align: left;'> exposition pipe-operator.</td> </tr> <tr> <td style='text-align: left;'> </td> </tr> </table> "	NA	NA	FALSE
"exposition"	"magrittr"	"magrittr exposition pipe-operator"	"<p>Expose the names in <code>lhs</code> to the <code>rhs</code> expression. This is useful when functions do not have a built-in data argument. </p>"	"<pre>lhs %$% rhs </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>lhs</code></td> <td> <p>A list, environment, or a data.frame.</p> </td> </tr> <tr valign='top'> <td><code>rhs</code></td> <td> <p>An expression where the names in lhs is available.</p> </td> </tr> </table> "	FALSE
"compound"	"magrittr"	"magrittr compound assignment pipe-operator"	"<p>Pipe an object forward into a function or call expression and update the <code>lhs</code> object with the resulting value. </p>"	"<pre>lhs %&lt;&gt;% rhs </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>lhs</code></td> <td> <p>An object which serves both as the initial value and as target.</p> </td> </tr> <tr valign='top'> <td><code>rhs</code></td> <td> <p>a function call using the magrittr semantics.</p> </td> </tr> </table> "	FALSE
"pipe"	"magrittr"	"magrittr forward-pipe operator"	"<p>Pipe an object forward into a function or call expression. </p>"	"<pre>lhs %&gt;% rhs </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>lhs</code></td> <td> <p>A value or the magrittr placeholder.</p> </td> </tr> <tr valign='top'> <td><code>rhs</code></td> <td> <p>A function call using the magrittr semantics.</p> </td> </tr> </table> "	FALSE
"tee"	"magrittr"	"magrittr tee operator"	"<p>Pipe a value forward into a function- or call expression and return the original value instead of the result. This is useful when an expression is used for its side-effect, say plotting or printing. </p>"	"<pre>lhs %T&gt;% rhs </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>lhs</code></td> <td> <p>A value or the magrittr placeholder.</p> </td> </tr> <tr valign='top'> <td><code>rhs</code></td> <td> <p>A function call using the magrittr semantics.</p> </td> </tr> </table> "	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"debug_fseq"	"magrittr"	"Debugging function for functional sequences."	"<p>This is a utility function for marking functions in a functional sequence for debbuging. </p>"	"<pre>debug_fseq(fseq, ...)<br />undebug_fseq(fseq) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>fseq</code></td> <td> <p>a functional sequence.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>indices of functions to debug.</p> </td> </tr> </table> "	FALSE
"debug_pipe"	"magrittr"	"Debugging function for magrittr pipelines."	"<p>This function is a wrapper around <code>browser</code>, which makes it easier to debug at certain places in a magrittr pipe chain. </p>"	"<pre>debug_pipe(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>a value</p> </td> </tr></table> "	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"freduce"	"magrittr"	"Apply a list of functions sequentially"	"<p>This function applies the first function to <code>value</code>, then the next function to the result of the previous function call, etc. </p>"	"<pre>freduce(value, function_list) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>value</code></td> <td> <p>initial value.</p> </td> </tr> <tr valign='top'> <td><code>function_list</code></td> <td> <p>a list of functions.</p> </td> </tr> </table> "	FALSE
"functions"	"magrittr"	"Extract the function list from a functional sequence."	"<p>This can be used to extract the list of functions inside a functional sequence created with a chain like <code>. %&gt;% foo %&gt;% bar</code>. </p>"	"<pre>functions(fseq) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>fseq</code></td> <td> <p>A functional sequence ala magrittr.</p> </td> </tr></table> "	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"magrittr"	"magrittr"	"magrittr - Ceci n'est pas un pipe"	"<p>The magrittr package offers a set of operators which promote semantics that will improve your code by </p> <ul> <li> <p> structuring sequences of data operations left-to-right (as opposed to from the inside and out), </p> </li> <li> <p> avoiding nested function calls, </p> </li> <li> <p> minimizing the need for local variables and function definitions, and </p> </li> <li> <p> making it easy to add steps anywhere in the sequence of operations. </p> </li> </ul>  <p>The operators pipe their left-hand side values forward into expressions that appear on the right-hand side, i.e. one can replace <code>f(x)</code> with <code>x %&gt;% f</code>, where <code>%&gt;%</code> is the (main) pipe-operator. <br><br> Consider the example below. Four operations are performed to arrive at the desired data set, and they are written in a natural order: the same as the order of execution. Also, no temporary variables are needed. If yet another operation is required, it is straight-forward to add to the sequence of operations whereever it may be needed. <br><br> For a more detailed introduction see the vignette (<code>vignette('magrittr')</code>) or the documentation pages for the available operators:<br></p> <table summary='Rd table'> <tr> <td style='text-align: left;'><br />    <code>%&gt;%</code>  </td> <td style='text-align: left;'> forward-pipe operator.</td> </tr> <tr> <td style='text-align: left;'><br />    <code>%T&gt;%</code> </td> <td style='text-align: left;'> tee operator.</td> </tr> <tr> <td style='text-align: left;'><br />    <code>%&lt;&gt;%</code> </td> <td style='text-align: left;'> compound assignment pipe-operator.</td> </tr> <tr> <td style='text-align: left;'><br />    <code>%$%</code>  </td> <td style='text-align: left;'> exposition pipe-operator.</td> </tr> <tr> <td style='text-align: left;'> </td> </tr> </table> "	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"print.fseq"	"magrittr"	"Print method for functional sequence."	"<p>Print method for functional sequence. </p>"	"<pre>## S3 method for class 'fseq' print(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A functional sequence object</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>not used.</p> </td> </tr> </table> "	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"debug_fseq"	"magrittr"	"Debugging function for functional sequences."	"<p>This is a utility function for marking functions in a functional sequence for debbuging. </p>"	"<pre>debug_fseq(fseq, ...)<br />undebug_fseq(fseq) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>fseq</code></td> <td> <p>a functional sequence.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>indices of functions to debug.</p> </td> </tr> </table> "	FALSE
"aliases"	"magrittr"	"Aliases"	"<p>magrittr provides a series of aliases which can be more pleasant to use when composing chains using the <code>%&gt;%</code> operator. </p>"	NA	NA	FALSE
"fseq"	"magrittr"	"Extract function(s) from a functional sequence."	"<p>Functional sequences can be subset using single or double brackets. A single-bracket subset results in a new functional sequence, and a double-bracket subset results in a single function. </p>"	"<pre>## S3 method for class 'fseq' x[[...]]<br />## S3 method for class 'fseq' x[...] </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A functional sequence</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>index/indices. For double brackets, the index must be of length 1.</p> </td> </tr> </table> "	FALSE
"fseq"	"magrittr"	"Extract function(s) from a functional sequence."	"<p>Functional sequences can be subset using single or double brackets. A single-bracket subset results in a new functional sequence, and a double-bracket subset results in a single function. </p>"	"<pre>## S3 method for class 'fseq' x[[...]]<br />## S3 method for class 'fseq' x[...] </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A functional sequence</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>index/indices. For double brackets, the index must be of length 1.</p> </td> </tr> </table> "	FALSE
"add_predictions"	"modelr"	"Add predictions to a data frame"	"<p>Add predictions to a data frame </p>"	"<pre>add_predictions(data, model, var = 'pred')<br />spread_predictions(data, ...)<br />gather_predictions(data, ..., .pred = 'pred', .model = 'model') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame used to generate the predictions.</p> </td> </tr> <tr valign='top'> <td><code>model, var</code></td> <td> <p><code>add_predictions</code> takes a single <code>model</code>; the output column will be called <code>pred</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p><code>gather_predictions</code> and <code>spread_predictions</code> take multiple models. The name will be taken from either the argument name of the name of the model.</p> </td> </tr> <tr valign='top'> <td><code>.pred, .model</code></td> <td> <p>The variable names used by <code>gather_predictions</code>.</p> </td> </tr> </table> "	FALSE
"add_predictors"	"modelr"	"Add predictors to a formula"	"<p>This merges a one- or two-sided formula <code>f</code> with the right-hand sides of all formulas supplied in <code>...</code>. </p>"	"<pre>add_predictors(f, ..., fun = '+') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>f</code></td> <td> <p>A formula.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Formulas whose right-hand sides will be merged to <code>f</code>.</p> </td> </tr> <tr valign='top'> <td><code>fun</code></td> <td> <p>A function name indicating how to merge the right-hand sides.</p> </td> </tr> </table> "	FALSE
"add_residuals"	"modelr"	"Add residuals to a data frame"	"<p>Add residuals to a data frame </p>"	"<pre>add_residuals(data, model, var = 'resid')<br />spread_residuals(data, ...)<br />gather_residuals(data, ..., .resid = 'resid', .model = 'model') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame used to generate the residuals</p> </td> </tr> <tr valign='top'> <td><code>model, var</code></td> <td> <p><code>add_residuals</code> takes a single <code>model</code>; the output column will be called <code>pred</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p><code>gather_residuals</code> and <code>spread_residuals</code> take multiple models. The name will be taken from either the argument name of the name of the model.</p> </td> </tr> <tr valign='top'> <td><code>.resid, .model</code></td> <td> <p>The variable names used by <code>gather_residuals</code>.</p> </td> </tr> </table> "	FALSE
"bootstrap"	"modelr"	"Generate n bootstrap replicates."	"<p>Generate <code>n</code> bootstrap replicates. </p>"	"<pre>bootstrap(data, n, id = '.id') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Number of test-training pairs to generate</p> </td> </tr> <tr valign='top'> <td><code>id</code></td> <td> <p>Name of variable that gives each model a unique integer id.</p> </td> </tr> </table> "	FALSE
"crossv_mc"	"modelr"	"Generate cross-validated test-training pairs"	"<p><code>crossv_kfold</code> splits the data into <code>k</code> exclusive partitions, and uses each partition for a test-training split. <code>crossv_mc</code> generates <code>n</code> random partitions, holding out <code>p</code> of the data for training. </p>"	"<pre>crossv_mc(data, n, test = 0.2, id = '.id')<br />crossv_kfold(data, k = 5, id = '.id') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Number of test-training pairs to generate (an integer).</p> </td> </tr> <tr valign='top'> <td><code>test</code></td> <td> <p>Proportion of observations that should be held out for testing (a double).</p> </td> </tr> <tr valign='top'> <td><code>id</code></td> <td> <p>Name of variable that gives each model a unique integer id.</p> </td> </tr> <tr valign='top'> <td><code>k</code></td> <td> <p>Number of folds (an integer).</p> </td> </tr> </table> "	FALSE
"crossv_mc"	"modelr"	"Generate cross-validated test-training pairs"	"<p><code>crossv_kfold</code> splits the data into <code>k</code> exclusive partitions, and uses each partition for a test-training split. <code>crossv_mc</code> generates <code>n</code> random partitions, holding out <code>p</code> of the data for training. </p>"	"<pre>crossv_mc(data, n, test = 0.2, id = '.id')<br />crossv_kfold(data, k = 5, id = '.id') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Number of test-training pairs to generate (an integer).</p> </td> </tr> <tr valign='top'> <td><code>test</code></td> <td> <p>Proportion of observations that should be held out for testing (a double).</p> </td> </tr> <tr valign='top'> <td><code>id</code></td> <td> <p>Name of variable that gives each model a unique integer id.</p> </td> </tr> <tr valign='top'> <td><code>k</code></td> <td> <p>Number of folds (an integer).</p> </td> </tr> </table> "	FALSE
"data_grid"	"modelr"	"Generate a data grid."	"<p>To visualise a model, it is very useful to be able to generate an evenly spaced grid of points from the data. <code>data_grid</code> helps you do this by wrapping around <code>expand()</code>. </p>"	"<pre>data_grid(data, ..., .model = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Variables passed on to <code>expand()</code></p> </td> </tr> <tr valign='top'> <td><code>.model</code></td> <td> <p>A model.  If supplied, any predictors needed for the model not present in <code>...</code> will be filled in with 'typical' values.</p> </td> </tr> </table> "	FALSE
"fit_with"	"modelr"	"Fit a list of formulas"	"<p><code>fit_with()</code> is a pipe-friendly tool that applies a list of formulas to a fitting function such as <code>lm()</code>. The list of formulas is typically created with <code>formulas</code>(). </p>"	"<pre>fit_with(data, .f, .formulas, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A dataset used to fit the models.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A fitting function such as <code>lm()</code>, <code>lmer</code>() or <code>stan_glmer()</code>.</p> </td> </tr> <tr valign='top'> <td><code>.formulas</code></td> <td> <p>A list of formulas specifying a model.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code></p> </td> </tr> </table> "	FALSE
"formulas"	"modelr"	"Create a list of formulas"	"<p><code>formulas()</code> creates a list of two-sided formulas by merging a unique left-hand side to a list of right-hand sides. </p>"	"<pre>formulas(.response, ...)<br />formulae(.response, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.response</code></td> <td> <p>A one-sided formula used as the left-hand side of all resulting formulas.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>List of formulas whose right-hand sides will be merged to <code>.response</code>.</p> </td> </tr> </table> "	FALSE
"formulas"	"modelr"	"Create a list of formulas"	"<p><code>formulas()</code> creates a list of two-sided formulas by merging a unique left-hand side to a list of right-hand sides. </p>"	"<pre>formulas(.response, ...)<br />formulae(.response, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.response</code></td> <td> <p>A one-sided formula used as the left-hand side of all resulting formulas.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>List of formulas whose right-hand sides will be merged to <code>.response</code>.</p> </td> </tr> </table> "	FALSE
"add_predictions"	"modelr"	"Add predictions to a data frame"	"<p>Add predictions to a data frame </p>"	"<pre>add_predictions(data, model, var = 'pred')<br />spread_predictions(data, ...)<br />gather_predictions(data, ..., .pred = 'pred', .model = 'model') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame used to generate the predictions.</p> </td> </tr> <tr valign='top'> <td><code>model, var</code></td> <td> <p><code>add_predictions</code> takes a single <code>model</code>; the output column will be called <code>pred</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p><code>gather_predictions</code> and <code>spread_predictions</code> take multiple models. The name will be taken from either the argument name of the name of the model.</p> </td> </tr> <tr valign='top'> <td><code>.pred, .model</code></td> <td> <p>The variable names used by <code>gather_predictions</code>.</p> </td> </tr> </table> "	FALSE
"add_residuals"	"modelr"	"Add residuals to a data frame"	"<p>Add residuals to a data frame </p>"	"<pre>add_residuals(data, model, var = 'resid')<br />spread_residuals(data, ...)<br />gather_residuals(data, ..., .resid = 'resid', .model = 'model') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame used to generate the residuals</p> </td> </tr> <tr valign='top'> <td><code>model, var</code></td> <td> <p><code>add_residuals</code> takes a single <code>model</code>; the output column will be called <code>pred</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p><code>gather_residuals</code> and <code>spread_residuals</code> take multiple models. The name will be taken from either the argument name of the name of the model.</p> </td> </tr> <tr valign='top'> <td><code>.resid, .model</code></td> <td> <p>The variable names used by <code>gather_residuals</code>.</p> </td> </tr> </table> "	FALSE
"geom_ref_line"	"modelr"	"Add a reference line (ggplot2)."	"<p>Add a reference line (ggplot2). </p>"	"<pre>geom_ref_line(h, v, size = 2, colour = 'white') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>h, v</code></td> <td> <p>Position of horizontal or vertical reference line</p> </td> </tr> <tr valign='top'> <td><code>size</code></td> <td> <p>Line size</p> </td> </tr> <tr valign='top'> <td><code>colour</code></td> <td> <p>Line colour</p> </td> </tr> </table>"	FALSE
"heights"	"modelr"	"Height and income data."	"<p>You might have heard that taller people earn more. Is it true? You can try and answer the question by exploring this dataset extracted from the <a href='https://www.nlsinfo.org'>National Longitudinal Study</a>, which is sponsored by the U.S. Bureau of Labor Statistics. </p>"	"<pre>heights </pre>"	NA	FALSE
"model-quality"	"modelr"	"Compute model quality for a given dataset"	"<p><code>rmse</code> is the root-mean-squared-error, <code>mae</code> is the mean absolute error, <code>qae</code> is quantiles of absolute error. These can both be interpreted on the scale of the response; <code>mae</code> is less sensitive to outliers. <code>rsquare</code> is the variance of the predictions divided by by the variance of the response. </p>"	"<pre>rmse(model, data)<br />mae(model, data)<br />rsquare(model, data)<br />qae(model, data, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>model</code></td> <td> <p>A model</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The dataset</p> </td> </tr> <tr valign='top'> <td><code>probs</code></td> <td> <p>Numeric vector of probabilit</p> </td> </tr> </table> "	FALSE
"model-quality"	"modelr"	"Compute model quality for a given dataset"	"<p><code>rmse</code> is the root-mean-squared-error, <code>mae</code> is the mean absolute error, <code>qae</code> is quantiles of absolute error. These can both be interpreted on the scale of the response; <code>mae</code> is less sensitive to outliers. <code>rsquare</code> is the variance of the predictions divided by by the variance of the response. </p>"	"<pre>rmse(model, data)<br />mae(model, data)<br />rsquare(model, data)<br />qae(model, data, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>model</code></td> <td> <p>A model</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The dataset</p> </td> </tr> <tr valign='top'> <td><code>probs</code></td> <td> <p>Numeric vector of probabilit</p> </td> </tr> </table> "	FALSE
"model_matrix"	"modelr"	"Construct a design matrix"	"<p>This is a thin wrapper around <code>model.matrix()</code> which returns a tibble. Use it to determine how your modelling formula is translated into a matrix, an thence into an equation. </p>"	"<pre>model_matrix(data, formula, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>formula</code></td> <td> <p>A modelling formula</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed onto <code>model.matrix()</code></p> </td> </tr> </table> "	FALSE
"na.warn"	"modelr"	"Handle missing values with a warning"	"<p>This NA handler works ensures that those models that support the <code>na.action</code> parameter do not silently drop missing values. It wraps around <code>na.exclude</code> so that there is one prediction/residual for input row. To apply it globally, run <code>options(na.action = na.warn)</code>. </p>"	"<pre>na.warn(object) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>object</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments (not currently used)</p> </td> </tr> </table> "	FALSE
"model-quality"	"modelr"	"Compute model quality for a given dataset"	"<p><code>rmse</code> is the root-mean-squared-error, <code>mae</code> is the mean absolute error, <code>qae</code> is quantiles of absolute error. These can both be interpreted on the scale of the response; <code>mae</code> is less sensitive to outliers. <code>rsquare</code> is the variance of the predictions divided by by the variance of the response. </p>"	"<pre>rmse(model, data)<br />mae(model, data)<br />rsquare(model, data)<br />qae(model, data, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>model</code></td> <td> <p>A model</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The dataset</p> </td> </tr> <tr valign='top'> <td><code>probs</code></td> <td> <p>Numeric vector of probabilit</p> </td> </tr> </table> "	FALSE
"resample"	"modelr"	"A \"lazy\" resample."	"<p>Often you will resample a dataset hundreds or thousands of times. Storing the complete resample each time would be very inefficient so this class instead stores a 'pointer' to the original dataset, and a vector of row indexes. To turn this into a regular data frame, call <code>as.data.frame</code>, to extract the indices, use <code>as.integer</code>. </p>"	"<pre>resample(data, idx) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>The data frame</p> </td> </tr> <tr valign='top'> <td><code>idx</code></td> <td> <p>A vector of integer indexes indicating which rows have been selected. These values should lie between 1 and <code>nrow(data)</code> but they are not checked by this function in the interests of performance.</p> </td> </tr> </table> "	FALSE
"resample_bootstrap"	"modelr"	"Generate a boostrap replicate"	"<p>Generate a boostrap replicate </p>"	"<pre>resample_bootstrap(data) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr></table> "	FALSE
"resample_partition"	"modelr"	"Generate an exclusive partitioning of a data frame"	"<p>Generate an exclusive partitioning of a data frame </p>"	"<pre>resample_partition(data, p) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>p</code></td> <td> <p>A named numeric vector giving where the value is the probability that an observation will be assigned to that group.</p> </td> </tr> </table> "	FALSE
"model-quality"	"modelr"	"Compute model quality for a given dataset"	"<p><code>rmse</code> is the root-mean-squared-error, <code>mae</code> is the mean absolute error, <code>qae</code> is quantiles of absolute error. These can both be interpreted on the scale of the response; <code>mae</code> is less sensitive to outliers. <code>rsquare</code> is the variance of the predictions divided by by the variance of the response. </p>"	"<pre>rmse(model, data)<br />mae(model, data)<br />rsquare(model, data)<br />qae(model, data, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>model</code></td> <td> <p>A model</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The dataset</p> </td> </tr> <tr valign='top'> <td><code>probs</code></td> <td> <p>Numeric vector of probabilit</p> </td> </tr> </table> "	FALSE
"model-quality"	"modelr"	"Compute model quality for a given dataset"	"<p><code>rmse</code> is the root-mean-squared-error, <code>mae</code> is the mean absolute error, <code>qae</code> is quantiles of absolute error. These can both be interpreted on the scale of the response; <code>mae</code> is less sensitive to outliers. <code>rsquare</code> is the variance of the predictions divided by by the variance of the response. </p>"	"<pre>rmse(model, data)<br />mae(model, data)<br />rsquare(model, data)<br />qae(model, data, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>model</code></td> <td> <p>A model</p> </td> </tr> <tr valign='top'> <td><code>data</code></td> <td> <p>The dataset</p> </td> </tr> <tr valign='top'> <td><code>probs</code></td> <td> <p>Numeric vector of probabilit</p> </td> </tr> </table> "	FALSE
"seq_range"	"modelr"	"Generate a sequence over the range of a vector"	"<p>Generate a sequence over the range of a vector </p>"	"<pre>seq_range(x, n, by, trim = NULL, expand = NULL, pretty = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A numeric vector</p> </td> </tr> <tr valign='top'> <td><code>n, by</code></td> <td> <p>Specify the output sequence either by supplying the length of the sequence with <code>n</code>, or the spacing between value with <code>by</code>. Specifying both is an error. </p> <p>I recommend that you name these arguments in order to make it clear to the reader.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>Optionally, trim values off the tails. <code>trim / 2 * length(x)</code> values are removed from each tail.</p> </td> </tr> <tr valign='top'> <td><code>expand</code></td> <td> <p>Optionally, expand the range by <code>expand * (1 + range(x)</code> (computed after trimming).</p> </td> </tr> <tr valign='top'> <td><code>pretty</code></td> <td> <p>If <code>TRUE</code>, will generate a pretty sequence. If <code>n</code> is supplied, this will use <code>pretty()</code> instead of <code>seq()</code>. If <code>by</code> is supplied, it will round the first value to a multiple of <code>by</code>.</p> </td> </tr> </table> "	FALSE
"sim"	"modelr"	"Simple simulated datasets"	"<p>These simple simulated datasets are useful for teaching modelling basics. </p>"	"<pre>sim1<br />sim2<br />sim3<br />sim4 </pre>"	NA	FALSE
"sim"	"modelr"	"Simple simulated datasets"	"<p>These simple simulated datasets are useful for teaching modelling basics. </p>"	"<pre>sim1<br />sim2<br />sim3<br />sim4 </pre>"	NA	FALSE
"sim"	"modelr"	"Simple simulated datasets"	"<p>These simple simulated datasets are useful for teaching modelling basics. </p>"	"<pre>sim1<br />sim2<br />sim3<br />sim4 </pre>"	NA	FALSE
"sim"	"modelr"	"Simple simulated datasets"	"<p>These simple simulated datasets are useful for teaching modelling basics. </p>"	"<pre>sim1<br />sim2<br />sim3<br />sim4 </pre>"	NA	FALSE
"sim"	"modelr"	"Simple simulated datasets"	"<p>These simple simulated datasets are useful for teaching modelling basics. </p>"	"<pre>sim1<br />sim2<br />sim3<br />sim4 </pre>"	NA	FALSE
"add_predictions"	"modelr"	"Add predictions to a data frame"	"<p>Add predictions to a data frame </p>"	"<pre>add_predictions(data, model, var = 'pred')<br />spread_predictions(data, ...)<br />gather_predictions(data, ..., .pred = 'pred', .model = 'model') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame used to generate the predictions.</p> </td> </tr> <tr valign='top'> <td><code>model, var</code></td> <td> <p><code>add_predictions</code> takes a single <code>model</code>; the output column will be called <code>pred</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p><code>gather_predictions</code> and <code>spread_predictions</code> take multiple models. The name will be taken from either the argument name of the name of the model.</p> </td> </tr> <tr valign='top'> <td><code>.pred, .model</code></td> <td> <p>The variable names used by <code>gather_predictions</code>.</p> </td> </tr> </table> "	FALSE
"add_residuals"	"modelr"	"Add residuals to a data frame"	"<p>Add residuals to a data frame </p>"	"<pre>add_residuals(data, model, var = 'resid')<br />spread_residuals(data, ...)<br />gather_residuals(data, ..., .resid = 'resid', .model = 'model') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame used to generate the residuals</p> </td> </tr> <tr valign='top'> <td><code>model, var</code></td> <td> <p><code>add_residuals</code> takes a single <code>model</code>; the output column will be called <code>pred</code></p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p><code>gather_residuals</code> and <code>spread_residuals</code> take multiple models. The name will be taken from either the argument name of the name of the model.</p> </td> </tr> <tr valign='top'> <td><code>.resid, .model</code></td> <td> <p>The variable names used by <code>gather_residuals</code>.</p> </td> </tr> </table> "	FALSE
"typical"	"modelr"	"Find the typical value"	"<p>For numeric vectors, it retunrs the median. For factors, characters, and logical vectors, it returns the most frequent value. If multiple values are tied for most frequent, it returns them all. <code>NA</code> missing values are always silently dropped. </p>"	"<pre>typical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A vector</p> </td> </tr></table> "	FALSE
"accumulate"	"purrr"	"Accumulate recursive folds across a list"	"<p><code>accumulate</code> applies a function recursively over a list from the left, while <code>accumulate_right</code> applies the function from the right. Unlike <code>reduce</code> both functions keep the intermediate results. </p>"	"<pre>accumulate(.x, .f, ..., .init)<br />accumulate_right(.x, .f, ..., .init) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A two-argument function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.init</code></td> <td> <p>If supplied, will be used as the first value to start the accumulation, rather than using <code>x[[1]]</code>. This is useful if you want to ensure that <code>reduce</code> returns the correct value when <code>.x</code> is <code>is_empty()</code>.</p> </td> </tr> </table> "	FALSE
"accumulate"	"purrr"	"Accumulate recursive folds across a list"	"<p><code>accumulate</code> applies a function recursively over a list from the left, while <code>accumulate_right</code> applies the function from the right. Unlike <code>reduce</code> both functions keep the intermediate results. </p>"	"<pre>accumulate(.x, .f, ..., .init)<br />accumulate_right(.x, .f, ..., .init) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A two-argument function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.init</code></td> <td> <p>If supplied, will be used as the first value to start the accumulation, rather than using <code>x[[1]]</code>. This is useful if you want to ensure that <code>reduce</code> returns the correct value when <code>.x</code> is <code>is_empty()</code>.</p> </td> </tr> </table> "	FALSE
"along"	"purrr"	"Helper to create vectors with matching length."	"<p>These functions take the idea of <code>seq_along</code> and generalise it to creating lists (<code>list_along</code>) and repeating values (<code>rep_along</code>). </p>"	"<pre>list_along(x)<br />rep_along(x, y) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A vector.</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>Values to repeat.</p> </td> </tr> </table> "	FALSE
"array-coercion"	"purrr"	"Coerce array to list"	"<p><code>array_branch()</code> and <code>array_tree()</code> enable arrays to be used with purrr's functionals by turning them into lists. The details of the coercion are controlled by the <code>margin</code> argument. <code>array_tree()</code> creates an hierarchical list (a tree) that has as many levels as dimensions specified in <code>margin</code>, while <code>array_branch()</code> creates a flat list (by analogy, a branch) along all mentioned dimensions. </p>"	"<pre>array_branch(array, margin = NULL)<br />array_tree(array, margin = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>array</code></td> <td> <p>An array to coerce into a list.</p> </td> </tr> <tr valign='top'> <td><code>margin</code></td> <td> <p>A numeric vector indicating the positions of the indices to be to be enlisted. If <code>NULL</code>, a full margin is used. If <code>numeric(0)</code>, the array as a whole is wrapped in a list.</p> </td> </tr> </table> "	FALSE
"array-coercion"	"purrr"	"Coerce array to list"	"<p><code>array_branch()</code> and <code>array_tree()</code> enable arrays to be used with purrr's functionals by turning them into lists. The details of the coercion are controlled by the <code>margin</code> argument. <code>array_tree()</code> creates an hierarchical list (a tree) that has as many levels as dimensions specified in <code>margin</code>, while <code>array_branch()</code> creates a flat list (by analogy, a branch) along all mentioned dimensions. </p>"	"<pre>array_branch(array, margin = NULL)<br />array_tree(array, margin = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>array</code></td> <td> <p>An array to coerce into a list.</p> </td> </tr> <tr valign='top'> <td><code>margin</code></td> <td> <p>A numeric vector indicating the positions of the indices to be to be enlisted. If <code>NULL</code>, a full margin is used. If <code>numeric(0)</code>, the array as a whole is wrapped in a list.</p> </td> </tr> </table> "	FALSE
"array-coercion"	"purrr"	"Coerce array to list"	"<p><code>array_branch()</code> and <code>array_tree()</code> enable arrays to be used with purrr's functionals by turning them into lists. The details of the coercion are controlled by the <code>margin</code> argument. <code>array_tree()</code> creates an hierarchical list (a tree) that has as many levels as dimensions specified in <code>margin</code>, while <code>array_branch()</code> creates a flat list (by analogy, a branch) along all mentioned dimensions. </p>"	"<pre>array_branch(array, margin = NULL)<br />array_tree(array, margin = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>array</code></td> <td> <p>An array to coerce into a list.</p> </td> </tr> <tr valign='top'> <td><code>margin</code></td> <td> <p>A numeric vector indicating the positions of the indices to be to be enlisted. If <code>NULL</code>, a full margin is used. If <code>numeric(0)</code>, the array as a whole is wrapped in a list.</p> </td> </tr> </table> "	FALSE
"as_function"	"purrr"	"Convert an object into a function."	"<p><code>as_function</code> is the powerhouse behind the varied function specifications that purrr functions allow. This is an S3 generic so that other people can make <code>as_function</code> work with their own objects. </p>"	"<pre>as_function(.f, ...)<br />## S3 method for class 'character' as_function(.f, ..., .null = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to methods.</p> </td> </tr> <tr valign='top'> <td><code>.null</code></td> <td> <p>Optional additional argument for character and numeric inputs.</p> </td> </tr> </table> "	FALSE
"as_function"	"purrr"	"Convert an object into a function."	"<p><code>as_function</code> is the powerhouse behind the varied function specifications that purrr functions allow. This is an S3 generic so that other people can make <code>as_function</code> work with their own objects. </p>"	"<pre>as_function(.f, ...)<br />## S3 method for class 'character' as_function(.f, ..., .null = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to methods.</p> </td> </tr> <tr valign='top'> <td><code>.null</code></td> <td> <p>Optional additional argument for character and numeric inputs.</p> </td> </tr> </table> "	FALSE
"as_vector"	"purrr"	"Coerce a list to a vector"	"<p><code>as_vector()</code> collapses a list of vectors into one vector. It checks that the type of each vector is consistent with <code>.type</code>. If the list can not be simplified, it throws an error. <code>simplify</code> will simplify a vector if possible; <code>simplify_all</code> will apply <code>simplify</code> to every element of a list. </p>"	"<pre>as_vector(.x, .type = NULL)<br />simplify(.x, .type = NULL)<br />simplify_all(.x, .type = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list of vectors</p> </td> </tr> <tr valign='top'> <td><code>.type</code></td> <td> <p>A vector mold or a string describing the type of the input vectors. The latter can be any of the types returned by <code>typeof()</code>, or 'numeric' as a shorthand for either 'double' or 'integer'.</p> </td> </tr> </table> "	FALSE
"at_depth"	"purrr"	"Map a function over lower levels of a nested list"	"<p><code>at_depth()</code> maps a function on lower levels of nested lists. In essence, <code>at_depth()</code> is a recursive map. </p>"	"<pre>at_depth(.x, .depth, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A deep list</p> </td> </tr> <tr valign='top'> <td><code>.depth</code></td> <td> <p>Level of <code>.x</code> to map on.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> </table> "	FALSE
"bare-type-predicates"	"purrr"	"Bare type predicates"	"<p>These predicates check for a given type but only return <code>TRUE</code> for bare R objects. Bare objects have no class attributes. For example, a data frame is a list, but not a bare list. </p>"	"<pre>is_bare_list(x)<br />is_bare_atomic(x)<br />is_bare_vector(x)<br />is_bare_double(x)<br />is_bare_integer(x)<br />is_bare_numeric(x)<br />is_bare_character(x)<br />is_bare_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"by_row"	"purrr"	"Apply a function to each row of a data frame"	"<p><code>by_row()</code> and <code>invoke_rows()</code> apply <code>..f</code> to each row of <code>.d</code>. If <code>..f</code>'s output is not a data frame nor an atomic vector, a list-column is created. In all cases, <code>by_row()</code> and <code>invoke_rows()</code> create a data frame in tidy format. </p>"	"<pre>by_row(.d, ..f, ..., .collate = c('list', 'rows', 'cols'), .to = '.out',<br />   .labels = TRUE)<br />invoke_rows(.f, .d, ..., .collate = c('list', 'rows', 'cols'), .to = '.out',<br />   .labels = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.d</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further arguments passed to <code>..f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.collate</code></td> <td> <p>If 'list', the results are returned as a list- column. Alternatively, if the results are data frames or atomic vectors, you can collate on 'cols' or on 'rows'. Column collation require vector of equal length or data frames with same number of rows.</p> </td> </tr> <tr valign='top'> <td><code>.to</code></td> <td> <p>Name of output column.</p> </td> </tr> <tr valign='top'> <td><code>.labels</code></td> <td> <p>If <code>TRUE</code>, the returned data frame is prepended with the labels of the slices (the columns in <code>.d</code> used to define the slices). They are recycled to match the output size in each slice if necessary.</p> </td> </tr> <tr valign='top'> <td><code>.f, ..f</code></td> <td> <p>A function to apply to each row. If <code>..f</code> does not return a data frame or an atomic vector, a list-column is created under the name <code>.out</code>. If it returns a data frame, it should have the same number of rows within groups and the same number of columns between groups.</p> </td> </tr> </table> "	FALSE
"by_slice"	"purrr"	"Apply a function to slices of a data frame"	"<p><code>by_slice()</code> applies <code>..f</code> on each group of a data frame. Groups should be set with <code>slice_rows()</code> or <code>group_by()</code>. </p>"	"<pre>by_slice(.d, ..f, ..., .collate = c('list', 'rows', 'cols'), .to = '.out',<br />   .labels = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.d</code></td> <td> <p>A sliced data frame.</p> </td> </tr> <tr valign='top'> <td><code>..f</code></td> <td> <p>A function to apply to each slice. If <code>..f</code> does not return a data frame or an atomic vector, a list-column is created under the name <code>.out</code>. If it returns a data frame, it should have the same number of rows within groups and the same number of columns between groups.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further arguments passed to <code>..f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.collate</code></td> <td> <p>If 'list', the results are returned as a list- column. Alternatively, if the results are data frames or atomic vectors, you can collate on 'cols' or on 'rows'. Column collation require vector of equal length or data frames with same number of rows.</p> </td> </tr> <tr valign='top'> <td><code>.to</code></td> <td> <p>Name of output column.</p> </td> </tr> <tr valign='top'> <td><code>.labels</code></td> <td> <p>If <code>TRUE</code>, the returned data frame is prepended with the labels of the slices (the columns in <code>.d</code> used to define the slices). They are recycled to match the output size in each slice if necessary.</p> </td> </tr> </table> "	FALSE
"keep"	"purrr"	"Keep or discard elements using a predicate function."	"<p><code>keep</code> and <code>discard</code> are opposites. <code>compact</code> is a handy wrapper that removes all elements that are <code>NULL</code>. </p>"	"<pre>keep(.x, .p, ...)<br />discard(.x, .p, ...)<br />compact(.x, .p = identity) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.p</code>.</p> </td> </tr> </table> "	FALSE
"compose"	"purrr"	"Compose multiple functions"	"<p>Compose multiple functions </p>"	"<pre>compose(...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>...</code></td> <td> <p>n functions to apply in order from right to left.</p> </td> </tr></table> "	FALSE
"conditional-map"	"purrr"	"Modify elements conditionally"	"<p><code>map_if()</code> maps a function over the elements of <code>.x</code> satisfying a predicate. <code>map_at()</code> is similar but will modify the elements corresponding to a character vector of names or a mumeric vector of positions. </p>"	"<pre>map_if(.x, .p, .f, ...)<br />map_at(.x, .at, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.at</code></td> <td> <p>A character vector of names or a numeric vector of positions. Only those elements corresponding to <code>.at</code> will be modified.</p> </td> </tr> </table> "	FALSE
"contains"	"purrr"	"Does a list contain an object?"	"<p>Does a list contain an object? </p>"	"<pre>contains(.x, .y) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.y</code></td> <td> <p>Object to test for</p> </td> </tr> </table> "	FALSE
"cross_n"	"purrr"	"Produce all combinations of list elements"	"<p><code>cross2()</code> returns the product set of the elements of <code>.x</code> and <code>.y</code>. <code>cross3()</code> takes an additional <code>.z</code> argument. <code>cross_n()</code> takes a list <code>.l</code> and returns the cartesian product of all its elements in a list, with one combination by element. <code>cross_d()</code> is like <code>cross_n()</code> but returns a data frame, with one combination by row. </p>"	"<pre>cross_n(.l, .filter = NULL)<br />cross2(.x, .y, .filter = NULL)<br />cross3(.x, .y, .z, .filter = NULL)<br />cross_d(.l, .filter = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists or atomic vectors. Alternatively, a data frame. <code>cross_d()</code> requires all elements to be named.</p> </td> </tr> <tr valign='top'> <td><code>.filter</code></td> <td> <p>A predicate function that takes the same number of arguments as the number of variables to be combined.</p> </td> </tr> <tr valign='top'> <td><code>.x, .y, .z</code></td> <td> <p>Lists or atomic vectors.</p> </td> </tr> </table> "	FALSE
"cross_n"	"purrr"	"Produce all combinations of list elements"	"<p><code>cross2()</code> returns the product set of the elements of <code>.x</code> and <code>.y</code>. <code>cross3()</code> takes an additional <code>.z</code> argument. <code>cross_n()</code> takes a list <code>.l</code> and returns the cartesian product of all its elements in a list, with one combination by element. <code>cross_d()</code> is like <code>cross_n()</code> but returns a data frame, with one combination by row. </p>"	"<pre>cross_n(.l, .filter = NULL)<br />cross2(.x, .y, .filter = NULL)<br />cross3(.x, .y, .z, .filter = NULL)<br />cross_d(.l, .filter = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists or atomic vectors. Alternatively, a data frame. <code>cross_d()</code> requires all elements to be named.</p> </td> </tr> <tr valign='top'> <td><code>.filter</code></td> <td> <p>A predicate function that takes the same number of arguments as the number of variables to be combined.</p> </td> </tr> <tr valign='top'> <td><code>.x, .y, .z</code></td> <td> <p>Lists or atomic vectors.</p> </td> </tr> </table> "	FALSE
"cross_n"	"purrr"	"Produce all combinations of list elements"	"<p><code>cross2()</code> returns the product set of the elements of <code>.x</code> and <code>.y</code>. <code>cross3()</code> takes an additional <code>.z</code> argument. <code>cross_n()</code> takes a list <code>.l</code> and returns the cartesian product of all its elements in a list, with one combination by element. <code>cross_d()</code> is like <code>cross_n()</code> but returns a data frame, with one combination by row. </p>"	"<pre>cross_n(.l, .filter = NULL)<br />cross2(.x, .y, .filter = NULL)<br />cross3(.x, .y, .z, .filter = NULL)<br />cross_d(.l, .filter = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists or atomic vectors. Alternatively, a data frame. <code>cross_d()</code> requires all elements to be named.</p> </td> </tr> <tr valign='top'> <td><code>.filter</code></td> <td> <p>A predicate function that takes the same number of arguments as the number of variables to be combined.</p> </td> </tr> <tr valign='top'> <td><code>.x, .y, .z</code></td> <td> <p>Lists or atomic vectors.</p> </td> </tr> </table> "	FALSE
"cross_n"	"purrr"	"Produce all combinations of list elements"	"<p><code>cross2()</code> returns the product set of the elements of <code>.x</code> and <code>.y</code>. <code>cross3()</code> takes an additional <code>.z</code> argument. <code>cross_n()</code> takes a list <code>.l</code> and returns the cartesian product of all its elements in a list, with one combination by element. <code>cross_d()</code> is like <code>cross_n()</code> but returns a data frame, with one combination by row. </p>"	"<pre>cross_n(.l, .filter = NULL)<br />cross2(.x, .y, .filter = NULL)<br />cross3(.x, .y, .z, .filter = NULL)<br />cross_d(.l, .filter = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists or atomic vectors. Alternatively, a data frame. <code>cross_d()</code> requires all elements to be named.</p> </td> </tr> <tr valign='top'> <td><code>.filter</code></td> <td> <p>A predicate function that takes the same number of arguments as the number of variables to be combined.</p> </td> </tr> <tr valign='top'> <td><code>.x, .y, .z</code></td> <td> <p>Lists or atomic vectors.</p> </td> </tr> </table> "	FALSE
"detect"	"purrr"	"Find the value or position of the first match."	"<p>Find the value or position of the first match. </p>"	"<pre>detect(.x, .p, ..., .right = FALSE)<br />detect_index(.x, .p, ..., .right = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.right</code></td> <td> <p>If <code>FALSE</code>, the default, starts at the beginnging of the vector and move towards the end; if <code>TRUE</code>, starts at the end of the vector and moves towards the beginning.</p> </td> </tr> </table> "	FALSE
"detect"	"purrr"	"Find the value or position of the first match."	"<p>Find the value or position of the first match. </p>"	"<pre>detect(.x, .p, ..., .right = FALSE)<br />detect_index(.x, .p, ..., .right = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.right</code></td> <td> <p>If <code>FALSE</code>, the default, starts at the beginnging of the vector and move towards the end; if <code>TRUE</code>, starts at the end of the vector and moves towards the beginning.</p> </td> </tr> </table> "	FALSE
"keep"	"purrr"	"Keep or discard elements using a predicate function."	"<p><code>keep</code> and <code>discard</code> are opposites. <code>compact</code> is a handy wrapper that removes all elements that are <code>NULL</code>. </p>"	"<pre>keep(.x, .p, ...)<br />discard(.x, .p, ...)<br />compact(.x, .p = identity) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.p</code>.</p> </td> </tr> </table> "	FALSE
"dmap"	"purrr"	"Map over the columns of a data frame"	"<p><code>dmap()</code> is just like <code>map()</code> but always returns a data frame. In addition, it handles grouped or sliced data frames. </p>"	"<pre>dmap(.d, .f, ...)<br />dmap_at(.d, .at, .f, ...)<br />dmap_if(.d, .p, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.d</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.at</code></td> <td> <p>A character vector of names or a numeric vector of positions. Only those elements corresponding to <code>.at</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> </table> "	FALSE
"dmap"	"purrr"	"Map over the columns of a data frame"	"<p><code>dmap()</code> is just like <code>map()</code> but always returns a data frame. In addition, it handles grouped or sliced data frames. </p>"	"<pre>dmap(.d, .f, ...)<br />dmap_at(.d, .at, .f, ...)<br />dmap_if(.d, .p, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.d</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.at</code></td> <td> <p>A character vector of names or a numeric vector of positions. Only those elements corresponding to <code>.at</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> </table> "	FALSE
"dmap"	"purrr"	"Map over the columns of a data frame"	"<p><code>dmap()</code> is just like <code>map()</code> but always returns a data frame. In addition, it handles grouped or sliced data frames. </p>"	"<pre>dmap(.d, .f, ...)<br />dmap_at(.d, .at, .f, ...)<br />dmap_if(.d, .p, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.d</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.at</code></td> <td> <p>A character vector of names or a numeric vector of positions. Only those elements corresponding to <code>.at</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> </table> "	FALSE
"every"	"purrr"	"Do every or some elements of a list satisfy a predicate?"	"<p>Do every or some elements of a list satisfy a predicate? </p>"	"<pre>every(.x, .p, ...)<br />some(.x, .p, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> </table> "	FALSE
"flatten"	"purrr"	"Flatten a list of lists into a simple vector."	"<p>These functions remove a level hierarchy from a list. They are similar to <code>unlist</code>, only ever remove a single layer of hierarchy, and are type-stable so you always know what the type of the output is. </p>"	"<pre>flatten(.x)<br />flatten_lgl(.x)<br />flatten_int(.x)<br />flatten_dbl(.x)<br />flatten_chr(.x)<br />flatten_df(.x, .id = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list of flatten. The contents of the list can be anything for <code>flatten</code> (as a list is returned), but the contents must match the type for the other functions.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"flatten"	"purrr"	"Flatten a list of lists into a simple vector."	"<p>These functions remove a level hierarchy from a list. They are similar to <code>unlist</code>, only ever remove a single layer of hierarchy, and are type-stable so you always know what the type of the output is. </p>"	"<pre>flatten(.x)<br />flatten_lgl(.x)<br />flatten_int(.x)<br />flatten_dbl(.x)<br />flatten_chr(.x)<br />flatten_df(.x, .id = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list of flatten. The contents of the list can be anything for <code>flatten</code> (as a list is returned), but the contents must match the type for the other functions.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"flatten"	"purrr"	"Flatten a list of lists into a simple vector."	"<p>These functions remove a level hierarchy from a list. They are similar to <code>unlist</code>, only ever remove a single layer of hierarchy, and are type-stable so you always know what the type of the output is. </p>"	"<pre>flatten(.x)<br />flatten_lgl(.x)<br />flatten_int(.x)<br />flatten_dbl(.x)<br />flatten_chr(.x)<br />flatten_df(.x, .id = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list of flatten. The contents of the list can be anything for <code>flatten</code> (as a list is returned), but the contents must match the type for the other functions.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"flatten"	"purrr"	"Flatten a list of lists into a simple vector."	"<p>These functions remove a level hierarchy from a list. They are similar to <code>unlist</code>, only ever remove a single layer of hierarchy, and are type-stable so you always know what the type of the output is. </p>"	"<pre>flatten(.x)<br />flatten_lgl(.x)<br />flatten_int(.x)<br />flatten_dbl(.x)<br />flatten_chr(.x)<br />flatten_df(.x, .id = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list of flatten. The contents of the list can be anything for <code>flatten</code> (as a list is returned), but the contents must match the type for the other functions.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"flatten"	"purrr"	"Flatten a list of lists into a simple vector."	"<p>These functions remove a level hierarchy from a list. They are similar to <code>unlist</code>, only ever remove a single layer of hierarchy, and are type-stable so you always know what the type of the output is. </p>"	"<pre>flatten(.x)<br />flatten_lgl(.x)<br />flatten_int(.x)<br />flatten_dbl(.x)<br />flatten_chr(.x)<br />flatten_df(.x, .id = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list of flatten. The contents of the list can be anything for <code>flatten</code> (as a list is returned), but the contents must match the type for the other functions.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"flatten"	"purrr"	"Flatten a list of lists into a simple vector."	"<p>These functions remove a level hierarchy from a list. They are similar to <code>unlist</code>, only ever remove a single layer of hierarchy, and are type-stable so you always know what the type of the output is. </p>"	"<pre>flatten(.x)<br />flatten_lgl(.x)<br />flatten_int(.x)<br />flatten_dbl(.x)<br />flatten_chr(.x)<br />flatten_df(.x, .id = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list of flatten. The contents of the list can be anything for <code>flatten</code> (as a list is returned), but the contents must match the type for the other functions.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"get-attr"	"purrr"	"Infix attribute accessor"	"<p>Infix attribute accessor </p>"	"<pre>x %@% name </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Object</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>Attribute name</p> </td> </tr> </table> "	FALSE
"head_while"	"purrr"	"Find head/tail that all satisfies a predicate."	"<p>Find head/tail that all satisfies a predicate. </p>"	"<pre>head_while(.x, .p, ...)<br />tail_while(.x, .p, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> </table> "	FALSE
"invoke"	"purrr"	"Invoke functions."	"<p>This pair of functions make it easier to combine a function and list of parameters to get a result. <code>invoke</code> is a wrapper around <code>do.call</code> that makes it easy to use in a pipe. <code>invoke_map</code> makes it easier to call lists of functions with lists of parameters. </p>"	"<pre>invoke(.f, .x = NULL, ..., .env = NULL)<br />invoke_map(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_df(.f, .x = list(NULL), ..., .env = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>For <code>invoke</code>, a function; for <code>invoke_map</code> a list of functions.</p> </td> </tr> <tr valign='top'> <td><code>.x</code></td> <td> <p>For <code>invoke</code>, an argument-list; for <code>invoke_map</code> a list of argument-lists the same length as <code>.f</code> (or length 1). The default argument, <code>list(NULL)</code>, will be recycled to the same length as <code>.f</code>, and will call each function with no arguments (apart from any suppled in <code>...</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed to each function.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>Environment in which <code>do.call()</code> should evaluate a constructed expression. This only matters if you pass as <code>.f</code> the name of a function rather than its value, or as <code>.x</code> symbols of objects rather than their values.</p> </td> </tr> </table> "	FALSE
"invoke"	"purrr"	"Invoke functions."	"<p>This pair of functions make it easier to combine a function and list of parameters to get a result. <code>invoke</code> is a wrapper around <code>do.call</code> that makes it easy to use in a pipe. <code>invoke_map</code> makes it easier to call lists of functions with lists of parameters. </p>"	"<pre>invoke(.f, .x = NULL, ..., .env = NULL)<br />invoke_map(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_df(.f, .x = list(NULL), ..., .env = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>For <code>invoke</code>, a function; for <code>invoke_map</code> a list of functions.</p> </td> </tr> <tr valign='top'> <td><code>.x</code></td> <td> <p>For <code>invoke</code>, an argument-list; for <code>invoke_map</code> a list of argument-lists the same length as <code>.f</code> (or length 1). The default argument, <code>list(NULL)</code>, will be recycled to the same length as <code>.f</code>, and will call each function with no arguments (apart from any suppled in <code>...</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed to each function.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>Environment in which <code>do.call()</code> should evaluate a constructed expression. This only matters if you pass as <code>.f</code> the name of a function rather than its value, or as <code>.x</code> symbols of objects rather than their values.</p> </td> </tr> </table> "	FALSE
"invoke"	"purrr"	"Invoke functions."	"<p>This pair of functions make it easier to combine a function and list of parameters to get a result. <code>invoke</code> is a wrapper around <code>do.call</code> that makes it easy to use in a pipe. <code>invoke_map</code> makes it easier to call lists of functions with lists of parameters. </p>"	"<pre>invoke(.f, .x = NULL, ..., .env = NULL)<br />invoke_map(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_df(.f, .x = list(NULL), ..., .env = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>For <code>invoke</code>, a function; for <code>invoke_map</code> a list of functions.</p> </td> </tr> <tr valign='top'> <td><code>.x</code></td> <td> <p>For <code>invoke</code>, an argument-list; for <code>invoke_map</code> a list of argument-lists the same length as <code>.f</code> (or length 1). The default argument, <code>list(NULL)</code>, will be recycled to the same length as <code>.f</code>, and will call each function with no arguments (apart from any suppled in <code>...</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed to each function.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>Environment in which <code>do.call()</code> should evaluate a constructed expression. This only matters if you pass as <code>.f</code> the name of a function rather than its value, or as <code>.x</code> symbols of objects rather than their values.</p> </td> </tr> </table> "	FALSE
"invoke"	"purrr"	"Invoke functions."	"<p>This pair of functions make it easier to combine a function and list of parameters to get a result. <code>invoke</code> is a wrapper around <code>do.call</code> that makes it easy to use in a pipe. <code>invoke_map</code> makes it easier to call lists of functions with lists of parameters. </p>"	"<pre>invoke(.f, .x = NULL, ..., .env = NULL)<br />invoke_map(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_df(.f, .x = list(NULL), ..., .env = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>For <code>invoke</code>, a function; for <code>invoke_map</code> a list of functions.</p> </td> </tr> <tr valign='top'> <td><code>.x</code></td> <td> <p>For <code>invoke</code>, an argument-list; for <code>invoke_map</code> a list of argument-lists the same length as <code>.f</code> (or length 1). The default argument, <code>list(NULL)</code>, will be recycled to the same length as <code>.f</code>, and will call each function with no arguments (apart from any suppled in <code>...</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed to each function.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>Environment in which <code>do.call()</code> should evaluate a constructed expression. This only matters if you pass as <code>.f</code> the name of a function rather than its value, or as <code>.x</code> symbols of objects rather than their values.</p> </td> </tr> </table> "	FALSE
"invoke"	"purrr"	"Invoke functions."	"<p>This pair of functions make it easier to combine a function and list of parameters to get a result. <code>invoke</code> is a wrapper around <code>do.call</code> that makes it easy to use in a pipe. <code>invoke_map</code> makes it easier to call lists of functions with lists of parameters. </p>"	"<pre>invoke(.f, .x = NULL, ..., .env = NULL)<br />invoke_map(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_df(.f, .x = list(NULL), ..., .env = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>For <code>invoke</code>, a function; for <code>invoke_map</code> a list of functions.</p> </td> </tr> <tr valign='top'> <td><code>.x</code></td> <td> <p>For <code>invoke</code>, an argument-list; for <code>invoke_map</code> a list of argument-lists the same length as <code>.f</code> (or length 1). The default argument, <code>list(NULL)</code>, will be recycled to the same length as <code>.f</code>, and will call each function with no arguments (apart from any suppled in <code>...</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed to each function.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>Environment in which <code>do.call()</code> should evaluate a constructed expression. This only matters if you pass as <code>.f</code> the name of a function rather than its value, or as <code>.x</code> symbols of objects rather than their values.</p> </td> </tr> </table> "	FALSE
"invoke"	"purrr"	"Invoke functions."	"<p>This pair of functions make it easier to combine a function and list of parameters to get a result. <code>invoke</code> is a wrapper around <code>do.call</code> that makes it easy to use in a pipe. <code>invoke_map</code> makes it easier to call lists of functions with lists of parameters. </p>"	"<pre>invoke(.f, .x = NULL, ..., .env = NULL)<br />invoke_map(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_df(.f, .x = list(NULL), ..., .env = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>For <code>invoke</code>, a function; for <code>invoke_map</code> a list of functions.</p> </td> </tr> <tr valign='top'> <td><code>.x</code></td> <td> <p>For <code>invoke</code>, an argument-list; for <code>invoke_map</code> a list of argument-lists the same length as <code>.f</code> (or length 1). The default argument, <code>list(NULL)</code>, will be recycled to the same length as <code>.f</code>, and will call each function with no arguments (apart from any suppled in <code>...</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed to each function.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>Environment in which <code>do.call()</code> should evaluate a constructed expression. This only matters if you pass as <code>.f</code> the name of a function rather than its value, or as <code>.x</code> symbols of objects rather than their values.</p> </td> </tr> </table> "	FALSE
"invoke"	"purrr"	"Invoke functions."	"<p>This pair of functions make it easier to combine a function and list of parameters to get a result. <code>invoke</code> is a wrapper around <code>do.call</code> that makes it easy to use in a pipe. <code>invoke_map</code> makes it easier to call lists of functions with lists of parameters. </p>"	"<pre>invoke(.f, .x = NULL, ..., .env = NULL)<br />invoke_map(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_df(.f, .x = list(NULL), ..., .env = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>For <code>invoke</code>, a function; for <code>invoke_map</code> a list of functions.</p> </td> </tr> <tr valign='top'> <td><code>.x</code></td> <td> <p>For <code>invoke</code>, an argument-list; for <code>invoke_map</code> a list of argument-lists the same length as <code>.f</code> (or length 1). The default argument, <code>list(NULL)</code>, will be recycled to the same length as <code>.f</code>, and will call each function with no arguments (apart from any suppled in <code>...</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed to each function.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>Environment in which <code>do.call()</code> should evaluate a constructed expression. This only matters if you pass as <code>.f</code> the name of a function rather than its value, or as <code>.x</code> symbols of objects rather than their values.</p> </td> </tr> </table> "	FALSE
"by_row"	"purrr"	"Apply a function to each row of a data frame"	"<p><code>by_row()</code> and <code>invoke_rows()</code> apply <code>..f</code> to each row of <code>.d</code>. If <code>..f</code>'s output is not a data frame nor an atomic vector, a list-column is created. In all cases, <code>by_row()</code> and <code>invoke_rows()</code> create a data frame in tidy format. </p>"	"<pre>by_row(.d, ..f, ..., .collate = c('list', 'rows', 'cols'), .to = '.out',<br />   .labels = TRUE)<br />invoke_rows(.f, .d, ..., .collate = c('list', 'rows', 'cols'), .to = '.out',<br />   .labels = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.d</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further arguments passed to <code>..f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.collate</code></td> <td> <p>If 'list', the results are returned as a list- column. Alternatively, if the results are data frames or atomic vectors, you can collate on 'cols' or on 'rows'. Column collation require vector of equal length or data frames with same number of rows.</p> </td> </tr> <tr valign='top'> <td><code>.to</code></td> <td> <p>Name of output column.</p> </td> </tr> <tr valign='top'> <td><code>.labels</code></td> <td> <p>If <code>TRUE</code>, the returned data frame is prepended with the labels of the slices (the columns in <code>.d</code> used to define the slices). They are recycled to match the output size in each slice if necessary.</p> </td> </tr> <tr valign='top'> <td><code>.f, ..f</code></td> <td> <p>A function to apply to each row. If <code>..f</code> does not return a data frame or an atomic vector, a list-column is created under the name <code>.out</code>. If it returns a data frame, it should have the same number of rows within groups and the same number of columns between groups.</p> </td> </tr> </table> "	FALSE
"type-predicates"	"purrr"	"Type predicates"	"<p>These type predicates aim to make type testing in R more consistent. They are wrappers around <code>typeof</code>, so operate at a level beneath S3/S4 etc. </p>"	"<pre>is_list(x)<br />is_atomic(x)<br />is_vector(x)<br />is_numeric(x)<br />is_integer(x)<br />is_double(x)<br />is_character(x)<br />is_logical(x)<br />is_null(x)<br />is_function(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"bare-type-predicates"	"purrr"	"Bare type predicates"	"<p>These predicates check for a given type but only return <code>TRUE</code> for bare R objects. Bare objects have no class attributes. For example, a data frame is a list, but not a bare list. </p>"	"<pre>is_bare_list(x)<br />is_bare_atomic(x)<br />is_bare_vector(x)<br />is_bare_double(x)<br />is_bare_integer(x)<br />is_bare_numeric(x)<br />is_bare_character(x)<br />is_bare_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"bare-type-predicates"	"purrr"	"Bare type predicates"	"<p>These predicates check for a given type but only return <code>TRUE</code> for bare R objects. Bare objects have no class attributes. For example, a data frame is a list, but not a bare list. </p>"	"<pre>is_bare_list(x)<br />is_bare_atomic(x)<br />is_bare_vector(x)<br />is_bare_double(x)<br />is_bare_integer(x)<br />is_bare_numeric(x)<br />is_bare_character(x)<br />is_bare_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"bare-type-predicates"	"purrr"	"Bare type predicates"	"<p>These predicates check for a given type but only return <code>TRUE</code> for bare R objects. Bare objects have no class attributes. For example, a data frame is a list, but not a bare list. </p>"	"<pre>is_bare_list(x)<br />is_bare_atomic(x)<br />is_bare_vector(x)<br />is_bare_double(x)<br />is_bare_integer(x)<br />is_bare_numeric(x)<br />is_bare_character(x)<br />is_bare_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"bare-type-predicates"	"purrr"	"Bare type predicates"	"<p>These predicates check for a given type but only return <code>TRUE</code> for bare R objects. Bare objects have no class attributes. For example, a data frame is a list, but not a bare list. </p>"	"<pre>is_bare_list(x)<br />is_bare_atomic(x)<br />is_bare_vector(x)<br />is_bare_double(x)<br />is_bare_integer(x)<br />is_bare_numeric(x)<br />is_bare_character(x)<br />is_bare_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"bare-type-predicates"	"purrr"	"Bare type predicates"	"<p>These predicates check for a given type but only return <code>TRUE</code> for bare R objects. Bare objects have no class attributes. For example, a data frame is a list, but not a bare list. </p>"	"<pre>is_bare_list(x)<br />is_bare_atomic(x)<br />is_bare_vector(x)<br />is_bare_double(x)<br />is_bare_integer(x)<br />is_bare_numeric(x)<br />is_bare_character(x)<br />is_bare_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"bare-type-predicates"	"purrr"	"Bare type predicates"	"<p>These predicates check for a given type but only return <code>TRUE</code> for bare R objects. Bare objects have no class attributes. For example, a data frame is a list, but not a bare list. </p>"	"<pre>is_bare_list(x)<br />is_bare_atomic(x)<br />is_bare_vector(x)<br />is_bare_double(x)<br />is_bare_integer(x)<br />is_bare_numeric(x)<br />is_bare_character(x)<br />is_bare_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"bare-type-predicates"	"purrr"	"Bare type predicates"	"<p>These predicates check for a given type but only return <code>TRUE</code> for bare R objects. Bare objects have no class attributes. For example, a data frame is a list, but not a bare list. </p>"	"<pre>is_bare_list(x)<br />is_bare_atomic(x)<br />is_bare_vector(x)<br />is_bare_double(x)<br />is_bare_integer(x)<br />is_bare_numeric(x)<br />is_bare_character(x)<br />is_bare_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"bare-type-predicates"	"purrr"	"Bare type predicates"	"<p>These predicates check for a given type but only return <code>TRUE</code> for bare R objects. Bare objects have no class attributes. For example, a data frame is a list, but not a bare list. </p>"	"<pre>is_bare_list(x)<br />is_bare_atomic(x)<br />is_bare_vector(x)<br />is_bare_double(x)<br />is_bare_integer(x)<br />is_bare_numeric(x)<br />is_bare_character(x)<br />is_bare_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"type-predicates"	"purrr"	"Type predicates"	"<p>These type predicates aim to make type testing in R more consistent. They are wrappers around <code>typeof</code>, so operate at a level beneath S3/S4 etc. </p>"	"<pre>is_list(x)<br />is_atomic(x)<br />is_vector(x)<br />is_numeric(x)<br />is_integer(x)<br />is_double(x)<br />is_character(x)<br />is_logical(x)<br />is_null(x)<br />is_function(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"type-predicates"	"purrr"	"Type predicates"	"<p>These type predicates aim to make type testing in R more consistent. They are wrappers around <code>typeof</code>, so operate at a level beneath S3/S4 etc. </p>"	"<pre>is_list(x)<br />is_atomic(x)<br />is_vector(x)<br />is_numeric(x)<br />is_integer(x)<br />is_double(x)<br />is_character(x)<br />is_logical(x)<br />is_null(x)<br />is_function(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"is_empty"	"purrr"	"Is a vector/list empty?"	"<p>Is a vector/list empty? </p>"	"<pre>is_empty(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to test</p> </td> </tr></table> "	FALSE
"is_formula"	"purrr"	"Is a formula?"	"<p>Is a formula? </p>"	"<pre>is_formula(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to test</p> </td> </tr></table> "	FALSE
"type-predicates"	"purrr"	"Type predicates"	"<p>These type predicates aim to make type testing in R more consistent. They are wrappers around <code>typeof</code>, so operate at a level beneath S3/S4 etc. </p>"	"<pre>is_list(x)<br />is_atomic(x)<br />is_vector(x)<br />is_numeric(x)<br />is_integer(x)<br />is_double(x)<br />is_character(x)<br />is_logical(x)<br />is_null(x)<br />is_function(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"type-predicates"	"purrr"	"Type predicates"	"<p>These type predicates aim to make type testing in R more consistent. They are wrappers around <code>typeof</code>, so operate at a level beneath S3/S4 etc. </p>"	"<pre>is_list(x)<br />is_atomic(x)<br />is_vector(x)<br />is_numeric(x)<br />is_integer(x)<br />is_double(x)<br />is_character(x)<br />is_logical(x)<br />is_null(x)<br />is_function(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"type-predicates"	"purrr"	"Type predicates"	"<p>These type predicates aim to make type testing in R more consistent. They are wrappers around <code>typeof</code>, so operate at a level beneath S3/S4 etc. </p>"	"<pre>is_list(x)<br />is_atomic(x)<br />is_vector(x)<br />is_numeric(x)<br />is_integer(x)<br />is_double(x)<br />is_character(x)<br />is_logical(x)<br />is_null(x)<br />is_function(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"type-predicates"	"purrr"	"Type predicates"	"<p>These type predicates aim to make type testing in R more consistent. They are wrappers around <code>typeof</code>, so operate at a level beneath S3/S4 etc. </p>"	"<pre>is_list(x)<br />is_atomic(x)<br />is_vector(x)<br />is_numeric(x)<br />is_integer(x)<br />is_double(x)<br />is_character(x)<br />is_logical(x)<br />is_null(x)<br />is_function(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"type-predicates"	"purrr"	"Type predicates"	"<p>These type predicates aim to make type testing in R more consistent. They are wrappers around <code>typeof</code>, so operate at a level beneath S3/S4 etc. </p>"	"<pre>is_list(x)<br />is_atomic(x)<br />is_vector(x)<br />is_numeric(x)<br />is_integer(x)<br />is_double(x)<br />is_character(x)<br />is_logical(x)<br />is_null(x)<br />is_function(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"type-predicates"	"purrr"	"Type predicates"	"<p>These type predicates aim to make type testing in R more consistent. They are wrappers around <code>typeof</code>, so operate at a level beneath S3/S4 etc. </p>"	"<pre>is_list(x)<br />is_atomic(x)<br />is_vector(x)<br />is_numeric(x)<br />is_integer(x)<br />is_double(x)<br />is_character(x)<br />is_logical(x)<br />is_null(x)<br />is_function(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"scalar-type-predicates"	"purrr"	"Scalar type predicates"	"<p>These predicates check for a given type and whether the vector is 'scalar', that is, of length 1. </p>"	"<pre>is_scalar_list(x)<br />is_scalar_atomic(x)<br />is_scalar_vector(x)<br />is_scalar_numeric(x)<br />is_scalar_integer(x)<br />is_scalar_double(x)<br />is_scalar_character(x)<br />is_scalar_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"scalar-type-predicates"	"purrr"	"Scalar type predicates"	"<p>These predicates check for a given type and whether the vector is 'scalar', that is, of length 1. </p>"	"<pre>is_scalar_list(x)<br />is_scalar_atomic(x)<br />is_scalar_vector(x)<br />is_scalar_numeric(x)<br />is_scalar_integer(x)<br />is_scalar_double(x)<br />is_scalar_character(x)<br />is_scalar_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"scalar-type-predicates"	"purrr"	"Scalar type predicates"	"<p>These predicates check for a given type and whether the vector is 'scalar', that is, of length 1. </p>"	"<pre>is_scalar_list(x)<br />is_scalar_atomic(x)<br />is_scalar_vector(x)<br />is_scalar_numeric(x)<br />is_scalar_integer(x)<br />is_scalar_double(x)<br />is_scalar_character(x)<br />is_scalar_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"scalar-type-predicates"	"purrr"	"Scalar type predicates"	"<p>These predicates check for a given type and whether the vector is 'scalar', that is, of length 1. </p>"	"<pre>is_scalar_list(x)<br />is_scalar_atomic(x)<br />is_scalar_vector(x)<br />is_scalar_numeric(x)<br />is_scalar_integer(x)<br />is_scalar_double(x)<br />is_scalar_character(x)<br />is_scalar_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"scalar-type-predicates"	"purrr"	"Scalar type predicates"	"<p>These predicates check for a given type and whether the vector is 'scalar', that is, of length 1. </p>"	"<pre>is_scalar_list(x)<br />is_scalar_atomic(x)<br />is_scalar_vector(x)<br />is_scalar_numeric(x)<br />is_scalar_integer(x)<br />is_scalar_double(x)<br />is_scalar_character(x)<br />is_scalar_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"scalar-type-predicates"	"purrr"	"Scalar type predicates"	"<p>These predicates check for a given type and whether the vector is 'scalar', that is, of length 1. </p>"	"<pre>is_scalar_list(x)<br />is_scalar_atomic(x)<br />is_scalar_vector(x)<br />is_scalar_numeric(x)<br />is_scalar_integer(x)<br />is_scalar_double(x)<br />is_scalar_character(x)<br />is_scalar_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"scalar-type-predicates"	"purrr"	"Scalar type predicates"	"<p>These predicates check for a given type and whether the vector is 'scalar', that is, of length 1. </p>"	"<pre>is_scalar_list(x)<br />is_scalar_atomic(x)<br />is_scalar_vector(x)<br />is_scalar_numeric(x)<br />is_scalar_integer(x)<br />is_scalar_double(x)<br />is_scalar_character(x)<br />is_scalar_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"scalar-type-predicates"	"purrr"	"Scalar type predicates"	"<p>These predicates check for a given type and whether the vector is 'scalar', that is, of length 1. </p>"	"<pre>is_scalar_list(x)<br />is_scalar_atomic(x)<br />is_scalar_vector(x)<br />is_scalar_numeric(x)<br />is_scalar_integer(x)<br />is_scalar_double(x)<br />is_scalar_character(x)<br />is_scalar_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"type-predicates"	"purrr"	"Type predicates"	"<p>These type predicates aim to make type testing in R more consistent. They are wrappers around <code>typeof</code>, so operate at a level beneath S3/S4 etc. </p>"	"<pre>is_list(x)<br />is_atomic(x)<br />is_vector(x)<br />is_numeric(x)<br />is_integer(x)<br />is_double(x)<br />is_character(x)<br />is_logical(x)<br />is_null(x)<br />is_function(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"keep"	"purrr"	"Keep or discard elements using a predicate function."	"<p><code>keep</code> and <code>discard</code> are opposites. <code>compact</code> is a handy wrapper that removes all elements that are <code>NULL</code>. </p>"	"<pre>keep(.x, .p, ...)<br />discard(.x, .p, ...)<br />compact(.x, .p = identity) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.p</code>.</p> </td> </tr> </table> "	FALSE
"lift"	"purrr"	"Lift the domain of a function"	"<p><code>lift_xy()</code> is a composition helper. It helps you compose functions by lifting their domain from a kind of input to another kind. The domain can be changed from and to a list (l), a vector (v) and dots (d). For example, <code>lift_ld(fun)</code> transforms a function taking a list to a function taking dots. </p>"	"<pre>lift(..f, ..., .unnamed = FALSE)<br />lift_dl(..f, ..., .unnamed = FALSE)<br />lift_dv(..f, ..., .unnamed = FALSE)<br />lift_vl(..f, ..., .type)<br />lift_vd(..f, ..., .type)<br />lift_ld(..f, ...)<br />lift_lv(..f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>..f</code></td> <td> <p>A function to lift.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Default arguments for <code>..f</code>. These will be evaluated only once, when the lifting factory is called.</p> </td> </tr> <tr valign='top'> <td><code>.unnamed</code></td> <td> <p>If <code>TRUE</code>, <code>ld</code> or <code>lv</code> will not name the parameters in the lifted function signature. This prevents matching of arguments by name and match by position instead.</p> </td> </tr> <tr valign='top'> <td><code>.type</code></td> <td> <p>A vector mold or a string describing the type of the input vectors. The latter can be any of the types returned by <code>typeof()</code>, or 'numeric' as a shorthand for either 'double' or 'integer'.</p> </td> </tr> </table> "	FALSE
"lift"	"purrr"	"Lift the domain of a function"	"<p><code>lift_xy()</code> is a composition helper. It helps you compose functions by lifting their domain from a kind of input to another kind. The domain can be changed from and to a list (l), a vector (v) and dots (d). For example, <code>lift_ld(fun)</code> transforms a function taking a list to a function taking dots. </p>"	"<pre>lift(..f, ..., .unnamed = FALSE)<br />lift_dl(..f, ..., .unnamed = FALSE)<br />lift_dv(..f, ..., .unnamed = FALSE)<br />lift_vl(..f, ..., .type)<br />lift_vd(..f, ..., .type)<br />lift_ld(..f, ...)<br />lift_lv(..f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>..f</code></td> <td> <p>A function to lift.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Default arguments for <code>..f</code>. These will be evaluated only once, when the lifting factory is called.</p> </td> </tr> <tr valign='top'> <td><code>.unnamed</code></td> <td> <p>If <code>TRUE</code>, <code>ld</code> or <code>lv</code> will not name the parameters in the lifted function signature. This prevents matching of arguments by name and match by position instead.</p> </td> </tr> <tr valign='top'> <td><code>.type</code></td> <td> <p>A vector mold or a string describing the type of the input vectors. The latter can be any of the types returned by <code>typeof()</code>, or 'numeric' as a shorthand for either 'double' or 'integer'.</p> </td> </tr> </table> "	FALSE
"lift"	"purrr"	"Lift the domain of a function"	"<p><code>lift_xy()</code> is a composition helper. It helps you compose functions by lifting their domain from a kind of input to another kind. The domain can be changed from and to a list (l), a vector (v) and dots (d). For example, <code>lift_ld(fun)</code> transforms a function taking a list to a function taking dots. </p>"	"<pre>lift(..f, ..., .unnamed = FALSE)<br />lift_dl(..f, ..., .unnamed = FALSE)<br />lift_dv(..f, ..., .unnamed = FALSE)<br />lift_vl(..f, ..., .type)<br />lift_vd(..f, ..., .type)<br />lift_ld(..f, ...)<br />lift_lv(..f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>..f</code></td> <td> <p>A function to lift.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Default arguments for <code>..f</code>. These will be evaluated only once, when the lifting factory is called.</p> </td> </tr> <tr valign='top'> <td><code>.unnamed</code></td> <td> <p>If <code>TRUE</code>, <code>ld</code> or <code>lv</code> will not name the parameters in the lifted function signature. This prevents matching of arguments by name and match by position instead.</p> </td> </tr> <tr valign='top'> <td><code>.type</code></td> <td> <p>A vector mold or a string describing the type of the input vectors. The latter can be any of the types returned by <code>typeof()</code>, or 'numeric' as a shorthand for either 'double' or 'integer'.</p> </td> </tr> </table> "	FALSE
"lift"	"purrr"	"Lift the domain of a function"	"<p><code>lift_xy()</code> is a composition helper. It helps you compose functions by lifting their domain from a kind of input to another kind. The domain can be changed from and to a list (l), a vector (v) and dots (d). For example, <code>lift_ld(fun)</code> transforms a function taking a list to a function taking dots. </p>"	"<pre>lift(..f, ..., .unnamed = FALSE)<br />lift_dl(..f, ..., .unnamed = FALSE)<br />lift_dv(..f, ..., .unnamed = FALSE)<br />lift_vl(..f, ..., .type)<br />lift_vd(..f, ..., .type)<br />lift_ld(..f, ...)<br />lift_lv(..f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>..f</code></td> <td> <p>A function to lift.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Default arguments for <code>..f</code>. These will be evaluated only once, when the lifting factory is called.</p> </td> </tr> <tr valign='top'> <td><code>.unnamed</code></td> <td> <p>If <code>TRUE</code>, <code>ld</code> or <code>lv</code> will not name the parameters in the lifted function signature. This prevents matching of arguments by name and match by position instead.</p> </td> </tr> <tr valign='top'> <td><code>.type</code></td> <td> <p>A vector mold or a string describing the type of the input vectors. The latter can be any of the types returned by <code>typeof()</code>, or 'numeric' as a shorthand for either 'double' or 'integer'.</p> </td> </tr> </table> "	FALSE
"lift"	"purrr"	"Lift the domain of a function"	"<p><code>lift_xy()</code> is a composition helper. It helps you compose functions by lifting their domain from a kind of input to another kind. The domain can be changed from and to a list (l), a vector (v) and dots (d). For example, <code>lift_ld(fun)</code> transforms a function taking a list to a function taking dots. </p>"	"<pre>lift(..f, ..., .unnamed = FALSE)<br />lift_dl(..f, ..., .unnamed = FALSE)<br />lift_dv(..f, ..., .unnamed = FALSE)<br />lift_vl(..f, ..., .type)<br />lift_vd(..f, ..., .type)<br />lift_ld(..f, ...)<br />lift_lv(..f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>..f</code></td> <td> <p>A function to lift.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Default arguments for <code>..f</code>. These will be evaluated only once, when the lifting factory is called.</p> </td> </tr> <tr valign='top'> <td><code>.unnamed</code></td> <td> <p>If <code>TRUE</code>, <code>ld</code> or <code>lv</code> will not name the parameters in the lifted function signature. This prevents matching of arguments by name and match by position instead.</p> </td> </tr> <tr valign='top'> <td><code>.type</code></td> <td> <p>A vector mold or a string describing the type of the input vectors. The latter can be any of the types returned by <code>typeof()</code>, or 'numeric' as a shorthand for either 'double' or 'integer'.</p> </td> </tr> </table> "	FALSE
"lift"	"purrr"	"Lift the domain of a function"	"<p><code>lift_xy()</code> is a composition helper. It helps you compose functions by lifting their domain from a kind of input to another kind. The domain can be changed from and to a list (l), a vector (v) and dots (d). For example, <code>lift_ld(fun)</code> transforms a function taking a list to a function taking dots. </p>"	"<pre>lift(..f, ..., .unnamed = FALSE)<br />lift_dl(..f, ..., .unnamed = FALSE)<br />lift_dv(..f, ..., .unnamed = FALSE)<br />lift_vl(..f, ..., .type)<br />lift_vd(..f, ..., .type)<br />lift_ld(..f, ...)<br />lift_lv(..f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>..f</code></td> <td> <p>A function to lift.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Default arguments for <code>..f</code>. These will be evaluated only once, when the lifting factory is called.</p> </td> </tr> <tr valign='top'> <td><code>.unnamed</code></td> <td> <p>If <code>TRUE</code>, <code>ld</code> or <code>lv</code> will not name the parameters in the lifted function signature. This prevents matching of arguments by name and match by position instead.</p> </td> </tr> <tr valign='top'> <td><code>.type</code></td> <td> <p>A vector mold or a string describing the type of the input vectors. The latter can be any of the types returned by <code>typeof()</code>, or 'numeric' as a shorthand for either 'double' or 'integer'.</p> </td> </tr> </table> "	FALSE
"lift"	"purrr"	"Lift the domain of a function"	"<p><code>lift_xy()</code> is a composition helper. It helps you compose functions by lifting their domain from a kind of input to another kind. The domain can be changed from and to a list (l), a vector (v) and dots (d). For example, <code>lift_ld(fun)</code> transforms a function taking a list to a function taking dots. </p>"	"<pre>lift(..f, ..., .unnamed = FALSE)<br />lift_dl(..f, ..., .unnamed = FALSE)<br />lift_dv(..f, ..., .unnamed = FALSE)<br />lift_vl(..f, ..., .type)<br />lift_vd(..f, ..., .type)<br />lift_ld(..f, ...)<br />lift_lv(..f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>..f</code></td> <td> <p>A function to lift.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Default arguments for <code>..f</code>. These will be evaluated only once, when the lifting factory is called.</p> </td> </tr> <tr valign='top'> <td><code>.unnamed</code></td> <td> <p>If <code>TRUE</code>, <code>ld</code> or <code>lv</code> will not name the parameters in the lifted function signature. This prevents matching of arguments by name and match by position instead.</p> </td> </tr> <tr valign='top'> <td><code>.type</code></td> <td> <p>A vector mold or a string describing the type of the input vectors. The latter can be any of the types returned by <code>typeof()</code>, or 'numeric' as a shorthand for either 'double' or 'integer'.</p> </td> </tr> </table> "	FALSE
"along"	"purrr"	"Helper to create vectors with matching length."	"<p>These functions take the idea of <code>seq_along</code> and generalise it to creating lists (<code>list_along</code>) and repeating values (<code>rep_along</code>). </p>"	"<pre>list_along(x)<br />rep_along(x, y) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A vector.</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>Values to repeat.</p> </td> </tr> </table> "	FALSE
"lmap"	"purrr"	"Apply a function to list-elements of a list"	"<p><code>lmap()</code>, <code>lmap_at()</code> and <code>lmap_if()</code> are similar to <code>map()</code>, <code>map_at()</code> and <code>map_if()</code>, with the difference that they operate exclusively on functions that take <em>and</em> return a list (or data frame). Thus, instead of mapping the elements of a list (as in <code>.x[[i]]</code>), they apply a function <code>.f</code> to each subset of size 1 of that list (as in <code>.x[i]</code>). We call those those elements ‘list-elements’). </p>"	"<pre>lmap(.x, .f, ...)<br />lmap_if(.x, .p, .f, ...)<br />lmap_at(.x, .at, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or data frame.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function that takes and returns a list or data frame.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>.at</code></td> <td> <p>A character vector of names or a numeric vector of positions. Only those elements corresponding to <code>.at</code> will be modified.</p> </td> </tr> </table> "	FALSE
"lmap"	"purrr"	"Apply a function to list-elements of a list"	"<p><code>lmap()</code>, <code>lmap_at()</code> and <code>lmap_if()</code> are similar to <code>map()</code>, <code>map_at()</code> and <code>map_if()</code>, with the difference that they operate exclusively on functions that take <em>and</em> return a list (or data frame). Thus, instead of mapping the elements of a list (as in <code>.x[[i]]</code>), they apply a function <code>.f</code> to each subset of size 1 of that list (as in <code>.x[i]</code>). We call those those elements ‘list-elements’). </p>"	"<pre>lmap(.x, .f, ...)<br />lmap_if(.x, .p, .f, ...)<br />lmap_at(.x, .at, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or data frame.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function that takes and returns a list or data frame.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>.at</code></td> <td> <p>A character vector of names or a numeric vector of positions. Only those elements corresponding to <code>.at</code> will be modified.</p> </td> </tr> </table> "	FALSE
"lmap"	"purrr"	"Apply a function to list-elements of a list"	"<p><code>lmap()</code>, <code>lmap_at()</code> and <code>lmap_if()</code> are similar to <code>map()</code>, <code>map_at()</code> and <code>map_if()</code>, with the difference that they operate exclusively on functions that take <em>and</em> return a list (or data frame). Thus, instead of mapping the elements of a list (as in <code>.x[[i]]</code>), they apply a function <code>.f</code> to each subset of size 1 of that list (as in <code>.x[i]</code>). We call those those elements ‘list-elements’). </p>"	"<pre>lmap(.x, .f, ...)<br />lmap_if(.x, .p, .f, ...)<br />lmap_at(.x, .at, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or data frame.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function that takes and returns a list or data frame.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>.at</code></td> <td> <p>A character vector of names or a numeric vector of positions. Only those elements corresponding to <code>.at</code> will be modified.</p> </td> </tr> </table> "	FALSE
"map"	"purrr"	"Apply a function to each element of a vector"	"<p><code>map()</code> returns the transformed input; <code>walk()</code> calls <code>.f</code> for its side-effect and returns the original input. <code>map()</code> returns a list or a data frame; <code>map_lgl()</code>, <code>map_int()</code>, <code>map_dbl()</code> and <code>map_chr()</code> return vectors of the corresponding type (or die trying); <code>map_df()</code> returns a data frame by row-binding the individual elements. </p>"	"<pre>map(.x, .f, ...)<br />map_lgl(.x, .f, ...)<br />map_chr(.x, .f, ...)<br />map_int(.x, .f, ...)<br />map_dbl(.x, .f, ...)<br />map_df(.x, .f, ..., .id = NULL)<br />walk(.x, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"conditional-map"	"purrr"	"Modify elements conditionally"	"<p><code>map_if()</code> maps a function over the elements of <code>.x</code> satisfying a predicate. <code>map_at()</code> is similar but will modify the elements corresponding to a character vector of names or a mumeric vector of positions. </p>"	"<pre>map_if(.x, .p, .f, ...)<br />map_at(.x, .at, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.at</code></td> <td> <p>A character vector of names or a numeric vector of positions. Only those elements corresponding to <code>.at</code> will be modified.</p> </td> </tr> </table> "	FALSE
"invoke"	"purrr"	"Invoke functions."	"<p>This pair of functions make it easier to combine a function and list of parameters to get a result. <code>invoke</code> is a wrapper around <code>do.call</code> that makes it easy to use in a pipe. <code>invoke_map</code> makes it easier to call lists of functions with lists of parameters. </p>"	"<pre>invoke(.f, .x = NULL, ..., .env = NULL)<br />invoke_map(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)<br />invoke_map_df(.f, .x = list(NULL), ..., .env = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>For <code>invoke</code>, a function; for <code>invoke_map</code> a list of functions.</p> </td> </tr> <tr valign='top'> <td><code>.x</code></td> <td> <p>For <code>invoke</code>, an argument-list; for <code>invoke_map</code> a list of argument-lists the same length as <code>.f</code> (or length 1). The default argument, <code>list(NULL)</code>, will be recycled to the same length as <code>.f</code>, and will call each function with no arguments (apart from any suppled in <code>...</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed to each function.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>Environment in which <code>do.call()</code> should evaluate a constructed expression. This only matters if you pass as <code>.f</code> the name of a function rather than its value, or as <code>.x</code> symbols of objects rather than their values.</p> </td> </tr> </table> "	FALSE
"map"	"purrr"	"Apply a function to each element of a vector"	"<p><code>map()</code> returns the transformed input; <code>walk()</code> calls <code>.f</code> for its side-effect and returns the original input. <code>map()</code> returns a list or a data frame; <code>map_lgl()</code>, <code>map_int()</code>, <code>map_dbl()</code> and <code>map_chr()</code> return vectors of the corresponding type (or die trying); <code>map_df()</code> returns a data frame by row-binding the individual elements. </p>"	"<pre>map(.x, .f, ...)<br />map_lgl(.x, .f, ...)<br />map_chr(.x, .f, ...)<br />map_int(.x, .f, ...)<br />map_dbl(.x, .f, ...)<br />map_df(.x, .f, ..., .id = NULL)<br />walk(.x, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"map"	"purrr"	"Apply a function to each element of a vector"	"<p><code>map()</code> returns the transformed input; <code>walk()</code> calls <code>.f</code> for its side-effect and returns the original input. <code>map()</code> returns a list or a data frame; <code>map_lgl()</code>, <code>map_int()</code>, <code>map_dbl()</code> and <code>map_chr()</code> return vectors of the corresponding type (or die trying); <code>map_df()</code> returns a data frame by row-binding the individual elements. </p>"	"<pre>map(.x, .f, ...)<br />map_lgl(.x, .f, ...)<br />map_chr(.x, .f, ...)<br />map_int(.x, .f, ...)<br />map_dbl(.x, .f, ...)<br />map_df(.x, .f, ..., .id = NULL)<br />walk(.x, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"map"	"purrr"	"Apply a function to each element of a vector"	"<p><code>map()</code> returns the transformed input; <code>walk()</code> calls <code>.f</code> for its side-effect and returns the original input. <code>map()</code> returns a list or a data frame; <code>map_lgl()</code>, <code>map_int()</code>, <code>map_dbl()</code> and <code>map_chr()</code> return vectors of the corresponding type (or die trying); <code>map_df()</code> returns a data frame by row-binding the individual elements. </p>"	"<pre>map(.x, .f, ...)<br />map_lgl(.x, .f, ...)<br />map_chr(.x, .f, ...)<br />map_int(.x, .f, ...)<br />map_dbl(.x, .f, ...)<br />map_df(.x, .f, ..., .id = NULL)<br />walk(.x, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"conditional-map"	"purrr"	"Modify elements conditionally"	"<p><code>map_if()</code> maps a function over the elements of <code>.x</code> satisfying a predicate. <code>map_at()</code> is similar but will modify the elements corresponding to a character vector of names or a mumeric vector of positions. </p>"	"<pre>map_if(.x, .p, .f, ...)<br />map_at(.x, .at, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.at</code></td> <td> <p>A character vector of names or a numeric vector of positions. Only those elements corresponding to <code>.at</code> will be modified.</p> </td> </tr> </table> "	FALSE
"map"	"purrr"	"Apply a function to each element of a vector"	"<p><code>map()</code> returns the transformed input; <code>walk()</code> calls <code>.f</code> for its side-effect and returns the original input. <code>map()</code> returns a list or a data frame; <code>map_lgl()</code>, <code>map_int()</code>, <code>map_dbl()</code> and <code>map_chr()</code> return vectors of the corresponding type (or die trying); <code>map_df()</code> returns a data frame by row-binding the individual elements. </p>"	"<pre>map(.x, .f, ...)<br />map_lgl(.x, .f, ...)<br />map_chr(.x, .f, ...)<br />map_int(.x, .f, ...)<br />map_dbl(.x, .f, ...)<br />map_df(.x, .f, ..., .id = NULL)<br />walk(.x, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"map"	"purrr"	"Apply a function to each element of a vector"	"<p><code>map()</code> returns the transformed input; <code>walk()</code> calls <code>.f</code> for its side-effect and returns the original input. <code>map()</code> returns a list or a data frame; <code>map_lgl()</code>, <code>map_int()</code>, <code>map_dbl()</code> and <code>map_chr()</code> return vectors of the corresponding type (or die trying); <code>map_df()</code> returns a data frame by row-binding the individual elements. </p>"	"<pre>map(.x, .f, ...)<br />map_lgl(.x, .f, ...)<br />map_chr(.x, .f, ...)<br />map_int(.x, .f, ...)<br />map_dbl(.x, .f, ...)<br />map_df(.x, .f, ..., .id = NULL)<br />walk(.x, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"by_row"	"purrr"	"Apply a function to each row of a data frame"	"<p><code>by_row()</code> and <code>invoke_rows()</code> apply <code>..f</code> to each row of <code>.d</code>. If <code>..f</code>'s output is not a data frame nor an atomic vector, a list-column is created. In all cases, <code>by_row()</code> and <code>invoke_rows()</code> create a data frame in tidy format. </p>"	"<pre>by_row(.d, ..f, ..., .collate = c('list', 'rows', 'cols'), .to = '.out',<br />   .labels = TRUE)<br />invoke_rows(.f, .d, ..., .collate = c('list', 'rows', 'cols'), .to = '.out',<br />   .labels = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.d</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Further arguments passed to <code>..f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.collate</code></td> <td> <p>If 'list', the results are returned as a list- column. Alternatively, if the results are data frames or atomic vectors, you can collate on 'cols' or on 'rows'. Column collation require vector of equal length or data frames with same number of rows.</p> </td> </tr> <tr valign='top'> <td><code>.to</code></td> <td> <p>Name of output column.</p> </td> </tr> <tr valign='top'> <td><code>.labels</code></td> <td> <p>If <code>TRUE</code>, the returned data frame is prepended with the labels of the slices (the columns in <code>.d</code> used to define the slices). They are recycled to match the output size in each slice if necessary.</p> </td> </tr> <tr valign='top'> <td><code>.f, ..f</code></td> <td> <p>A function to apply to each row. If <code>..f</code> does not return a data frame or an atomic vector, a list-column is created under the name <code>.out</code>. If it returns a data frame, it should have the same number of rows within groups and the same number of columns between groups.</p> </td> </tr> </table> "	FALSE
"negate"	"purrr"	"Negate a predicate function."	"<p>Negate a predicate function. </p>"	"<pre>negate(.p) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr></table> "	FALSE
"null-default"	"purrr"	"Default value for NULL."	"<p>This infix function makes it easy to replace <code>NULL</code>s with a default value. It's inspired by the way that Ruby's or operation (<code>||</code>) works. </p>"	"<pre>x %||% y </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x, y</code></td> <td> <p>If <code>x</code> is NULL, will return <code>y</code>; otherwise returns <code>x</code>.</p> </td> </tr></table> "	FALSE
"split_by"	"purrr"	"Split, order and sort lists by their components."	"<p>Split, order and sort lists by their components. </p>"	"<pre>split_by(.x, .f, ...)<br />order_by(.x, .f, ...)<br />sort_by(.x, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> </table> "	FALSE
"partial"	"purrr"	"Partial apply a function, filling in some arguments."	"<p>Partial function application allows you to modify a function by pre-filling some of the arguments.  It is particularly useful in conjunction with functionals and other function operators. </p>"	"<pre>partial(...f, ..., .env = parent.frame(), .lazy = TRUE, .first = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...f</code></td> <td> <p>a function. For the output source to read well, this should be an be a named function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>named arguments to <code>...f</code> that should be partially applied.</p> </td> </tr> <tr valign='top'> <td><code>.env</code></td> <td> <p>the environment of the created function. Defaults to <code>parent.frame</code> and you should rarely need to modify this.</p> </td> </tr> <tr valign='top'> <td><code>.lazy</code></td> <td> <p>If <code>TRUE</code> arguments evaluated lazily, if <code>FALSE</code>, evaluated when <code>partial</code> is called.</p> </td> </tr> <tr valign='top'> <td><code>.first</code></td> <td> <p>If <code>TRUE</code>, the partialized arguments are placed to the front of the function signature. If <code>FALSE</code>, they are moved to the back. Only useful to control position matching of arguments when the partialized arguments are not named.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"safely"	"purrr"	"Capture side effects."	"<p>These functions wrap functions so instead generating side effects through output, messages, warnings, and errors, they instead return enchanced output. They are all adverbs because they modify the action of a verb (a function). </p>"	"<pre>safely(.f, otherwise = NULL, quiet = TRUE)<br />quietly(.f)<br />possibly(.f, otherwise, quiet = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>otherwise</code></td> <td> <p>Default value to use when an error occurs.</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>Hide errors (<code>TRUE</code>, the default), or display them as they occur?</p> </td> </tr> </table> "	FALSE
"prepend"	"purrr"	"Prepend a vector"	"<p>This is a companion to <code>append()</code> to help merging two lists or atomic vectors. <code>prepend()</code> is a clearer semantic signal than 'c()' that a vector is to be merged at the beginning of another, especially in a pipe chain. </p>"	"<pre>prepend(x, values, before = 1) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>the vector to be modified.</p> </td> </tr> <tr valign='top'> <td><code>values</code></td> <td> <p>to be included in the modified vector.</p> </td> </tr> <tr valign='top'> <td><code>before</code></td> <td> <p>a subscript, before which the values are to be appended.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"safely"	"purrr"	"Capture side effects."	"<p>These functions wrap functions so instead generating side effects through output, messages, warnings, and errors, they instead return enchanced output. They are all adverbs because they modify the action of a verb (a function). </p>"	"<pre>safely(.f, otherwise = NULL, quiet = TRUE)<br />quietly(.f)<br />possibly(.f, otherwise, quiet = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>otherwise</code></td> <td> <p>Default value to use when an error occurs.</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>Hide errors (<code>TRUE</code>, the default), or display them as they occur?</p> </td> </tr> </table> "	FALSE
"rbernoulli"	"purrr"	"Generate random samples from a Bernoulli distribution"	"<p>Generate random samples from a Bernoulli distribution </p>"	"<pre>rbernoulli(n, p = 0.5) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>n</code></td> <td> <p>Number of samples</p> </td> </tr> <tr valign='top'> <td><code>p</code></td> <td> <p>Probability of getting <code>TRUE</code></p> </td> </tr> </table> "	FALSE
"rdunif"	"purrr"	"Generate random samples from a discrete uniform distribution"	"<p>Generate random samples from a discrete uniform distribution </p>"	"<pre>rdunif(n, b, a = 1) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>n</code></td> <td> <p>Number of samples to draw.</p> </td> </tr> <tr valign='top'> <td><code>a, b</code></td> <td> <p>Range of the distribution (inclusive).</p> </td> </tr> </table> "	FALSE
"reduce"	"purrr"	"Reduce a list to a single value by iteratively applying a binary function."	"<p><code>reduce</code> combines from the left, <code>reduce_right</code> combines from the right. </p>"	"<pre>reduce(.x, .f, ..., .init)<br />reduce_right(.x, .f, ..., .init) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A two-argument function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.init</code></td> <td> <p>If supplied, will be used as the first value to start the accumulation, rather than using <code>x[[1]]</code>. This is useful if you want to ensure that <code>reduce</code> returns the correct value when <code>.x</code> is <code>is_empty()</code>.</p> </td> </tr> </table> "	FALSE
"reduce"	"purrr"	"Reduce a list to a single value by iteratively applying a binary function."	"<p><code>reduce</code> combines from the left, <code>reduce_right</code> combines from the right. </p>"	"<pre>reduce(.x, .f, ..., .init)<br />reduce_right(.x, .f, ..., .init) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A two-argument function.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.init</code></td> <td> <p>If supplied, will be used as the first value to start the accumulation, rather than using <code>x[[1]]</code>. This is useful if you want to ensure that <code>reduce</code> returns the correct value when <code>.x</code> is <code>is_empty()</code>.</p> </td> </tr> </table> "	FALSE
"along"	"purrr"	"Helper to create vectors with matching length."	"<p>These functions take the idea of <code>seq_along</code> and generalise it to creating lists (<code>list_along</code>) and repeating values (<code>rep_along</code>). </p>"	"<pre>list_along(x)<br />rep_along(x, y) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A vector.</p> </td> </tr> <tr valign='top'> <td><code>y</code></td> <td> <p>Values to repeat.</p> </td> </tr> </table> "	FALSE
"rerun"	"purrr"	"Re-run expressions multiple times."	"<p>This is a convenient way of generating sample data. It works similarly to <code>replicate(..., simplify = FALSE)</code>. </p>"	"<pre>rerun(.n, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.n</code></td> <td> <p>Number of times to run expressions</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Expressions to re-run.</p> </td> </tr> </table> "	FALSE
"safely"	"purrr"	"Capture side effects."	"<p>These functions wrap functions so instead generating side effects through output, messages, warnings, and errors, they instead return enchanced output. They are all adverbs because they modify the action of a verb (a function). </p>"	"<pre>safely(.f, otherwise = NULL, quiet = TRUE)<br />quietly(.f)<br />possibly(.f, otherwise, quiet = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>otherwise</code></td> <td> <p>Default value to use when an error occurs.</p> </td> </tr> <tr valign='top'> <td><code>quiet</code></td> <td> <p>Hide errors (<code>TRUE</code>, the default), or display them as they occur?</p> </td> </tr> </table> "	FALSE
"scalar-type-predicates"	"purrr"	"Scalar type predicates"	"<p>These predicates check for a given type and whether the vector is 'scalar', that is, of length 1. </p>"	"<pre>is_scalar_list(x)<br />is_scalar_atomic(x)<br />is_scalar_vector(x)<br />is_scalar_numeric(x)<br />is_scalar_integer(x)<br />is_scalar_double(x)<br />is_scalar_character(x)<br />is_scalar_logical(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"set_names"	"purrr"	"Set names in a vector"	"<p>This is a snake case wrapper for <code>setNames</code>, with tweaked defaults, and stricter argument checking. </p>"	"<pre>set_names(x, nm = x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Vector to name</p> </td> </tr> <tr valign='top'> <td><code>nm</code></td> <td> <p>Vector of names, the same length as <code>x</code></p> </td> </tr> </table> "	FALSE
"as_vector"	"purrr"	"Coerce a list to a vector"	"<p><code>as_vector()</code> collapses a list of vectors into one vector. It checks that the type of each vector is consistent with <code>.type</code>. If the list can not be simplified, it throws an error. <code>simplify</code> will simplify a vector if possible; <code>simplify_all</code> will apply <code>simplify</code> to every element of a list. </p>"	"<pre>as_vector(.x, .type = NULL)<br />simplify(.x, .type = NULL)<br />simplify_all(.x, .type = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list of vectors</p> </td> </tr> <tr valign='top'> <td><code>.type</code></td> <td> <p>A vector mold or a string describing the type of the input vectors. The latter can be any of the types returned by <code>typeof()</code>, or 'numeric' as a shorthand for either 'double' or 'integer'.</p> </td> </tr> </table> "	FALSE
"as_vector"	"purrr"	"Coerce a list to a vector"	"<p><code>as_vector()</code> collapses a list of vectors into one vector. It checks that the type of each vector is consistent with <code>.type</code>. If the list can not be simplified, it throws an error. <code>simplify</code> will simplify a vector if possible; <code>simplify_all</code> will apply <code>simplify</code> to every element of a list. </p>"	"<pre>as_vector(.x, .type = NULL)<br />simplify(.x, .type = NULL)<br />simplify_all(.x, .type = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list of vectors</p> </td> </tr> <tr valign='top'> <td><code>.type</code></td> <td> <p>A vector mold or a string describing the type of the input vectors. The latter can be any of the types returned by <code>typeof()</code>, or 'numeric' as a shorthand for either 'double' or 'integer'.</p> </td> </tr> </table> "	FALSE
"slice_rows"	"purrr"	"Slice a data frame into groups of rows"	"<p><code>slice_rows()</code> is equivalent to dplyr's <code>group_by()</code> command but it takes a vector of column names or positions instead of capturing column names with special evaluation. <code>unslice()</code> removes the slicing attributes. </p>"	"<pre>slice_rows(.d, .cols = NULL)<br />unslice(.d) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.d</code></td> <td> <p>A data frame to slice or unslice.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A character vector of column names or a numeric vector of column positions. If <code>NULL</code>, the slicing attributes are removed.</p> </td> </tr> </table> "	FALSE
"every"	"purrr"	"Do every or some elements of a list satisfy a predicate?"	"<p>Do every or some elements of a list satisfy a predicate? </p>"	"<pre>every(.x, .p, ...)<br />some(.x, .p, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> </table> "	FALSE
"split_by"	"purrr"	"Split, order and sort lists by their components."	"<p>Split, order and sort lists by their components. </p>"	"<pre>split_by(.x, .f, ...)<br />order_by(.x, .f, ...)<br />sort_by(.x, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> </table> "	FALSE
"splice"	"purrr"	"Splice objects and lists of objects into a list"	"<p>This splices all arguments into a list. Non-list objects and lists with a S3 class are encapsulated in a list before concatenation. </p>"	"<pre>splice(...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>...</code></td> <td> <p>Objects to concatenate.</p> </td> </tr></table> "	FALSE
"split_by"	"purrr"	"Split, order and sort lists by their components."	"<p>Split, order and sort lists by their components. </p>"	"<pre>split_by(.x, .f, ...)<br />order_by(.x, .f, ...)<br />sort_by(.x, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> </table> "	FALSE
"head_while"	"purrr"	"Find head/tail that all satisfies a predicate."	"<p>Find head/tail that all satisfies a predicate. </p>"	"<pre>head_while(.x, .p, ...)<br />tail_while(.x, .p, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.p</code></td> <td> <p>A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as <code>.x</code>. Alternatively, if the elements of <code>.x</code> are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where <code>.p</code> evaluates to <code>TRUE</code> will be modified.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> </table> "	FALSE
"transpose"	"purrr"	"Transpose a list."	"<p>Tranpose turns a list-of-lists 'inside-out'; it turns a pair of lists into a list of pairs, or a list of pairs into pair of lists. For example, If you had a list of length n where each component had values <code>a</code> and <code>b</code>, <code>transpose()</code> would make a list with elements <code>a</code> and <code>b</code> that contained lists of length n. It's called transpose because <code>x[[1]][[2]]</code> is equivalent to <code>transpose(x)[[2]][[1]]</code>. </p>"	"<pre>transpose(.l) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>.l</code></td> <td> <p>A list of vectors to zip. The first element is used as the template; you'll get a warning if a sub-list is not the same length as the first element. For efficiency, elements are matched by position, not by name.</p> </td> </tr></table> "	FALSE
"type-predicates"	"purrr"	"Type predicates"	"<p>These type predicates aim to make type testing in R more consistent. They are wrappers around <code>typeof</code>, so operate at a level beneath S3/S4 etc. </p>"	"<pre>is_list(x)<br />is_atomic(x)<br />is_vector(x)<br />is_numeric(x)<br />is_integer(x)<br />is_double(x)<br />is_character(x)<br />is_logical(x)<br />is_null(x)<br />is_function(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>object to be tested.</p> </td> </tr></table> "	FALSE
"slice_rows"	"purrr"	"Slice a data frame into groups of rows"	"<p><code>slice_rows()</code> is equivalent to dplyr's <code>group_by()</code> command but it takes a vector of column names or positions instead of capturing column names with special evaluation. <code>unslice()</code> removes the slicing attributes. </p>"	"<pre>slice_rows(.d, .cols = NULL)<br />unslice(.d) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.d</code></td> <td> <p>A data frame to slice or unslice.</p> </td> </tr> <tr valign='top'> <td><code>.cols</code></td> <td> <p>A character vector of column names or a numeric vector of column positions. If <code>NULL</code>, the slicing attributes are removed.</p> </td> </tr> </table> "	FALSE
"update_list"	"purrr"	"Modify a list"	"<p>Modify a list </p>"	"<pre>update_list(`_data`, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>_data</code></td> <td> <p>A list.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>New values of a list. Use <code>NULL</code> to remove values. Use a formula to evaluate in the context of the list values.</p> </td> </tr> </table> "	FALSE
"map"	"purrr"	"Apply a function to each element of a vector"	"<p><code>map()</code> returns the transformed input; <code>walk()</code> calls <code>.f</code> for its side-effect and returns the original input. <code>map()</code> returns a list or a data frame; <code>map_lgl()</code>, <code>map_int()</code>, <code>map_dbl()</code> and <code>map_chr()</code> return vectors of the corresponding type (or die trying); <code>map_df()</code> returns a data frame by row-binding the individual elements. </p>"	"<pre>map(.x, .f, ...)<br />map_lgl(.x, .f, ...)<br />map_chr(.x, .f, ...)<br />map_int(.x, .f, ...)<br />map_dbl(.x, .f, ...)<br />map_df(.x, .f, ..., .id = NULL)<br />walk(.x, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>A list or atomic vector.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"map2"	"purrr"	"Map over multiple inputs simultaneously."	"<p>These functions are variants of <code>map()</code> iterate over multiple arguments in parallel. <code>map2</code> is specialised for the two argument case; <code>pmap</code> allows you to provide any number of arguments in a list. </p>"	"<pre>map2(.x, .y, .f, ...)<br />map2_lgl(.x, .y, .f, ...)<br />map2_int(.x, .y, .f, ...)<br />map2_dbl(.x, .y, .f, ...)<br />map2_chr(.x, .y, .f, ...)<br />map2_df(.x, .y, .f, ..., .id = NULL)<br />pmap(.l, .f, ...)<br />pmap_lgl(.l, .f, ...)<br />pmap_int(.l, .f, ...)<br />pmap_dbl(.l, .f, ...)<br />pmap_chr(.l, .f, ...)<br />pmap_df(.l, .f, ..., .id = NULL)<br />walk2(.x, .y, .f, ...)<br />pwalk(.l, .f, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x, .y</code></td> <td> <p>Vectors of the same length. A vector of length 1 will be recycled.</p> </td> </tr> <tr valign='top'> <td><code>.f</code></td> <td> <p>A function, formula, or atomic vector. </p> <p>If a <strong>function</strong>, it is used as is. </p> <p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function with two arguments, <code>.x</code> or <code>.</code> and <code>.y</code>. This allows you to create very compact anonymous functions with up to two inputs. </p> <p>If <strong>character</strong> or <strong>integer vector</strong>, e.g. <code>'y'</code>, it is converted to an extractor function, <code>function(x) x[['y']]</code>. To index deeply into a nested list, use multiple values; <code>c('x', 'y')</code> is equivalent to <code>z[['x']][['y']]</code>. You can also set <code>.null</code> to set a default to use instead of <code>NULL</code> for absent components.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>.f</code>.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>If not <code>NULL</code> a variable with this name will be created giving either the name or the index of the data frame.</p> </td> </tr> <tr valign='top'> <td><code>.l</code></td> <td> <p>A list of lists. The length of <code>.l</code> determines the number of arguments that <code>.f</code> will be called with. List names will be used if present.</p> </td> </tr> </table> "	FALSE
"when"	"purrr"	"Match/validate a set of conditions for an object and continue with the actionassociated with the first valid match."	"<p><code>when</code> is a flavour of pattern matching (or an if-else abstraction) in which a value is matched against a sequence of condition-action sets. When a valid match/condition is found the action is executed and the result of the action is returned. </p>"	"<pre>when(., ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.</code></td> <td> <p>the value to match agaist</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>formulas; each containing a condition as LHS and an action as RHS. named arguments will define additional values.</p> </td> </tr> </table> "	FALSE
"transpose"	"purrr"	"Transpose a list."	"<p>Tranpose turns a list-of-lists 'inside-out'; it turns a pair of lists into a list of pairs, or a list of pairs into pair of lists. For example, If you had a list of length n where each component had values <code>a</code> and <code>b</code>, <code>transpose()</code> would make a list with elements <code>a</code> and <code>b</code> that contained lists of length n. It's called transpose because <code>x[[1]][[2]]</code> is equivalent to <code>transpose(x)[[2]][[1]]</code>. </p>"	"<pre>transpose(.l) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>.l</code></td> <td> <p>A list of vectors to zip. The first element is used as the template; you'll get a warning if a sub-list is not the same length as the first element. For efficiency, elements are matched by position, not by name.</p> </td> </tr></table> "	FALSE
"transpose"	"purrr"	"Transpose a list."	"<p>Tranpose turns a list-of-lists 'inside-out'; it turns a pair of lists into a list of pairs, or a list of pairs into pair of lists. For example, If you had a list of length n where each component had values <code>a</code> and <code>b</code>, <code>transpose()</code> would make a list with elements <code>a</code> and <code>b</code> that contained lists of length n. It's called transpose because <code>x[[1]][[2]]</code> is equivalent to <code>transpose(x)[[2]][[1]]</code>. </p>"	"<pre>transpose(.l) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>.l</code></td> <td> <p>A list of vectors to zip. The first element is used as the template; you'll get a warning if a sub-list is not the same length as the first element. For efficiency, elements are matched by position, not by name.</p> </td> </tr></table> "	FALSE
"transpose"	"purrr"	"Transpose a list."	"<p>Tranpose turns a list-of-lists 'inside-out'; it turns a pair of lists into a list of pairs, or a list of pairs into pair of lists. For example, If you had a list of length n where each component had values <code>a</code> and <code>b</code>, <code>transpose()</code> would make a list with elements <code>a</code> and <code>b</code> that contained lists of length n. It's called transpose because <code>x[[1]][[2]]</code> is equivalent to <code>transpose(x)[[2]][[1]]</code>. </p>"	"<pre>transpose(.l) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>.l</code></td> <td> <p>A list of vectors to zip. The first element is used as the template; you'll get a warning if a sub-list is not the same length as the first element. For efficiency, elements are matched by position, not by name.</p> </td> </tr></table> "	FALSE
"get-attr"	"purrr"	"Infix attribute accessor"	"<p>Infix attribute accessor </p>"	"<pre>x %@% name </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Object</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>Attribute name</p> </td> </tr> </table> "	FALSE
"null-default"	"purrr"	"Default value for NULL."	"<p>This infix function makes it easy to replace <code>NULL</code>s with a default value. It's inspired by the way that Ruby's or operation (<code>||</code>) works. </p>"	"<pre>x %||% y </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x, y</code></td> <td> <p>If <code>x</code> is NULL, will return <code>y</code>; otherwise returns <code>x</code>.</p> </td> </tr></table> "	FALSE
"cols"	"readr"	"Create column specification"	"<p>Create column specification </p>"	"<pre>cols(..., .default = col_guess())<br />cols_only(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Either column objects created by <code>col_*</code>, or their abbreviated character names. If you're only overriding a few columns, it's best to refer to columns by name. If not named, the column types must match the column names exactly.</p> </td> </tr> <tr valign='top'> <td><code>.default</code></td> <td> <p>Any named columns not explicitly overridden in <code>...</code> will be read with this column type.</p> </td> </tr> </table> "	FALSE
"spec"	"readr"	"Examine the column specifications for a data frame"	"<p><code>spec</code> extracts the full column specifications. <code>cols_condense</code> takes a spec object and condenses its definition by setting the default column type to the most frequent type and only listing columns with a different type. </p>"	"<pre>cols_condense(x)<br />spec(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>The data frame object to extract from</p> </td> </tr></table> "	FALSE
"cols"	"readr"	"Create column specification"	"<p>Create column specification </p>"	"<pre>cols(..., .default = col_guess())<br />cols_only(...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>Either column objects created by <code>col_*</code>, or their abbreviated character names. If you're only overriding a few columns, it's best to refer to columns by name. If not named, the column types must match the column names exactly.</p> </td> </tr> <tr valign='top'> <td><code>.default</code></td> <td> <p>Any named columns not explicitly overridden in <code>...</code> will be read with this column type.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_datetime"	"readr"	"Parse a character vector of dates or date times."	"<p>Parse a character vector of dates or date times. </p>"	"<pre>parse_datetime(x, format = '', na = c('', 'NA'),<br />   locale = default_locale())<br />parse_date(x, format = '', na = c('', 'NA'), locale = default_locale())<br />parse_time(x, format = '', na = c('', 'NA'), locale = default_locale())<br />col_datetime(format = '')<br />col_date(format = '')<br />col_time(format = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector of dates to parse.</p> </td> </tr> <tr valign='top'> <td><code>format</code></td> <td> <p>A format specification, as described below. If set to '', date times are parsed as ISO8601, dates and times used the date and time formats specified in the <code>locale</code>. </p> <p>Unlike <code>strptime</code>, the format specification must match the complete string.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_datetime"	"readr"	"Parse a character vector of dates or date times."	"<p>Parse a character vector of dates or date times. </p>"	"<pre>parse_datetime(x, format = '', na = c('', 'NA'),<br />   locale = default_locale())<br />parse_date(x, format = '', na = c('', 'NA'), locale = default_locale())<br />parse_time(x, format = '', na = c('', 'NA'), locale = default_locale())<br />col_datetime(format = '')<br />col_date(format = '')<br />col_time(format = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector of dates to parse.</p> </td> </tr> <tr valign='top'> <td><code>format</code></td> <td> <p>A format specification, as described below. If set to '', date times are parsed as ISO8601, dates and times used the date and time formats specified in the <code>locale</code>. </p> <p>Unlike <code>strptime</code>, the format specification must match the complete string.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_factor"	"readr"	"Parse a character vector into a factor"	"<p>Parse a character vector into a factor </p>"	"<pre>parse_factor(x, levels, ordered = FALSE, na = c('', 'NA'),<br />   locale = default_locale())<br />col_factor(levels, ordered = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>levels</code></td> <td> <p>Character vector providing set of allowed levels.</p> </td> </tr> <tr valign='top'> <td><code>ordered</code></td> <td> <p>Is it an ordered factor?</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_guess"	"readr"	"Parse a character vector into the \"best\" type."	"<p><code>parse_guess()</code> returns the parser vector; <code>guess_parser()</code> returns the name of the parser. These functions use a number of heuristics to determine which type of vector is 'best'. Generally they try to err of the side of safety, as it's straightforward to override the parsing choice if needed. </p>"	"<pre>parse_guess(x, na = c('', 'NA'), locale = default_locale())<br />col_guess()<br />guess_parser(x, locale = default_locale()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_number"	"readr"	"Extract numbers out of an atomic vector"	"<p>This drops any non-numeric characters before or after the first number. The grouping mark specified by the locale is ignored inside the number. </p>"	"<pre>parse_number(x, na = c('', 'NA'), locale = default_locale())<br />col_number() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_datetime"	"readr"	"Parse a character vector of dates or date times."	"<p>Parse a character vector of dates or date times. </p>"	"<pre>parse_datetime(x, format = '', na = c('', 'NA'),<br />   locale = default_locale())<br />parse_date(x, format = '', na = c('', 'NA'), locale = default_locale())<br />parse_time(x, format = '', na = c('', 'NA'), locale = default_locale())<br />col_datetime(format = '')<br />col_date(format = '')<br />col_time(format = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector of dates to parse.</p> </td> </tr> <tr valign='top'> <td><code>format</code></td> <td> <p>A format specification, as described below. If set to '', date times are parsed as ISO8601, dates and times used the date and time formats specified in the <code>locale</code>. </p> <p>Unlike <code>strptime</code>, the format specification must match the complete string.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"count_fields"	"readr"	"Count the number of fields in each line of a file."	"<p>This is useful for diagnosing problems with functions that fail to parse correctly. </p>"	"<pre>count_fields(file, tokenizer, skip = 0, n_max = -1L) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>tokenizer</code></td> <td> <p>A tokenizer that specifies how to break the <code>file</code> up into fields, e.g., <code>tokenizer_csv</code>, <code>tokenizer_fwf</code></p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Optionally, maximum number of rows to count fields for.</p> </td> </tr> </table> "	FALSE
"date_names"	"readr"	"Create or retrieve date names"	"<p>When parsing dates, you often need to know how weekdays of the week and months are represented as text. This pair of functions allows you to either create your own, or retrieve from a standard list. The standard list is derived from ICU (<a href='http://site.icu-project.org'>http://site.icu-project.org</a>) via the stringi package. </p>"	"<pre>date_names(mon, mon_ab = mon, day, day_ab = day, am_pm = c('AM', 'PM'))<br />date_names_lang(language)<br />date_names_langs() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mon, mon_ab</code></td> <td> <p>Full and abbreviated month names. Starts with Sunday.</p> </td> </tr> <tr valign='top'> <td><code>day, day_ab</code></td> <td> <p>Full and abbreviated week day names</p> </td> </tr> <tr valign='top'> <td><code>am_pm</code></td> <td> <p>Names used for AM and PM.</p> </td> </tr> <tr valign='top'> <td><code>language</code></td> <td> <p>A BCP 47 locale, made up of a languge and a region, e.g. <code>en_US</code> for American English. See <code>date_names_locales()</code> for a complete list of available locales.</p> </td> </tr> </table> "	FALSE
"date_names"	"readr"	"Create or retrieve date names"	"<p>When parsing dates, you often need to know how weekdays of the week and months are represented as text. This pair of functions allows you to either create your own, or retrieve from a standard list. The standard list is derived from ICU (<a href='http://site.icu-project.org'>http://site.icu-project.org</a>) via the stringi package. </p>"	"<pre>date_names(mon, mon_ab = mon, day, day_ab = day, am_pm = c('AM', 'PM'))<br />date_names_lang(language)<br />date_names_langs() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mon, mon_ab</code></td> <td> <p>Full and abbreviated month names. Starts with Sunday.</p> </td> </tr> <tr valign='top'> <td><code>day, day_ab</code></td> <td> <p>Full and abbreviated week day names</p> </td> </tr> <tr valign='top'> <td><code>am_pm</code></td> <td> <p>Names used for AM and PM.</p> </td> </tr> <tr valign='top'> <td><code>language</code></td> <td> <p>A BCP 47 locale, made up of a languge and a region, e.g. <code>en_US</code> for American English. See <code>date_names_locales()</code> for a complete list of available locales.</p> </td> </tr> </table> "	FALSE
"date_names"	"readr"	"Create or retrieve date names"	"<p>When parsing dates, you often need to know how weekdays of the week and months are represented as text. This pair of functions allows you to either create your own, or retrieve from a standard list. The standard list is derived from ICU (<a href='http://site.icu-project.org'>http://site.icu-project.org</a>) via the stringi package. </p>"	"<pre>date_names(mon, mon_ab = mon, day, day_ab = day, am_pm = c('AM', 'PM'))<br />date_names_lang(language)<br />date_names_langs() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>mon, mon_ab</code></td> <td> <p>Full and abbreviated month names. Starts with Sunday.</p> </td> </tr> <tr valign='top'> <td><code>day, day_ab</code></td> <td> <p>Full and abbreviated week day names</p> </td> </tr> <tr valign='top'> <td><code>am_pm</code></td> <td> <p>Names used for AM and PM.</p> </td> </tr> <tr valign='top'> <td><code>language</code></td> <td> <p>A BCP 47 locale, made up of a languge and a region, e.g. <code>en_US</code> for American English. See <code>date_names_locales()</code> for a complete list of available locales.</p> </td> </tr> </table> "	FALSE
"locale"	"readr"	"Create locales"	"<p>A locale object tries to capture all the defaults that can vary between countries. You set the locale in once, and the details are automatically passed on down to the columns parsers. The defaults have been chosen to match R (i.e. US English) as closely as possible. </p>"	"<pre>locale(date_names = 'en', date_format = '%AD', time_format = '%AT',<br />   decimal_mark = '.', grouping_mark = ',', tz = 'UTC',<br />   encoding = 'UTF-8', asciify = FALSE)<br />default_locale() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>date_names</code></td> <td> <p>Character representations of day and month names. Either the language code as string (passed on to <code>date_names_lang</code>) or an object created by <code>date_names</code>.</p> </td> </tr> <tr valign='top'> <td><code>date_format, time_format</code></td> <td> <p>Default date and time formats.</p> </td> </tr> <tr valign='top'> <td><code>decimal_mark, grouping_mark</code></td> <td> <p>Symbols used to indicate the decimal place, and to chunk larger numbers. Decimal mark can only be <code>,</code> or <code>.</code>.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>Default tz. This is used both for input (if the time zone isn't present in individual strings), and for output (to control the default display). The default is to use 'UTC', a time zone that does not use daylight savings time (DST) and hence is typically most useful for data. The absense of time zones makes it approximately 50x faster to generate UTC times than any other time zone. </p> <p>Use <code>''</code> to use the system default time zone, but beware that this will not be reproducible across systems. </p> <p>For a complete list of possible time zones, see <code>OlsonNames()</code>. Americans, note that 'EST' is a Canadian time zone that does not have DST. It is <em>not</em> Eastern Standard Time. It's better to use 'US/Eastern', 'US/Central' etc.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>Default encoding. This only affects how the file is read - readr always converts the output to UTF-8.</p> </td> </tr> <tr valign='top'> <td><code>asciify</code></td> <td> <p>Should diacritics be stripped from date names and converted to ASCII? This is useful if you're dealing with ASCII data where the correct spellings have been lost. Requires the <span class='pkg'>stringi</span> package.</p> </td> </tr> </table> "	FALSE
"write_delim"	"readr"	"Save a data frame to a delimited file."	"<p>This is about twice as fast as <code>write.csv</code>, and never writes row names. <code>output_column</code> is a generic method used to coerce columns to suitable output. </p>"	"<pre>write_delim(x, path, delim = ' ', na = 'NA', append = FALSE,<br />   col_names = !append)<br />write_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_excel_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_tsv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />format_csv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_tsv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_delim(x, delim, na = 'NA', append = FALSE, col_names = !append)<br />output_column(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to write to.</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Delimiter used to seperate values. Defaults to <code>' '</code>. Must be a single character.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>String used for missing values. Defaults to NA. Missing values will never be quoted; strings with the same value as <code>na</code> will always be quoted.</p> </td> </tr> <tr valign='top'> <td><code>append</code></td> <td> <p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>, will append to existing file. In both cases, if file does not exist a new file is created.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Write columns names at the top of the file?</p> </td> </tr> </table> "	FALSE
"write_delim"	"readr"	"Save a data frame to a delimited file."	"<p>This is about twice as fast as <code>write.csv</code>, and never writes row names. <code>output_column</code> is a generic method used to coerce columns to suitable output. </p>"	"<pre>write_delim(x, path, delim = ' ', na = 'NA', append = FALSE,<br />   col_names = !append)<br />write_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_excel_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_tsv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />format_csv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_tsv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_delim(x, delim, na = 'NA', append = FALSE, col_names = !append)<br />output_column(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to write to.</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Delimiter used to seperate values. Defaults to <code>' '</code>. Must be a single character.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>String used for missing values. Defaults to NA. Missing values will never be quoted; strings with the same value as <code>na</code> will always be quoted.</p> </td> </tr> <tr valign='top'> <td><code>append</code></td> <td> <p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>, will append to existing file. In both cases, if file does not exist a new file is created.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Write columns names at the top of the file?</p> </td> </tr> </table> "	FALSE
"write_delim"	"readr"	"Save a data frame to a delimited file."	"<p>This is about twice as fast as <code>write.csv</code>, and never writes row names. <code>output_column</code> is a generic method used to coerce columns to suitable output. </p>"	"<pre>write_delim(x, path, delim = ' ', na = 'NA', append = FALSE,<br />   col_names = !append)<br />write_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_excel_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_tsv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />format_csv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_tsv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_delim(x, delim, na = 'NA', append = FALSE, col_names = !append)<br />output_column(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to write to.</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Delimiter used to seperate values. Defaults to <code>' '</code>. Must be a single character.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>String used for missing values. Defaults to NA. Missing values will never be quoted; strings with the same value as <code>na</code> will always be quoted.</p> </td> </tr> <tr valign='top'> <td><code>append</code></td> <td> <p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>, will append to existing file. In both cases, if file does not exist a new file is created.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Write columns names at the top of the file?</p> </td> </tr> </table> "	FALSE
"read_fwf"	"readr"	"Read a fixed width file."	"<p>A fixed width file can be a very compact representation of numeric data. It's also very fast to parse, because every field is in the same place in every line. Unfortunately, it's painful to parse because you need to describe the length of every field. Readr aims to make it as easy as possible by providing a number of different ways to describe the field structure. </p>"	"<pre>read_fwf(file, col_positions, col_types = NULL, locale = default_locale(),<br />   na = c('', 'NA'), comment = '', skip = 0, n_max = Inf,<br />   guess_max = min(n_max, 1000), progress = interactive())<br />fwf_empty(file, skip = 0, col_names = NULL, comment = '')<br />fwf_widths(widths, col_names = NULL)<br />fwf_positions(start, end, col_names = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>col_positions</code></td> <td> <p>Column positions, as created by <code>fwf_empty</code>, <code>fwf_widths</code> or <code>fwf_positions</code>. To read in only selected fields, use <code>fwf_positions</code>. If the width of the last column is variable (a ragged fwf file), supply the last end position as NA.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either NULL, or a character vector column names.</p> </td> </tr> <tr valign='top'> <td><code>widths</code></td> <td> <p>Width of each field. Use NA as width of last field when reading a ragged fwf file.</p> </td> </tr> <tr valign='top'> <td><code>start, end</code></td> <td> <p>Starting and ending (inclusive) positions of each field. Use NA as last end field when reading a ragged fwf file.</p> </td> </tr> </table> "	FALSE
"read_fwf"	"readr"	"Read a fixed width file."	"<p>A fixed width file can be a very compact representation of numeric data. It's also very fast to parse, because every field is in the same place in every line. Unfortunately, it's painful to parse because you need to describe the length of every field. Readr aims to make it as easy as possible by providing a number of different ways to describe the field structure. </p>"	"<pre>read_fwf(file, col_positions, col_types = NULL, locale = default_locale(),<br />   na = c('', 'NA'), comment = '', skip = 0, n_max = Inf,<br />   guess_max = min(n_max, 1000), progress = interactive())<br />fwf_empty(file, skip = 0, col_names = NULL, comment = '')<br />fwf_widths(widths, col_names = NULL)<br />fwf_positions(start, end, col_names = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>col_positions</code></td> <td> <p>Column positions, as created by <code>fwf_empty</code>, <code>fwf_widths</code> or <code>fwf_positions</code>. To read in only selected fields, use <code>fwf_positions</code>. If the width of the last column is variable (a ragged fwf file), supply the last end position as NA.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either NULL, or a character vector column names.</p> </td> </tr> <tr valign='top'> <td><code>widths</code></td> <td> <p>Width of each field. Use NA as width of last field when reading a ragged fwf file.</p> </td> </tr> <tr valign='top'> <td><code>start, end</code></td> <td> <p>Starting and ending (inclusive) positions of each field. Use NA as last end field when reading a ragged fwf file.</p> </td> </tr> </table> "	FALSE
"read_fwf"	"readr"	"Read a fixed width file."	"<p>A fixed width file can be a very compact representation of numeric data. It's also very fast to parse, because every field is in the same place in every line. Unfortunately, it's painful to parse because you need to describe the length of every field. Readr aims to make it as easy as possible by providing a number of different ways to describe the field structure. </p>"	"<pre>read_fwf(file, col_positions, col_types = NULL, locale = default_locale(),<br />   na = c('', 'NA'), comment = '', skip = 0, n_max = Inf,<br />   guess_max = min(n_max, 1000), progress = interactive())<br />fwf_empty(file, skip = 0, col_names = NULL, comment = '')<br />fwf_widths(widths, col_names = NULL)<br />fwf_positions(start, end, col_names = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>col_positions</code></td> <td> <p>Column positions, as created by <code>fwf_empty</code>, <code>fwf_widths</code> or <code>fwf_positions</code>. To read in only selected fields, use <code>fwf_positions</code>. If the width of the last column is variable (a ragged fwf file), supply the last end position as NA.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either NULL, or a character vector column names.</p> </td> </tr> <tr valign='top'> <td><code>widths</code></td> <td> <p>Width of each field. Use NA as width of last field when reading a ragged fwf file.</p> </td> </tr> <tr valign='top'> <td><code>start, end</code></td> <td> <p>Starting and ending (inclusive) positions of each field. Use NA as last end field when reading a ragged fwf file.</p> </td> </tr> </table> "	FALSE
"encoding"	"readr"	"Guess encoding of file."	"<p>Uses <code>stri_enc_detect</code>: see the documentation there for caveats. </p>"	"<pre>guess_encoding(file, n_max = 10000, threshold = 0.2) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Number of lines to read. If <code>n_max</code> is -1, all lines in file will be read.</p> </td> </tr> <tr valign='top'> <td><code>threshold</code></td> <td> <p>Only report guesses above this threshold of certainty.</p> </td> </tr> </table> "	FALSE
"parse_guess"	"readr"	"Parse a character vector into the \"best\" type."	"<p><code>parse_guess()</code> returns the parser vector; <code>guess_parser()</code> returns the name of the parser. These functions use a number of heuristics to determine which type of vector is 'best'. Generally they try to err of the side of safety, as it's straightforward to override the parsing choice if needed. </p>"	"<pre>parse_guess(x, na = c('', 'NA'), locale = default_locale())<br />col_guess()<br />guess_parser(x, locale = default_locale()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"locale"	"readr"	"Create locales"	"<p>A locale object tries to capture all the defaults that can vary between countries. You set the locale in once, and the details are automatically passed on down to the columns parsers. The defaults have been chosen to match R (i.e. US English) as closely as possible. </p>"	"<pre>locale(date_names = 'en', date_format = '%AD', time_format = '%AT',<br />   decimal_mark = '.', grouping_mark = ',', tz = 'UTC',<br />   encoding = 'UTF-8', asciify = FALSE)<br />default_locale() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>date_names</code></td> <td> <p>Character representations of day and month names. Either the language code as string (passed on to <code>date_names_lang</code>) or an object created by <code>date_names</code>.</p> </td> </tr> <tr valign='top'> <td><code>date_format, time_format</code></td> <td> <p>Default date and time formats.</p> </td> </tr> <tr valign='top'> <td><code>decimal_mark, grouping_mark</code></td> <td> <p>Symbols used to indicate the decimal place, and to chunk larger numbers. Decimal mark can only be <code>,</code> or <code>.</code>.</p> </td> </tr> <tr valign='top'> <td><code>tz</code></td> <td> <p>Default tz. This is used both for input (if the time zone isn't present in individual strings), and for output (to control the default display). The default is to use 'UTC', a time zone that does not use daylight savings time (DST) and hence is typically most useful for data. The absense of time zones makes it approximately 50x faster to generate UTC times than any other time zone. </p> <p>Use <code>''</code> to use the system default time zone, but beware that this will not be reproducible across systems. </p> <p>For a complete list of possible time zones, see <code>OlsonNames()</code>. Americans, note that 'EST' is a Canadian time zone that does not have DST. It is <em>not</em> Eastern Standard Time. It's better to use 'US/Eastern', 'US/Central' etc.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>Default encoding. This only affects how the file is read - readr always converts the output to UTF-8.</p> </td> </tr> <tr valign='top'> <td><code>asciify</code></td> <td> <p>Should diacritics be stripped from date names and converted to ASCII? This is useful if you're dealing with ASCII data where the correct spellings have been lost. Requires the <span class='pkg'>stringi</span> package.</p> </td> </tr> </table> "	FALSE
"write_delim"	"readr"	"Save a data frame to a delimited file."	"<p>This is about twice as fast as <code>write.csv</code>, and never writes row names. <code>output_column</code> is a generic method used to coerce columns to suitable output. </p>"	"<pre>write_delim(x, path, delim = ' ', na = 'NA', append = FALSE,<br />   col_names = !append)<br />write_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_excel_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_tsv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />format_csv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_tsv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_delim(x, delim, na = 'NA', append = FALSE, col_names = !append)<br />output_column(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to write to.</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Delimiter used to seperate values. Defaults to <code>' '</code>. Must be a single character.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>String used for missing values. Defaults to NA. Missing values will never be quoted; strings with the same value as <code>na</code> will always be quoted.</p> </td> </tr> <tr valign='top'> <td><code>append</code></td> <td> <p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>, will append to existing file. In both cases, if file does not exist a new file is created.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Write columns names at the top of the file?</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_datetime"	"readr"	"Parse a character vector of dates or date times."	"<p>Parse a character vector of dates or date times. </p>"	"<pre>parse_datetime(x, format = '', na = c('', 'NA'),<br />   locale = default_locale())<br />parse_date(x, format = '', na = c('', 'NA'), locale = default_locale())<br />parse_time(x, format = '', na = c('', 'NA'), locale = default_locale())<br />col_datetime(format = '')<br />col_date(format = '')<br />col_time(format = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector of dates to parse.</p> </td> </tr> <tr valign='top'> <td><code>format</code></td> <td> <p>A format specification, as described below. If set to '', date times are parsed as ISO8601, dates and times used the date and time formats specified in the <code>locale</code>. </p> <p>Unlike <code>strptime</code>, the format specification must match the complete string.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_datetime"	"readr"	"Parse a character vector of dates or date times."	"<p>Parse a character vector of dates or date times. </p>"	"<pre>parse_datetime(x, format = '', na = c('', 'NA'),<br />   locale = default_locale())<br />parse_date(x, format = '', na = c('', 'NA'), locale = default_locale())<br />parse_time(x, format = '', na = c('', 'NA'), locale = default_locale())<br />col_datetime(format = '')<br />col_date(format = '')<br />col_time(format = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector of dates to parse.</p> </td> </tr> <tr valign='top'> <td><code>format</code></td> <td> <p>A format specification, as described below. If set to '', date times are parsed as ISO8601, dates and times used the date and time formats specified in the <code>locale</code>. </p> <p>Unlike <code>strptime</code>, the format specification must match the complete string.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_factor"	"readr"	"Parse a character vector into a factor"	"<p>Parse a character vector into a factor </p>"	"<pre>parse_factor(x, levels, ordered = FALSE, na = c('', 'NA'),<br />   locale = default_locale())<br />col_factor(levels, ordered = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>levels</code></td> <td> <p>Character vector providing set of allowed levels.</p> </td> </tr> <tr valign='top'> <td><code>ordered</code></td> <td> <p>Is it an ordered factor?</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_guess"	"readr"	"Parse a character vector into the \"best\" type."	"<p><code>parse_guess()</code> returns the parser vector; <code>guess_parser()</code> returns the name of the parser. These functions use a number of heuristics to determine which type of vector is 'best'. Generally they try to err of the side of safety, as it's straightforward to override the parsing choice if needed. </p>"	"<pre>parse_guess(x, na = c('', 'NA'), locale = default_locale())<br />col_guess()<br />guess_parser(x, locale = default_locale()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_number"	"readr"	"Extract numbers out of an atomic vector"	"<p>This drops any non-numeric characters before or after the first number. The grouping mark specified by the locale is ignored inside the number. </p>"	"<pre>parse_number(x, na = c('', 'NA'), locale = default_locale())<br />col_number() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_atomic"	"readr"	"Parse character vector in an atomic vector."	"<p>Use <code>parse_</code> if you have a character vector you want to parse. Use <code>col_</code> in conjunction with a <code>read_</code> function to parse the values as they're read in. </p>"	"<pre>parse_logical(x, na = c('', 'NA'), locale = default_locale())<br />parse_integer(x, na = c('', 'NA'), locale = default_locale())<br />parse_double(x, na = c('', 'NA'), locale = default_locale())<br />parse_character(x, na = c('', 'NA'), locale = default_locale())<br />col_logical()<br />col_integer()<br />col_double()<br />col_character()<br />col_skip() </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Character vector of values to parse.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"parse_datetime"	"readr"	"Parse a character vector of dates or date times."	"<p>Parse a character vector of dates or date times. </p>"	"<pre>parse_datetime(x, format = '', na = c('', 'NA'),<br />   locale = default_locale())<br />parse_date(x, format = '', na = c('', 'NA'), locale = default_locale())<br />parse_time(x, format = '', na = c('', 'NA'), locale = default_locale())<br />col_datetime(format = '')<br />col_date(format = '')<br />col_time(format = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector of dates to parse.</p> </td> </tr> <tr valign='top'> <td><code>format</code></td> <td> <p>A format specification, as described below. If set to '', date times are parsed as ISO8601, dates and times used the date and time formats specified in the <code>locale</code>. </p> <p>Unlike <code>strptime</code>, the format specification must match the complete string.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"problems"	"readr"	"Retrieve parsing problems."	"<p>Readr functions will only throw an error if parsing fails in an unrecoverable way. However, there are lots of potential problems that you might want to know about - these are stored in the <code>problems</code> attribute of the output, which you can easily access with this function. <code>stop_for_problems()</code> will throw an error if there are any parsing problems: this is useful for automated scripts where you want to throw an error as soon as you encounter a problem. </p>"	"<pre>problems(x)<br />stop_for_problems(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>An data frame (from <code>read_*</code>) or a vector (from <code>parse_*</code>).</p> </td> </tr></table> "	FALSE
"readr_example"	"readr"	"Get path to readr example"	"<p>readr comes bundled with a number of sample files in its <code>inst/extdata</code> directory. This function make them easy to access </p>"	"<pre>readr_example(path) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>path</code></td> <td> <p>Name of file</p> </td> </tr></table> "	FALSE
"read_delim"	"readr"	"Read a delimited file into a data frame."	"<p><code>read_csv</code> and <code>read_tsv</code> are special cases of the general <code>read_delim</code>. They're useful for reading the most common types of flat file data, comma separated values and tab separated values, respectively. <code>read_csv2</code> uses <code>;</code> for separators, instead of <code>,</code>. This is common in European countries which use <code>,</code> as the decimal separator. </p>"	"<pre>read_delim(file, delim, quote = '\'', escape_backslash = FALSE,<br />   escape_double = TRUE, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = FALSE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_csv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_csv2(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_tsv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Single character used to separate fields within a record.</p> </td> </tr> <tr valign='top'> <td><code>quote</code></td> <td> <p>Single character used to quote strings.</p> </td> </tr> <tr valign='top'> <td><code>escape_backslash</code></td> <td> <p>Does the file use backslashes to escape special characters? This is more general than <code>escape_double</code> as backslashes can be used to escape the delimeter character, the quote characer, or to add special characters like <code>\n</code>.</p> </td> </tr> <tr valign='top'> <td><code>escape_double</code></td> <td> <p>Does the file escape quotes by doubling them? i.e. If this option is <code>TRUE</code>, the value <code>''''</code> represents a single quote, <code>\'</code>.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column names. </p> <p>If <code>TRUE</code>, the first row of the input will be used as the column names, and will not be included in the data frame. If <code>FALSE</code>, column names will be generated automatically: X1, X2, X3 etc. </p> <p>If <code>col_names</code> is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. </p> <p>Missing (<code>NA</code>) column names will generate a warning, and be filled in with dummy names <code>X1</code>, <code>X2</code> etc. Duplicate column names will generate a warning and be made unique with a numeric prefix.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>quoted_na</code></td> <td> <p>Should missing values inside quotes be treated as missing values (the default) or strings.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>trim_ws</code></td> <td> <p>Should leading and trailing whitespace be trimmed from each field before parsing it?</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"read_delim"	"readr"	"Read a delimited file into a data frame."	"<p><code>read_csv</code> and <code>read_tsv</code> are special cases of the general <code>read_delim</code>. They're useful for reading the most common types of flat file data, comma separated values and tab separated values, respectively. <code>read_csv2</code> uses <code>;</code> for separators, instead of <code>,</code>. This is common in European countries which use <code>,</code> as the decimal separator. </p>"	"<pre>read_delim(file, delim, quote = '\'', escape_backslash = FALSE,<br />   escape_double = TRUE, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = FALSE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_csv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_csv2(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_tsv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Single character used to separate fields within a record.</p> </td> </tr> <tr valign='top'> <td><code>quote</code></td> <td> <p>Single character used to quote strings.</p> </td> </tr> <tr valign='top'> <td><code>escape_backslash</code></td> <td> <p>Does the file use backslashes to escape special characters? This is more general than <code>escape_double</code> as backslashes can be used to escape the delimeter character, the quote characer, or to add special characters like <code>\n</code>.</p> </td> </tr> <tr valign='top'> <td><code>escape_double</code></td> <td> <p>Does the file escape quotes by doubling them? i.e. If this option is <code>TRUE</code>, the value <code>''''</code> represents a single quote, <code>\'</code>.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column names. </p> <p>If <code>TRUE</code>, the first row of the input will be used as the column names, and will not be included in the data frame. If <code>FALSE</code>, column names will be generated automatically: X1, X2, X3 etc. </p> <p>If <code>col_names</code> is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. </p> <p>Missing (<code>NA</code>) column names will generate a warning, and be filled in with dummy names <code>X1</code>, <code>X2</code> etc. Duplicate column names will generate a warning and be made unique with a numeric prefix.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>quoted_na</code></td> <td> <p>Should missing values inside quotes be treated as missing values (the default) or strings.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>trim_ws</code></td> <td> <p>Should leading and trailing whitespace be trimmed from each field before parsing it?</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"read_delim"	"readr"	"Read a delimited file into a data frame."	"<p><code>read_csv</code> and <code>read_tsv</code> are special cases of the general <code>read_delim</code>. They're useful for reading the most common types of flat file data, comma separated values and tab separated values, respectively. <code>read_csv2</code> uses <code>;</code> for separators, instead of <code>,</code>. This is common in European countries which use <code>,</code> as the decimal separator. </p>"	"<pre>read_delim(file, delim, quote = '\'', escape_backslash = FALSE,<br />   escape_double = TRUE, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = FALSE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_csv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_csv2(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_tsv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Single character used to separate fields within a record.</p> </td> </tr> <tr valign='top'> <td><code>quote</code></td> <td> <p>Single character used to quote strings.</p> </td> </tr> <tr valign='top'> <td><code>escape_backslash</code></td> <td> <p>Does the file use backslashes to escape special characters? This is more general than <code>escape_double</code> as backslashes can be used to escape the delimeter character, the quote characer, or to add special characters like <code>\n</code>.</p> </td> </tr> <tr valign='top'> <td><code>escape_double</code></td> <td> <p>Does the file escape quotes by doubling them? i.e. If this option is <code>TRUE</code>, the value <code>''''</code> represents a single quote, <code>\'</code>.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column names. </p> <p>If <code>TRUE</code>, the first row of the input will be used as the column names, and will not be included in the data frame. If <code>FALSE</code>, column names will be generated automatically: X1, X2, X3 etc. </p> <p>If <code>col_names</code> is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. </p> <p>Missing (<code>NA</code>) column names will generate a warning, and be filled in with dummy names <code>X1</code>, <code>X2</code> etc. Duplicate column names will generate a warning and be made unique with a numeric prefix.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>quoted_na</code></td> <td> <p>Should missing values inside quotes be treated as missing values (the default) or strings.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>trim_ws</code></td> <td> <p>Should leading and trailing whitespace be trimmed from each field before parsing it?</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"read_file"	"readr"	"Read a file into a string."	"<p>Read a file into a string. </p>"	"<pre>read_file(file, locale = default_locale())<br />read_file_raw(file) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"read_file"	"readr"	"Read a file into a string."	"<p>Read a file into a string. </p>"	"<pre>read_file(file, locale = default_locale())<br />read_file_raw(file) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"read_fwf"	"readr"	"Read a fixed width file."	"<p>A fixed width file can be a very compact representation of numeric data. It's also very fast to parse, because every field is in the same place in every line. Unfortunately, it's painful to parse because you need to describe the length of every field. Readr aims to make it as easy as possible by providing a number of different ways to describe the field structure. </p>"	"<pre>read_fwf(file, col_positions, col_types = NULL, locale = default_locale(),<br />   na = c('', 'NA'), comment = '', skip = 0, n_max = Inf,<br />   guess_max = min(n_max, 1000), progress = interactive())<br />fwf_empty(file, skip = 0, col_names = NULL, comment = '')<br />fwf_widths(widths, col_names = NULL)<br />fwf_positions(start, end, col_names = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>col_positions</code></td> <td> <p>Column positions, as created by <code>fwf_empty</code>, <code>fwf_widths</code> or <code>fwf_positions</code>. To read in only selected fields, use <code>fwf_positions</code>. If the width of the last column is variable (a ragged fwf file), supply the last end position as NA.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either NULL, or a character vector column names.</p> </td> </tr> <tr valign='top'> <td><code>widths</code></td> <td> <p>Width of each field. Use NA as width of last field when reading a ragged fwf file.</p> </td> </tr> <tr valign='top'> <td><code>start, end</code></td> <td> <p>Starting and ending (inclusive) positions of each field. Use NA as last end field when reading a ragged fwf file.</p> </td> </tr> </table> "	FALSE
"read_lines"	"readr"	"Read lines from a file or string."	"<p>Read lines from a file or string. </p>"	"<pre>read_lines(file, skip = 0, n_max = -1L, locale = default_locale(),<br />   na = character(), progress = interactive())<br />read_lines_raw(file, skip = 0, n_max = -1L, progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Number of lines to read. If <code>n_max</code> is -1, all lines in file will be read.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"read_lines"	"readr"	"Read lines from a file or string."	"<p>Read lines from a file or string. </p>"	"<pre>read_lines(file, skip = 0, n_max = -1L, locale = default_locale(),<br />   na = character(), progress = interactive())<br />read_lines_raw(file, skip = 0, n_max = -1L, progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Number of lines to read. If <code>n_max</code> is -1, all lines in file will be read.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"read_log"	"readr"	"Read common/combined log file."	"<p>This is a fairly standard format for log files - it uses both quotes and square brackets for quoting, and there may be literal quotes embedded in a quoted string. The dash, '-', is used for missing values. </p>"	"<pre>read_log(file, col_names = FALSE, col_types = NULL, skip = 0,<br />   n_max = -1, progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column names. </p> <p>If <code>TRUE</code>, the first row of the input will be used as the column names, and will not be included in the data frame. If <code>FALSE</code>, column names will be generated automatically: X1, X2, X3 etc. </p> <p>If <code>col_names</code> is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. </p> <p>Missing (<code>NA</code>) column names will generate a warning, and be filled in with dummy names <code>X1</code>, <code>X2</code> etc. Duplicate column names will generate a warning and be made unique with a numeric prefix.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"read_rds"	"readr"	"Read object from RDS file."	"<p>This is a minimal wrapper around <code>readRDS</code> that uses the same naming scheme as all other functions in <span class='pkg'>readr</span>. </p>"	"<pre>read_rds(path) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>path</code></td> <td> <p>Path of file</p> </td> </tr></table> "	FALSE
"read_table"	"readr"	"Read text file where columns are separated by whitespace."	"<p>This is designed to read the type of textual data where each column is separate by one (or more) columns of space. Each line is the same length, and each field is in the same position in every line. It's similar to <code>read.table</code>, but rather parsing like a file delimited by arbitrary amounts of whitespace, it first finds empty columns and then parses like a fixed width file. <code>spec_table</code> returns the column specification rather than a data frame. </p>"	"<pre>read_table(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = 'NA', skip = 0, n_max = Inf,<br />   guess_max = min(n_max, 1000), progress = interactive())<br />spec_table(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = 'NA', skip = 0, n_max = 0,<br />   guess_max = 1000, progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column names. </p> <p>If <code>TRUE</code>, the first row of the input will be used as the column names, and will not be included in the data frame. If <code>FALSE</code>, column names will be generated automatically: X1, X2, X3 etc. </p> <p>If <code>col_names</code> is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. </p> <p>Missing (<code>NA</code>) column names will generate a warning, and be filled in with dummy names <code>X1</code>, <code>X2</code> etc. Duplicate column names will generate a warning and be made unique with a numeric prefix.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"read_delim"	"readr"	"Read a delimited file into a data frame."	"<p><code>read_csv</code> and <code>read_tsv</code> are special cases of the general <code>read_delim</code>. They're useful for reading the most common types of flat file data, comma separated values and tab separated values, respectively. <code>read_csv2</code> uses <code>;</code> for separators, instead of <code>,</code>. This is common in European countries which use <code>,</code> as the decimal separator. </p>"	"<pre>read_delim(file, delim, quote = '\'', escape_backslash = FALSE,<br />   escape_double = TRUE, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = FALSE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_csv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_csv2(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive())<br />read_tsv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = Inf,<br />   guess_max = min(1000, n_max), progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Single character used to separate fields within a record.</p> </td> </tr> <tr valign='top'> <td><code>quote</code></td> <td> <p>Single character used to quote strings.</p> </td> </tr> <tr valign='top'> <td><code>escape_backslash</code></td> <td> <p>Does the file use backslashes to escape special characters? This is more general than <code>escape_double</code> as backslashes can be used to escape the delimeter character, the quote characer, or to add special characters like <code>\n</code>.</p> </td> </tr> <tr valign='top'> <td><code>escape_double</code></td> <td> <p>Does the file escape quotes by doubling them? i.e. If this option is <code>TRUE</code>, the value <code>''''</code> represents a single quote, <code>\'</code>.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column names. </p> <p>If <code>TRUE</code>, the first row of the input will be used as the column names, and will not be included in the data frame. If <code>FALSE</code>, column names will be generated automatically: X1, X2, X3 etc. </p> <p>If <code>col_names</code> is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. </p> <p>Missing (<code>NA</code>) column names will generate a warning, and be filled in with dummy names <code>X1</code>, <code>X2</code> etc. Duplicate column names will generate a warning and be made unique with a numeric prefix.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>quoted_na</code></td> <td> <p>Should missing values inside quotes be treated as missing values (the default) or strings.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>trim_ws</code></td> <td> <p>Should leading and trailing whitespace be trimmed from each field before parsing it?</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"spec"	"readr"	"Examine the column specifications for a data frame"	"<p><code>spec</code> extracts the full column specifications. <code>cols_condense</code> takes a spec object and condenses its definition by setting the default column type to the most frequent type and only listing columns with a different type. </p>"	"<pre>cols_condense(x)<br />spec(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>The data frame object to extract from</p> </td> </tr></table> "	FALSE
"spec_delim"	"readr"	"Retrieve the column specification of a file."	"<p>By default the types of the first 20 columns are printed, <code>options(readr.num_columns)</code> can be used to modify this (a value of 0 turns off printing). </p>"	"<pre>spec_delim(file, delim, quote = '\'', escape_backslash = FALSE,<br />   escape_double = TRUE, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = FALSE, skip = 0, n_max = 0,<br />   guess_max = 1000, progress = interactive())<br />spec_csv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive())<br />spec_csv2(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive())<br />spec_tsv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Single character used to separate fields within a record.</p> </td> </tr> <tr valign='top'> <td><code>quote</code></td> <td> <p>Single character used to quote strings.</p> </td> </tr> <tr valign='top'> <td><code>escape_backslash</code></td> <td> <p>Does the file use backslashes to escape special characters? This is more general than <code>escape_double</code> as backslashes can be used to escape the delimeter character, the quote characer, or to add special characters like <code>\n</code>.</p> </td> </tr> <tr valign='top'> <td><code>escape_double</code></td> <td> <p>Does the file escape quotes by doubling them? i.e. If this option is <code>TRUE</code>, the value <code>''''</code> represents a single quote, <code>\'</code>.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column names. </p> <p>If <code>TRUE</code>, the first row of the input will be used as the column names, and will not be included in the data frame. If <code>FALSE</code>, column names will be generated automatically: X1, X2, X3 etc. </p> <p>If <code>col_names</code> is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. </p> <p>Missing (<code>NA</code>) column names will generate a warning, and be filled in with dummy names <code>X1</code>, <code>X2</code> etc. Duplicate column names will generate a warning and be made unique with a numeric prefix.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>quoted_na</code></td> <td> <p>Should missing values inside quotes be treated as missing values (the default) or strings.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>trim_ws</code></td> <td> <p>Should leading and trailing whitespace be trimmed from each field before parsing it?</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"spec_delim"	"readr"	"Retrieve the column specification of a file."	"<p>By default the types of the first 20 columns are printed, <code>options(readr.num_columns)</code> can be used to modify this (a value of 0 turns off printing). </p>"	"<pre>spec_delim(file, delim, quote = '\'', escape_backslash = FALSE,<br />   escape_double = TRUE, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = FALSE, skip = 0, n_max = 0,<br />   guess_max = 1000, progress = interactive())<br />spec_csv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive())<br />spec_csv2(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive())<br />spec_tsv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Single character used to separate fields within a record.</p> </td> </tr> <tr valign='top'> <td><code>quote</code></td> <td> <p>Single character used to quote strings.</p> </td> </tr> <tr valign='top'> <td><code>escape_backslash</code></td> <td> <p>Does the file use backslashes to escape special characters? This is more general than <code>escape_double</code> as backslashes can be used to escape the delimeter character, the quote characer, or to add special characters like <code>\n</code>.</p> </td> </tr> <tr valign='top'> <td><code>escape_double</code></td> <td> <p>Does the file escape quotes by doubling them? i.e. If this option is <code>TRUE</code>, the value <code>''''</code> represents a single quote, <code>\'</code>.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column names. </p> <p>If <code>TRUE</code>, the first row of the input will be used as the column names, and will not be included in the data frame. If <code>FALSE</code>, column names will be generated automatically: X1, X2, X3 etc. </p> <p>If <code>col_names</code> is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. </p> <p>Missing (<code>NA</code>) column names will generate a warning, and be filled in with dummy names <code>X1</code>, <code>X2</code> etc. Duplicate column names will generate a warning and be made unique with a numeric prefix.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>quoted_na</code></td> <td> <p>Should missing values inside quotes be treated as missing values (the default) or strings.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>trim_ws</code></td> <td> <p>Should leading and trailing whitespace be trimmed from each field before parsing it?</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"spec_delim"	"readr"	"Retrieve the column specification of a file."	"<p>By default the types of the first 20 columns are printed, <code>options(readr.num_columns)</code> can be used to modify this (a value of 0 turns off printing). </p>"	"<pre>spec_delim(file, delim, quote = '\'', escape_backslash = FALSE,<br />   escape_double = TRUE, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = FALSE, skip = 0, n_max = 0,<br />   guess_max = 1000, progress = interactive())<br />spec_csv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive())<br />spec_csv2(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive())<br />spec_tsv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Single character used to separate fields within a record.</p> </td> </tr> <tr valign='top'> <td><code>quote</code></td> <td> <p>Single character used to quote strings.</p> </td> </tr> <tr valign='top'> <td><code>escape_backslash</code></td> <td> <p>Does the file use backslashes to escape special characters? This is more general than <code>escape_double</code> as backslashes can be used to escape the delimeter character, the quote characer, or to add special characters like <code>\n</code>.</p> </td> </tr> <tr valign='top'> <td><code>escape_double</code></td> <td> <p>Does the file escape quotes by doubling them? i.e. If this option is <code>TRUE</code>, the value <code>''''</code> represents a single quote, <code>\'</code>.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column names. </p> <p>If <code>TRUE</code>, the first row of the input will be used as the column names, and will not be included in the data frame. If <code>FALSE</code>, column names will be generated automatically: X1, X2, X3 etc. </p> <p>If <code>col_names</code> is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. </p> <p>Missing (<code>NA</code>) column names will generate a warning, and be filled in with dummy names <code>X1</code>, <code>X2</code> etc. Duplicate column names will generate a warning and be made unique with a numeric prefix.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>quoted_na</code></td> <td> <p>Should missing values inside quotes be treated as missing values (the default) or strings.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>trim_ws</code></td> <td> <p>Should leading and trailing whitespace be trimmed from each field before parsing it?</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"read_table"	"readr"	"Read text file where columns are separated by whitespace."	"<p>This is designed to read the type of textual data where each column is separate by one (or more) columns of space. Each line is the same length, and each field is in the same position in every line. It's similar to <code>read.table</code>, but rather parsing like a file delimited by arbitrary amounts of whitespace, it first finds empty columns and then parses like a fixed width file. <code>spec_table</code> returns the column specification rather than a data frame. </p>"	"<pre>read_table(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = 'NA', skip = 0, n_max = Inf,<br />   guess_max = min(n_max, 1000), progress = interactive())<br />spec_table(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = 'NA', skip = 0, n_max = 0,<br />   guess_max = 1000, progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column names. </p> <p>If <code>TRUE</code>, the first row of the input will be used as the column names, and will not be included in the data frame. If <code>FALSE</code>, column names will be generated automatically: X1, X2, X3 etc. </p> <p>If <code>col_names</code> is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. </p> <p>Missing (<code>NA</code>) column names will generate a warning, and be filled in with dummy names <code>X1</code>, <code>X2</code> etc. Duplicate column names will generate a warning and be made unique with a numeric prefix.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"spec_delim"	"readr"	"Retrieve the column specification of a file."	"<p>By default the types of the first 20 columns are printed, <code>options(readr.num_columns)</code> can be used to modify this (a value of 0 turns off printing). </p>"	"<pre>spec_delim(file, delim, quote = '\'', escape_backslash = FALSE,<br />   escape_double = TRUE, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = FALSE, skip = 0, n_max = 0,<br />   guess_max = 1000, progress = interactive())<br />spec_csv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive())<br />spec_csv2(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive())<br />spec_tsv(file, col_names = TRUE, col_types = NULL,<br />   locale = default_locale(), na = c('', 'NA'), quoted_na = TRUE,<br />   comment = '', trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000,<br />   progress = interactive()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>file</code></td> <td> <p>Either a path to a file, a connection, or literal data (either a single string or a raw vector). </p> <p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically uncompressed. Files starting with <code>http://</code>, <code>https://</code>, <code>ftp://</code>, or <code>ftps://</code> will be automatically downloaded. Remote gz files can also be automatically downloaded &amp; decompressed. </p> <p>Literal data is most useful for examples and tests. It must contain at least one new line to be recognised as data (instead of a path).</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Single character used to separate fields within a record.</p> </td> </tr> <tr valign='top'> <td><code>quote</code></td> <td> <p>Single character used to quote strings.</p> </td> </tr> <tr valign='top'> <td><code>escape_backslash</code></td> <td> <p>Does the file use backslashes to escape special characters? This is more general than <code>escape_double</code> as backslashes can be used to escape the delimeter character, the quote characer, or to add special characters like <code>\n</code>.</p> </td> </tr> <tr valign='top'> <td><code>escape_double</code></td> <td> <p>Does the file escape quotes by doubling them? i.e. If this option is <code>TRUE</code>, the value <code>''''</code> represents a single quote, <code>\'</code>.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column names. </p> <p>If <code>TRUE</code>, the first row of the input will be used as the column names, and will not be included in the data frame. If <code>FALSE</code>, column names will be generated automatically: X1, X2, X3 etc. </p> <p>If <code>col_names</code> is a character vector, the values will be used as the names of the columns, and the first row of the input will be read into the first row of the output data frame. </p> <p>Missing (<code>NA</code>) column names will generate a warning, and be filled in with dummy names <code>X1</code>, <code>X2</code> etc. Duplicate column names will generate a warning and be made unique with a numeric prefix.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Alternatively, you can use a compact string representation where each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or <code>_</code>/<code>-</code> to skip the column.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>quoted_na</code></td> <td> <p>Should missing values inside quotes be treated as missing values (the default) or strings.</p> </td> </tr> <tr valign='top'> <td><code>comment</code></td> <td> <p>A string used to identify comments. Any text after the comment characters will be silently ignored.</p> </td> </tr> <tr valign='top'> <td><code>trim_ws</code></td> <td> <p>Should leading and trailing whitespace be trimmed from each field before parsing it?</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of lines to skip before reading data.</p> </td> </tr> <tr valign='top'> <td><code>n_max</code></td> <td> <p>Maximum number of records to read.</p> </td> </tr> <tr valign='top'> <td><code>guess_max</code></td> <td> <p>Maximum number of records to use for guessing column types.</p> </td> </tr> <tr valign='top'> <td><code>progress</code></td> <td> <p>Display a progress bar? By default it will only display in an interactive session. The display is updated every 50,000 values and will only display if estimated reading time is 5 seconds or more.</p> </td> </tr> </table> "	FALSE
"problems"	"readr"	"Retrieve parsing problems."	"<p>Readr functions will only throw an error if parsing fails in an unrecoverable way. However, there are lots of potential problems that you might want to know about - these are stored in the <code>problems</code> attribute of the output, which you can easily access with this function. <code>stop_for_problems()</code> will throw an error if there are any parsing problems: this is useful for automated scripts where you want to throw an error as soon as you encounter a problem. </p>"	"<pre>problems(x)<br />stop_for_problems(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>An data frame (from <code>read_*</code>) or a vector (from <code>parse_*</code>).</p> </td> </tr></table> "	FALSE
"type_convert"	"readr"	"Re-convert character columns in existing data frame."	"<p>This is useful if you need to do some manual munging - you can read the columns in as character, clean it up with (e.g.) regular expressions and then let readr take another stab at parsing it. </p>"	"<pre>type_convert(df, col_types = NULL, na = c('', 'NA'), trim_ws = TRUE,<br />   locale = default_locale()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>df</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>One of <code>NULL</code>, a <code>cols</code> specification, or a string. See <code>vignette('column-types')</code> for more details. </p> <p>If <code>NULL</code>, all column types will be imputed from the first 1000 rows on the input. This is convenient (and fast), but not robust. If the imputation fails, you'll need to supply the correct types yourself. </p> <p>If a column specification created by <code>cols</code>, it must contain one column specification for each column. If you only want to read a subset of the columns, use <code>cols_only</code>. </p> <p>Unlike other functions <code>type_convert</code> does not allow character specificatinos of <code>col_types</code>.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Character vector of strings to use for missing values. Set this option to <code>character()</code> to indicate no missing values.</p> </td> </tr> <tr valign='top'> <td><code>trim_ws</code></td> <td> <p>Should leading and trailing whitespace be trimmed from each field before parsing it?</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>The locale controls defaults that vary from place to place. The default locale is US-centric (like R), but you can use <code>locale</code> to create your own locale that controls things like the default time zone, encoding, decimal mark, big mark, and day/month names.</p> </td> </tr> </table> "	FALSE
"write_delim"	"readr"	"Save a data frame to a delimited file."	"<p>This is about twice as fast as <code>write.csv</code>, and never writes row names. <code>output_column</code> is a generic method used to coerce columns to suitable output. </p>"	"<pre>write_delim(x, path, delim = ' ', na = 'NA', append = FALSE,<br />   col_names = !append)<br />write_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_excel_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_tsv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />format_csv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_tsv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_delim(x, delim, na = 'NA', append = FALSE, col_names = !append)<br />output_column(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to write to.</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Delimiter used to seperate values. Defaults to <code>' '</code>. Must be a single character.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>String used for missing values. Defaults to NA. Missing values will never be quoted; strings with the same value as <code>na</code> will always be quoted.</p> </td> </tr> <tr valign='top'> <td><code>append</code></td> <td> <p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>, will append to existing file. In both cases, if file does not exist a new file is created.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Write columns names at the top of the file?</p> </td> </tr> </table> "	FALSE
"write_delim"	"readr"	"Save a data frame to a delimited file."	"<p>This is about twice as fast as <code>write.csv</code>, and never writes row names. <code>output_column</code> is a generic method used to coerce columns to suitable output. </p>"	"<pre>write_delim(x, path, delim = ' ', na = 'NA', append = FALSE,<br />   col_names = !append)<br />write_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_excel_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_tsv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />format_csv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_tsv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_delim(x, delim, na = 'NA', append = FALSE, col_names = !append)<br />output_column(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to write to.</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Delimiter used to seperate values. Defaults to <code>' '</code>. Must be a single character.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>String used for missing values. Defaults to NA. Missing values will never be quoted; strings with the same value as <code>na</code> will always be quoted.</p> </td> </tr> <tr valign='top'> <td><code>append</code></td> <td> <p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>, will append to existing file. In both cases, if file does not exist a new file is created.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Write columns names at the top of the file?</p> </td> </tr> </table> "	FALSE
"write_delim"	"readr"	"Save a data frame to a delimited file."	"<p>This is about twice as fast as <code>write.csv</code>, and never writes row names. <code>output_column</code> is a generic method used to coerce columns to suitable output. </p>"	"<pre>write_delim(x, path, delim = ' ', na = 'NA', append = FALSE,<br />   col_names = !append)<br />write_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_excel_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_tsv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />format_csv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_tsv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_delim(x, delim, na = 'NA', append = FALSE, col_names = !append)<br />output_column(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to write to.</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Delimiter used to seperate values. Defaults to <code>' '</code>. Must be a single character.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>String used for missing values. Defaults to NA. Missing values will never be quoted; strings with the same value as <code>na</code> will always be quoted.</p> </td> </tr> <tr valign='top'> <td><code>append</code></td> <td> <p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>, will append to existing file. In both cases, if file does not exist a new file is created.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Write columns names at the top of the file?</p> </td> </tr> </table> "	FALSE
"write_lines"	"readr"	"Write lines/ a file"	"<p><code>write_lines</code> takes a character vector, appending a new line after entry. <code>write_file</code> takes a single string, or a raw vector, and writes it exactly as is. </p>"	"<pre>write_lines(x, path, na = 'NA', append = FALSE)<br />write_file(x, path, append = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to write to.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>String used for missing values. Defaults to NA. Missing values will never be quoted; strings with the same value as <code>na</code> will always be quoted.</p> </td> </tr> <tr valign='top'> <td><code>append</code></td> <td> <p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>, will append to existing file. In both cases, if file does not exist a new file is created.</p> </td> </tr> </table> "	FALSE
"write_lines"	"readr"	"Write lines/ a file"	"<p><code>write_lines</code> takes a character vector, appending a new line after entry. <code>write_file</code> takes a single string, or a raw vector, and writes it exactly as is. </p>"	"<pre>write_lines(x, path, na = 'NA', append = FALSE)<br />write_file(x, path, append = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to write to.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>String used for missing values. Defaults to NA. Missing values will never be quoted; strings with the same value as <code>na</code> will always be quoted.</p> </td> </tr> <tr valign='top'> <td><code>append</code></td> <td> <p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>, will append to existing file. In both cases, if file does not exist a new file is created.</p> </td> </tr> </table> "	FALSE
"write_rds"	"readr"	"Write a single R object to file"	"<p>Consistent wrapper around <code>saveRDS</code>. <code>write_rds</code> does not compress by default as space is generally cheaper than time. </p>"	"<pre>write_rds(x, path, compress = c('none', 'gz', 'bz2', 'xz'), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>R object to write to serialise.</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to write to.</p> </td> </tr> <tr valign='top'> <td><code>compress</code></td> <td> <p>Compression method to use: 'none', 'gz' ,'bz', or 'xz'.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments to connection function. For example, control the space-time trade-off of different compression methods with <code>compression</code>. See <code>connections</code> for more details.</p> </td> </tr> </table> "	FALSE
"write_delim"	"readr"	"Save a data frame to a delimited file."	"<p>This is about twice as fast as <code>write.csv</code>, and never writes row names. <code>output_column</code> is a generic method used to coerce columns to suitable output. </p>"	"<pre>write_delim(x, path, delim = ' ', na = 'NA', append = FALSE,<br />   col_names = !append)<br />write_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_excel_csv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />write_tsv(x, path, na = 'NA', append = FALSE, col_names = !append)<br />format_csv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_tsv(x, na = 'NA', append = FALSE, col_names = !append)<br />format_delim(x, delim, na = 'NA', append = FALSE, col_names = !append)<br />output_column(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame to write to disk</p> </td> </tr> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to write to.</p> </td> </tr> <tr valign='top'> <td><code>delim</code></td> <td> <p>Delimiter used to seperate values. Defaults to <code>' '</code>. Must be a single character.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>String used for missing values. Defaults to NA. Missing values will never be quoted; strings with the same value as <code>na</code> will always be quoted.</p> </td> </tr> <tr valign='top'> <td><code>append</code></td> <td> <p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>, will append to existing file. In both cases, if file does not exist a new file is created.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Write columns names at the top of the file?</p> </td> </tr> </table> "	FALSE
"excel_sheets"	"readxl"	"List all sheets in an excel spreadsheet."	"<p>List all sheets in an excel spreadsheet. </p>"	"<pre>excel_sheets(path) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>path</code></td> <td> <p>Path to the xls/xlsx file</p> </td> </tr></table> "	FALSE
"read_excel"	"readxl"	"Read xls and xlsx files."	"<p>Read xls and xlsx files. </p>"	"<pre>read_excel(path, sheet = 1, col_names = TRUE, col_types = NULL, na = '',<br />   skip = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>path</code></td> <td> <p>Path to the xls/xlsx file</p> </td> </tr> <tr valign='top'> <td><code>sheet</code></td> <td> <p>Sheet to read. Either a string (the name of a sheet), or an integer (the position of the sheet). Defaults to the first sheet.</p> </td> </tr> <tr valign='top'> <td><code>col_names</code></td> <td> <p>Either <code>TRUE</code> to use the first row as column names, <code>FALSE</code> to number columns sequentially from <code>X1</code> to <code>Xn</code>, or a character vector giving a name for each column.</p> </td> </tr> <tr valign='top'> <td><code>col_types</code></td> <td> <p>Either <code>NULL</code> to guess from the spreadsheet or a character vector containing 'blank', 'numeric', 'date' or 'text'.</p> </td> </tr> <tr valign='top'> <td><code>na</code></td> <td> <p>Missing value. By default readxl converts blank cells to missing data. Set this value if you have used a sentinel value for missing values.</p> </td> </tr> <tr valign='top'> <td><code>skip</code></td> <td> <p>Number of rows to skip before reading any data.</p> </td> </tr> </table> "	FALSE
"modifiers"	"stringr"	"Control matching behaviour with modifier functions."	"<dl> <dt>fixed</dt> <dd> <p>Compare literal bytes in the string. This is very fast, but not usually what you want for non-ASCII character sets.</p> </dd> <dt>coll</dt> <dd> <p>Compare strings respecting standard collation rules.</p> </dd> <dt>regex</dt> <dd> <p>The default. Uses ICU regular expressions.</p> </dd> <dt>boundary</dt> <dd> <p>Match boundaries between things.</p> </dd> </dl> "	"<pre>fixed(pattern, ignore_case = FALSE)<br />coll(pattern, ignore_case = FALSE, locale = NULL, ...)<br />regex(pattern, ignore_case = FALSE, multiline = FALSE, comments = FALSE,<br />   dotall = FALSE, ...)<br />boundary(type = c('character', 'line_break', 'sentence', 'word'),<br />   skip_word_none = NA, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to modify behaviour.</p> </td> </tr> <tr valign='top'> <td><code>ignore_case</code></td> <td> <p>Should case differences be ignored in the match?</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>Locale to use for comparisons. See <code>stri_locale_list()</code> for all possible options.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other less frequently used arguments passed on to <code>stri_opts_collator</code>, <code>stri_opts_regex</code>, or <code>stri_opts_brkiter</code></p> </td> </tr> <tr valign='top'> <td><code>multiline</code></td> <td> <p>If <code>TRUE</code>, <code>$</code> and <code>^</code> match the beginning and end of each line. If <code>FALSE</code>, the default, only match the start and end of the input.</p> </td> </tr> <tr valign='top'> <td><code>comments</code></td> <td> <p>If <code>TRUE</code>, white space and comments beginning with <code>#</code> are ignored. Escape literal spaces with <code>\ </code>.</p> </td> </tr> <tr valign='top'> <td><code>dotall</code></td> <td> <p>If <code>TRUE</code>, <code>.</code> will also match line terminators.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>Boundary type to detect.</p> </td> </tr> <tr valign='top'> <td><code>skip_word_none</code></td> <td> <p>Ignore 'words' that don't contain any characters or numbers - i.e. punctuation. Default <code>NA</code> will skip such 'words' only when splitting on <code>word</code> boundaries.</p> </td> </tr> </table> "	FALSE
"case"	"stringr"	"Convert case of a string."	"<p>Convert case of a string. </p>"	"<pre>str_to_upper(string, locale = '')<br />str_to_lower(string, locale = '')<br />str_to_title(string, locale = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>String to modify</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>Locale to use for translations.</p> </td> </tr> </table> "	FALSE
"modifiers"	"stringr"	"Control matching behaviour with modifier functions."	"<dl> <dt>fixed</dt> <dd> <p>Compare literal bytes in the string. This is very fast, but not usually what you want for non-ASCII character sets.</p> </dd> <dt>coll</dt> <dd> <p>Compare strings respecting standard collation rules.</p> </dd> <dt>regex</dt> <dd> <p>The default. Uses ICU regular expressions.</p> </dd> <dt>boundary</dt> <dd> <p>Match boundaries between things.</p> </dd> </dl> "	"<pre>fixed(pattern, ignore_case = FALSE)<br />coll(pattern, ignore_case = FALSE, locale = NULL, ...)<br />regex(pattern, ignore_case = FALSE, multiline = FALSE, comments = FALSE,<br />   dotall = FALSE, ...)<br />boundary(type = c('character', 'line_break', 'sentence', 'word'),<br />   skip_word_none = NA, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to modify behaviour.</p> </td> </tr> <tr valign='top'> <td><code>ignore_case</code></td> <td> <p>Should case differences be ignored in the match?</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>Locale to use for comparisons. See <code>stri_locale_list()</code> for all possible options.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other less frequently used arguments passed on to <code>stri_opts_collator</code>, <code>stri_opts_regex</code>, or <code>stri_opts_brkiter</code></p> </td> </tr> <tr valign='top'> <td><code>multiline</code></td> <td> <p>If <code>TRUE</code>, <code>$</code> and <code>^</code> match the beginning and end of each line. If <code>FALSE</code>, the default, only match the start and end of the input.</p> </td> </tr> <tr valign='top'> <td><code>comments</code></td> <td> <p>If <code>TRUE</code>, white space and comments beginning with <code>#</code> are ignored. Escape literal spaces with <code>\ </code>.</p> </td> </tr> <tr valign='top'> <td><code>dotall</code></td> <td> <p>If <code>TRUE</code>, <code>.</code> will also match line terminators.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>Boundary type to detect.</p> </td> </tr> <tr valign='top'> <td><code>skip_word_none</code></td> <td> <p>Ignore 'words' that don't contain any characters or numbers - i.e. punctuation. Default <code>NA</code> will skip such 'words' only when splitting on <code>word</code> boundaries.</p> </td> </tr> </table> "	FALSE
"modifiers"	"stringr"	"Control matching behaviour with modifier functions."	"<dl> <dt>fixed</dt> <dd> <p>Compare literal bytes in the string. This is very fast, but not usually what you want for non-ASCII character sets.</p> </dd> <dt>coll</dt> <dd> <p>Compare strings respecting standard collation rules.</p> </dd> <dt>regex</dt> <dd> <p>The default. Uses ICU regular expressions.</p> </dd> <dt>boundary</dt> <dd> <p>Match boundaries between things.</p> </dd> </dl> "	"<pre>fixed(pattern, ignore_case = FALSE)<br />coll(pattern, ignore_case = FALSE, locale = NULL, ...)<br />regex(pattern, ignore_case = FALSE, multiline = FALSE, comments = FALSE,<br />   dotall = FALSE, ...)<br />boundary(type = c('character', 'line_break', 'sentence', 'word'),<br />   skip_word_none = NA, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to modify behaviour.</p> </td> </tr> <tr valign='top'> <td><code>ignore_case</code></td> <td> <p>Should case differences be ignored in the match?</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>Locale to use for comparisons. See <code>stri_locale_list()</code> for all possible options.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other less frequently used arguments passed on to <code>stri_opts_collator</code>, <code>stri_opts_regex</code>, or <code>stri_opts_brkiter</code></p> </td> </tr> <tr valign='top'> <td><code>multiline</code></td> <td> <p>If <code>TRUE</code>, <code>$</code> and <code>^</code> match the beginning and end of each line. If <code>FALSE</code>, the default, only match the start and end of the input.</p> </td> </tr> <tr valign='top'> <td><code>comments</code></td> <td> <p>If <code>TRUE</code>, white space and comments beginning with <code>#</code> are ignored. Escape literal spaces with <code>\ </code>.</p> </td> </tr> <tr valign='top'> <td><code>dotall</code></td> <td> <p>If <code>TRUE</code>, <code>.</code> will also match line terminators.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>Boundary type to detect.</p> </td> </tr> <tr valign='top'> <td><code>skip_word_none</code></td> <td> <p>Ignore 'words' that don't contain any characters or numbers - i.e. punctuation. Default <code>NA</code> will skip such 'words' only when splitting on <code>word</code> boundaries.</p> </td> </tr> </table> "	FALSE
"stringr-data"	"stringr"	"Sample character vectors for practicing string manipulations."	"<p><code>fruit</code> and <code>word</code> come from the <code>rcorpora</code> package written by Gabor Csardi; the data was collected by Darius Kazemi and made available at <a href='https://github.com/dariusk/corpora'>https://github.com/dariusk/corpora</a>. <code>sentences</code> is a collection of 'Harvard sentences' used for standardised testing of voice. </p>"	"<pre>sentences<br />fruit<br />words </pre>"	NA	FALSE
"invert_match"	"stringr"	"Switch location of matches to location of non-matches."	"<p>Invert a matrix of match locations to match the opposite of what was previously matched. </p>"	"<pre>invert_match(loc) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>loc</code></td> <td> <p>matrix of match locations, as from <code>str_locate_all</code></p> </td> </tr></table> "	FALSE
"modifiers"	"stringr"	"Control matching behaviour with modifier functions."	"<dl> <dt>fixed</dt> <dd> <p>Compare literal bytes in the string. This is very fast, but not usually what you want for non-ASCII character sets.</p> </dd> <dt>coll</dt> <dd> <p>Compare strings respecting standard collation rules.</p> </dd> <dt>regex</dt> <dd> <p>The default. Uses ICU regular expressions.</p> </dd> <dt>boundary</dt> <dd> <p>Match boundaries between things.</p> </dd> </dl> "	"<pre>fixed(pattern, ignore_case = FALSE)<br />coll(pattern, ignore_case = FALSE, locale = NULL, ...)<br />regex(pattern, ignore_case = FALSE, multiline = FALSE, comments = FALSE,<br />   dotall = FALSE, ...)<br />boundary(type = c('character', 'line_break', 'sentence', 'word'),<br />   skip_word_none = NA, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to modify behaviour.</p> </td> </tr> <tr valign='top'> <td><code>ignore_case</code></td> <td> <p>Should case differences be ignored in the match?</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>Locale to use for comparisons. See <code>stri_locale_list()</code> for all possible options.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other less frequently used arguments passed on to <code>stri_opts_collator</code>, <code>stri_opts_regex</code>, or <code>stri_opts_brkiter</code></p> </td> </tr> <tr valign='top'> <td><code>multiline</code></td> <td> <p>If <code>TRUE</code>, <code>$</code> and <code>^</code> match the beginning and end of each line. If <code>FALSE</code>, the default, only match the start and end of the input.</p> </td> </tr> <tr valign='top'> <td><code>comments</code></td> <td> <p>If <code>TRUE</code>, white space and comments beginning with <code>#</code> are ignored. Escape literal spaces with <code>\ </code>.</p> </td> </tr> <tr valign='top'> <td><code>dotall</code></td> <td> <p>If <code>TRUE</code>, <code>.</code> will also match line terminators.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>Boundary type to detect.</p> </td> </tr> <tr valign='top'> <td><code>skip_word_none</code></td> <td> <p>Ignore 'words' that don't contain any characters or numbers - i.e. punctuation. Default <code>NA</code> will skip such 'words' only when splitting on <code>word</code> boundaries.</p> </td> </tr> </table> "	FALSE
"modifiers"	"stringr"	"Control matching behaviour with modifier functions."	"<dl> <dt>fixed</dt> <dd> <p>Compare literal bytes in the string. This is very fast, but not usually what you want for non-ASCII character sets.</p> </dd> <dt>coll</dt> <dd> <p>Compare strings respecting standard collation rules.</p> </dd> <dt>regex</dt> <dd> <p>The default. Uses ICU regular expressions.</p> </dd> <dt>boundary</dt> <dd> <p>Match boundaries between things.</p> </dd> </dl> "	"<pre>fixed(pattern, ignore_case = FALSE)<br />coll(pattern, ignore_case = FALSE, locale = NULL, ...)<br />regex(pattern, ignore_case = FALSE, multiline = FALSE, comments = FALSE,<br />   dotall = FALSE, ...)<br />boundary(type = c('character', 'line_break', 'sentence', 'word'),<br />   skip_word_none = NA, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to modify behaviour.</p> </td> </tr> <tr valign='top'> <td><code>ignore_case</code></td> <td> <p>Should case differences be ignored in the match?</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>Locale to use for comparisons. See <code>stri_locale_list()</code> for all possible options.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other less frequently used arguments passed on to <code>stri_opts_collator</code>, <code>stri_opts_regex</code>, or <code>stri_opts_brkiter</code></p> </td> </tr> <tr valign='top'> <td><code>multiline</code></td> <td> <p>If <code>TRUE</code>, <code>$</code> and <code>^</code> match the beginning and end of each line. If <code>FALSE</code>, the default, only match the start and end of the input.</p> </td> </tr> <tr valign='top'> <td><code>comments</code></td> <td> <p>If <code>TRUE</code>, white space and comments beginning with <code>#</code> are ignored. Escape literal spaces with <code>\ </code>.</p> </td> </tr> <tr valign='top'> <td><code>dotall</code></td> <td> <p>If <code>TRUE</code>, <code>.</code> will also match line terminators.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>Boundary type to detect.</p> </td> </tr> <tr valign='top'> <td><code>skip_word_none</code></td> <td> <p>Ignore 'words' that don't contain any characters or numbers - i.e. punctuation. Default <code>NA</code> will skip such 'words' only when splitting on <code>word</code> boundaries.</p> </td> </tr> </table> "	FALSE
"stringr-data"	"stringr"	"Sample character vectors for practicing string manipulations."	"<p><code>fruit</code> and <code>word</code> come from the <code>rcorpora</code> package written by Gabor Csardi; the data was collected by Darius Kazemi and made available at <a href='https://github.com/dariusk/corpora'>https://github.com/dariusk/corpora</a>. <code>sentences</code> is a collection of 'Harvard sentences' used for standardised testing of voice. </p>"	"<pre>sentences<br />fruit<br />words </pre>"	NA	FALSE
"stringr-data"	"stringr"	"Sample character vectors for practicing string manipulations."	"<p><code>fruit</code> and <code>word</code> come from the <code>rcorpora</code> package written by Gabor Csardi; the data was collected by Darius Kazemi and made available at <a href='https://github.com/dariusk/corpora'>https://github.com/dariusk/corpora</a>. <code>sentences</code> is a collection of 'Harvard sentences' used for standardised testing of voice. </p>"	"<pre>sentences<br />fruit<br />words </pre>"	NA	FALSE
"str_c"	"stringr"	"Join multiple strings into a single string."	"<p>To understand how <code>str_c</code> works, you need to imagine that you are building up a matrix of strings. Each input argument forms a column, and is expanded to the length of the longest argument, using the usual recyling rules.  The <code>sep</code> string is inserted between each column. If collapse is <code>NULL</code> each row is collapsed into a single string. If non-<code>NULL</code> that string is inserted at the end of each row, and the entire matrix collapsed to a single string. </p>"	"<pre>str_c(..., sep = '', collapse = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>One or more character vectors. Zero length arguments are removed. Short arguments are recycled to the length of the longest. </p> <p>Like most other R functions, missing values are 'infectious': whenever a missing value is combined with another string the result will always be missing. Use <code>str_replace_na</code> to convert <code>NA</code> to <code>'NA'</code></p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>String to insert between input vectors.</p> </td> </tr> <tr valign='top'> <td><code>collapse</code></td> <td> <p>Optional string used to combine input vectors into single string.</p> </td> </tr> </table> "	FALSE
"str_conv"	"stringr"	"Specify the encoding of a string."	"<p>This is a convenient way to override the current encoding of a string. </p>"	"<pre>str_conv(string, encoding) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>String to re-encode.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>Name of encoding. See <code>stri_enc_list</code> for a complete list.</p> </td> </tr> </table> "	FALSE
"str_count"	"stringr"	"Count the number of matches in a string."	"<p>Vectorised over <code>string</code> and <code>pattern</code>. </p>"	"<pre>str_count(string, pattern = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for. </p> <p>The default interpretation is a regular expression, as described in stringi-search-regex. Control options with <code>regex()</code>. </p> <p>Match a fixed string (i.e. by comparing only bytes), using <code>fixed(x)</code>. This is fast, but approximate. Generally, for matching human text, you'll want <code>coll(x)</code> which respects character matching rules for the specified locale. </p> <p>Match character, word, line and sentence boundaries with <code>boundary()</code>. An empty pattern, '', is equivalent to <code>boundary('character')</code>.</p> </td> </tr> </table> "	FALSE
"str_detect"	"stringr"	"Detect the presence or absence of a pattern in a string."	"<p>Vectorised over <code>string</code> and <code>pattern</code>. </p>"	"<pre>str_detect(string, pattern) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for. </p> <p>The default interpretation is a regular expression, as described in stringi-search-regex. Control options with <code>regex()</code>. </p> <p>Match a fixed string (i.e. by comparing only bytes), using <code>fixed(x)</code>. This is fast, but approximate. Generally, for matching human text, you'll want <code>coll(x)</code> which respects character matching rules for the specified locale. </p> <p>Match character, word, line and sentence boundaries with <code>boundary()</code>. An empty pattern, '', is equivalent to <code>boundary('character')</code>.</p> </td> </tr> </table> "	FALSE
"str_dup"	"stringr"	"Duplicate and concatenate strings within a character vector."	"<p>Vectorised over <code>string</code> and <code>times</code>. </p>"	"<pre>str_dup(string, times) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input character vector.</p> </td> </tr> <tr valign='top'> <td><code>times</code></td> <td> <p>Number of times to duplicate each string.</p> </td> </tr> </table> "	FALSE
"str_extract"	"stringr"	"Extract matching patterns from a string."	"<p>Vectorised over <code>string</code> and <code>pattern</code>. </p>"	"<pre>str_extract(string, pattern)<br />str_extract_all(string, pattern, simplify = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for. </p> <p>The default interpretation is a regular expression, as described in stringi-search-regex. Control options with <code>regex()</code>. </p> <p>Match a fixed string (i.e. by comparing only bytes), using <code>fixed(x)</code>. This is fast, but approximate. Generally, for matching human text, you'll want <code>coll(x)</code> which respects character matching rules for the specified locale. </p> <p>Match character, word, line and sentence boundaries with <code>boundary()</code>. An empty pattern, '', is equivalent to <code>boundary('character')</code>.</p> </td> </tr> <tr valign='top'> <td><code>simplify</code></td> <td> <p>If <code>FALSE</code>, the default, returns a list of character vectors. If <code>TRUE</code> returns a character matrix.</p> </td> </tr> </table> "	FALSE
"str_extract"	"stringr"	"Extract matching patterns from a string."	"<p>Vectorised over <code>string</code> and <code>pattern</code>. </p>"	"<pre>str_extract(string, pattern)<br />str_extract_all(string, pattern, simplify = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for. </p> <p>The default interpretation is a regular expression, as described in stringi-search-regex. Control options with <code>regex()</code>. </p> <p>Match a fixed string (i.e. by comparing only bytes), using <code>fixed(x)</code>. This is fast, but approximate. Generally, for matching human text, you'll want <code>coll(x)</code> which respects character matching rules for the specified locale. </p> <p>Match character, word, line and sentence boundaries with <code>boundary()</code>. An empty pattern, '', is equivalent to <code>boundary('character')</code>.</p> </td> </tr> <tr valign='top'> <td><code>simplify</code></td> <td> <p>If <code>FALSE</code>, the default, returns a list of character vectors. If <code>TRUE</code> returns a character matrix.</p> </td> </tr> </table> "	FALSE
"str_interp"	"stringr"	"String interpolation."	"<p>String interpolation is a useful way of specifying a character string which depends on values in a certain environment. It allows for string creation which is easier to read and write when compared to using e.g. <code>paste</code> or <code>sprintf</code>. The (template) string can include expression placeholders of the form <code>${expression}</code> or <code>$[format]{expression}</code>, where expressions are valid R expressions that can be evaluated in the given environment, and <code>format</code> is a format specification valid for use with <code>sprintf</code>. </p>"	"<pre>str_interp(string, env = parent.frame()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>A template character string. This function is not vectorised: a character vector will be collapsed into a single string.</p> </td> </tr> <tr valign='top'> <td><code>env</code></td> <td> <p>The environment in which to evaluate the expressions.</p> </td> </tr> </table> "	FALSE
"str_c"	"stringr"	"Join multiple strings into a single string."	"<p>To understand how <code>str_c</code> works, you need to imagine that you are building up a matrix of strings. Each input argument forms a column, and is expanded to the length of the longest argument, using the usual recyling rules.  The <code>sep</code> string is inserted between each column. If collapse is <code>NULL</code> each row is collapsed into a single string. If non-<code>NULL</code> that string is inserted at the end of each row, and the entire matrix collapsed to a single string. </p>"	"<pre>str_c(..., sep = '', collapse = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>One or more character vectors. Zero length arguments are removed. Short arguments are recycled to the length of the longest. </p> <p>Like most other R functions, missing values are 'infectious': whenever a missing value is combined with another string the result will always be missing. Use <code>str_replace_na</code> to convert <code>NA</code> to <code>'NA'</code></p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>String to insert between input vectors.</p> </td> </tr> <tr valign='top'> <td><code>collapse</code></td> <td> <p>Optional string used to combine input vectors into single string.</p> </td> </tr> </table> "	FALSE
"str_length"	"stringr"	"The length of a string."	"<p>Technically this returns the number of 'code points', in a string. One code point usually corresponds to one character, but not always. For example, an u with a umlaut might be represented as a single character or as the combination a u and an umlaut. </p>"	"<pre>str_length(string) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr></table> "	FALSE
"str_locate"	"stringr"	"Locate the position of patterns in a string."	"<p>Vectorised over <code>string</code> and <code>pattern</code>. If the match is of length 0, (e.g. from a special match like <code>$</code>) end will be one character less than start. </p>"	"<pre>str_locate(string, pattern)<br />str_locate_all(string, pattern) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for. </p> <p>The default interpretation is a regular expression, as described in stringi-search-regex. Control options with <code>regex()</code>. </p> <p>Match a fixed string (i.e. by comparing only bytes), using <code>fixed(x)</code>. This is fast, but approximate. Generally, for matching human text, you'll want <code>coll(x)</code> which respects character matching rules for the specified locale. </p> <p>Match character, word, line and sentence boundaries with <code>boundary()</code>. An empty pattern, '', is equivalent to <code>boundary('character')</code>.</p> </td> </tr> </table> "	FALSE
"str_locate"	"stringr"	"Locate the position of patterns in a string."	"<p>Vectorised over <code>string</code> and <code>pattern</code>. If the match is of length 0, (e.g. from a special match like <code>$</code>) end will be one character less than start. </p>"	"<pre>str_locate(string, pattern)<br />str_locate_all(string, pattern) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for. </p> <p>The default interpretation is a regular expression, as described in stringi-search-regex. Control options with <code>regex()</code>. </p> <p>Match a fixed string (i.e. by comparing only bytes), using <code>fixed(x)</code>. This is fast, but approximate. Generally, for matching human text, you'll want <code>coll(x)</code> which respects character matching rules for the specified locale. </p> <p>Match character, word, line and sentence boundaries with <code>boundary()</code>. An empty pattern, '', is equivalent to <code>boundary('character')</code>.</p> </td> </tr> </table> "	FALSE
"str_match"	"stringr"	"Extract matched groups from a string."	"<p>Vectorised over <code>string</code> and <code>pattern</code>. </p>"	"<pre>str_match(string, pattern)<br />str_match_all(string, pattern) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for, as defined by an ICU regular expression. See stringi-search-regex for more details.</p> </td> </tr> </table> "	FALSE
"str_match"	"stringr"	"Extract matched groups from a string."	"<p>Vectorised over <code>string</code> and <code>pattern</code>. </p>"	"<pre>str_match(string, pattern)<br />str_match_all(string, pattern) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for, as defined by an ICU regular expression. See stringi-search-regex for more details.</p> </td> </tr> </table> "	FALSE
"str_order"	"stringr"	"Order or sort a character vector."	"<p>Order or sort a character vector. </p>"	"<pre>str_order(x, decreasing = FALSE, na_last = TRUE, locale = '', ...)<br />str_sort(x, decreasing = FALSE, na_last = TRUE, locale = '', ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector to sort.</p> </td> </tr> <tr valign='top'> <td><code>decreasing</code></td> <td> <p>A boolean. If <code>FALSE</code>, the default, sorts from lowest to highest; if <code>TRUE</code> sorts from highest to lowest.</p> </td> </tr> <tr valign='top'> <td><code>na_last</code></td> <td> <p>Where should <code>NA</code> go? <code>TRUE</code> at the end, <code>FALSE</code> at the beginning, <code>NA</code> dropped.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>In which locale should the sorting occur? Defaults to the current locale.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other options used to control sorting order. Passed on to <code>stri_opts_collator</code>.</p> </td> </tr> </table> "	FALSE
"str_pad"	"stringr"	"Pad a string."	"<p>Vectorised over <code>string</code>, <code>width</code> and <code>pad</code>. </p>"	"<pre>str_pad(string, width, side = c('left', 'right', 'both'), pad = ' ') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>A character vector.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Minimum width of padded strings.</p> </td> </tr> <tr valign='top'> <td><code>side</code></td> <td> <p>Side on which padding character is added (left, right or both).</p> </td> </tr> <tr valign='top'> <td><code>pad</code></td> <td> <p>Single padding character (default is a space).</p> </td> </tr> </table> "	FALSE
"str_replace"	"stringr"	"Replace matched patterns in a string."	"<p>Vectorised over <code>string</code>, <code>pattern</code> and <code>replacement</code>. </p>"	"<pre>str_replace(string, pattern, replacement)<br />str_replace_all(string, pattern, replacement) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern, replacement</code></td> <td> <p>Supply separate pattern and replacement strings to vectorise over the patterns. References of the form <code>\1</code>, <code>\2</code> will be replaced with the contents of the respective matched group (created by <code>()</code>) within the pattern. </p> <p>For <code>str_replace_all</code> only, you can perform multiple patterns and replacements to each string, by passing a named character to <code>pattern</code>.</p> </td> </tr> </table> "	FALSE
"str_replace"	"stringr"	"Replace matched patterns in a string."	"<p>Vectorised over <code>string</code>, <code>pattern</code> and <code>replacement</code>. </p>"	"<pre>str_replace(string, pattern, replacement)<br />str_replace_all(string, pattern, replacement) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern, replacement</code></td> <td> <p>Supply separate pattern and replacement strings to vectorise over the patterns. References of the form <code>\1</code>, <code>\2</code> will be replaced with the contents of the respective matched group (created by <code>()</code>) within the pattern. </p> <p>For <code>str_replace_all</code> only, you can perform multiple patterns and replacements to each string, by passing a named character to <code>pattern</code>.</p> </td> </tr> </table> "	FALSE
"str_replace_na"	"stringr"	"Turn NA into \"NA\""	"<p>Turn NA into 'NA' </p>"	"<pre>str_replace_na(string, replacement = 'NA') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>replacement</code></td> <td> <p>Supply separate pattern and replacement strings to vectorise over the patterns. References of the form <code>\1</code>, <code>\2</code> will be replaced with the contents of the respective matched group (created by <code>()</code>) within the pattern. </p> <p>For <code>str_replace_all</code> only, you can perform multiple patterns and replacements to each string, by passing a named character to <code>pattern</code>.</p> </td> </tr> </table> "	FALSE
"str_order"	"stringr"	"Order or sort a character vector."	"<p>Order or sort a character vector. </p>"	"<pre>str_order(x, decreasing = FALSE, na_last = TRUE, locale = '', ...)<br />str_sort(x, decreasing = FALSE, na_last = TRUE, locale = '', ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector to sort.</p> </td> </tr> <tr valign='top'> <td><code>decreasing</code></td> <td> <p>A boolean. If <code>FALSE</code>, the default, sorts from lowest to highest; if <code>TRUE</code> sorts from highest to lowest.</p> </td> </tr> <tr valign='top'> <td><code>na_last</code></td> <td> <p>Where should <code>NA</code> go? <code>TRUE</code> at the end, <code>FALSE</code> at the beginning, <code>NA</code> dropped.</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>In which locale should the sorting occur? Defaults to the current locale.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other options used to control sorting order. Passed on to <code>stri_opts_collator</code>.</p> </td> </tr> </table> "	FALSE
"str_split"	"stringr"	"Split up a string into pieces."	"<p>Vectorised over <code>string</code> and <code>pattern</code>. </p>"	"<pre>str_split(string, pattern, n = Inf, simplify = FALSE)<br />str_split_fixed(string, pattern, n) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for. </p> <p>The default interpretation is a regular expression, as described in stringi-search-regex. Control options with <code>regex()</code>. </p> <p>Match a fixed string (i.e. by comparing only bytes), using <code>fixed(x)</code>. This is fast, but approximate. Generally, for matching human text, you'll want <code>coll(x)</code> which respects character matching rules for the specified locale. </p> <p>Match character, word, line and sentence boundaries with <code>boundary()</code>. An empty pattern, '', is equivalent to <code>boundary('character')</code>.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of pieces to return.  Default (Inf) uses all possible split positions. </p> <p>For <code>str_split_fixed</code>, if n is greater than the number of pieces, the result will be padded with empty strings.</p> </td> </tr> <tr valign='top'> <td><code>simplify</code></td> <td> <p>If <code>FALSE</code>, the default, returns a list of character vectors. If <code>TRUE</code> returns a character matrix.</p> </td> </tr> </table> "	FALSE
"str_split"	"stringr"	"Split up a string into pieces."	"<p>Vectorised over <code>string</code> and <code>pattern</code>. </p>"	"<pre>str_split(string, pattern, n = Inf, simplify = FALSE)<br />str_split_fixed(string, pattern, n) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for. </p> <p>The default interpretation is a regular expression, as described in stringi-search-regex. Control options with <code>regex()</code>. </p> <p>Match a fixed string (i.e. by comparing only bytes), using <code>fixed(x)</code>. This is fast, but approximate. Generally, for matching human text, you'll want <code>coll(x)</code> which respects character matching rules for the specified locale. </p> <p>Match character, word, line and sentence boundaries with <code>boundary()</code>. An empty pattern, '', is equivalent to <code>boundary('character')</code>.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>number of pieces to return.  Default (Inf) uses all possible split positions. </p> <p>For <code>str_split_fixed</code>, if n is greater than the number of pieces, the result will be padded with empty strings.</p> </td> </tr> <tr valign='top'> <td><code>simplify</code></td> <td> <p>If <code>FALSE</code>, the default, returns a list of character vectors. If <code>TRUE</code> returns a character matrix.</p> </td> </tr> </table> "	FALSE
"str_sub"	"stringr"	"Extract and replace substrings from a character vector."	"<p><code>str_sub</code> will recycle all arguments to be the same length as the longest argument. If any arguments are of length 0, the output will be a zero length character vector. </p>"	"<pre>str_sub(string, start = 1L, end = -1L)<br />str_sub(string, start = 1L, end = -1L) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>input character vector.</p> </td> </tr> <tr valign='top'> <td><code>start, end</code></td> <td> <p>Two integer vectors. <code>start</code> gives the position of the first character (defaults to first), <code>end</code> gives the position of the last (defaults to last character). Alternatively, pass a two-column matrix to <code>start</code>. </p> <p>Negative values count backwards from the last character.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>replacement string</p> </td> </tr> </table> "	FALSE
"str_sub"	"stringr"	"Extract and replace substrings from a character vector."	"<p><code>str_sub</code> will recycle all arguments to be the same length as the longest argument. If any arguments are of length 0, the output will be a zero length character vector. </p>"	"<pre>str_sub(string, start = 1L, end = -1L)<br />str_sub(string, start = 1L, end = -1L) &lt;- value </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>input character vector.</p> </td> </tr> <tr valign='top'> <td><code>start, end</code></td> <td> <p>Two integer vectors. <code>start</code> gives the position of the first character (defaults to first), <code>end</code> gives the position of the last (defaults to last character). Alternatively, pass a two-column matrix to <code>start</code>. </p> <p>Negative values count backwards from the last character.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>replacement string</p> </td> </tr> </table> "	FALSE
"str_subset"	"stringr"	"Keep strings matching a pattern."	"<p>This is a convenient wrapper around <code>x[str_detect(x, pattern)]</code>. Vectorised over <code>string</code> and <code>pattern</code> </p>"	"<pre>str_subset(string, pattern) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for. </p> <p>The default interpretation is a regular expression, as described in stringi-search-regex. Control options with <code>regex()</code>. </p> <p>Match a fixed string (i.e. by comparing only bytes), using <code>fixed(x)</code>. This is fast, but approximate. Generally, for matching human text, you'll want <code>coll(x)</code> which respects character matching rules for the specified locale. </p> <p>Match character, word, line and sentence boundaries with <code>boundary()</code>. An empty pattern, '', is equivalent to <code>boundary('character')</code>.</p> </td> </tr> </table> "	FALSE
"case"	"stringr"	"Convert case of a string."	"<p>Convert case of a string. </p>"	"<pre>str_to_upper(string, locale = '')<br />str_to_lower(string, locale = '')<br />str_to_title(string, locale = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>String to modify</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>Locale to use for translations.</p> </td> </tr> </table> "	FALSE
"case"	"stringr"	"Convert case of a string."	"<p>Convert case of a string. </p>"	"<pre>str_to_upper(string, locale = '')<br />str_to_lower(string, locale = '')<br />str_to_title(string, locale = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>String to modify</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>Locale to use for translations.</p> </td> </tr> </table> "	FALSE
"case"	"stringr"	"Convert case of a string."	"<p>Convert case of a string. </p>"	"<pre>str_to_upper(string, locale = '')<br />str_to_lower(string, locale = '')<br />str_to_title(string, locale = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>String to modify</p> </td> </tr> <tr valign='top'> <td><code>locale</code></td> <td> <p>Locale to use for translations.</p> </td> </tr> </table> "	FALSE
"str_trim"	"stringr"	"Trim whitespace from start and end of string."	"<p>Trim whitespace from start and end of string. </p>"	"<pre>str_trim(string, side = c('both', 'left', 'right')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>A character vector.</p> </td> </tr> <tr valign='top'> <td><code>side</code></td> <td> <p>Side on which to remove whitespace (left, right or both).</p> </td> </tr> </table> "	FALSE
"str_trunc"	"stringr"	"Truncate a character string."	"<p>Truncate a character string. </p>"	"<pre>str_trunc(string, width, side = c('right', 'left', 'center'),<br />   ellipsis = '...') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>A character vector.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Maximum width of string.</p> </td> </tr> <tr valign='top'> <td><code>side, ellipsis</code></td> <td> <p>Location and content of ellipsis that indicates content has been removed.</p> </td> </tr> </table> "	FALSE
"str_view"	"stringr"	"View HTML rendering of regular expression match."	"<p><code>str_view</code> shows the first match; <code>str_view_all</code> shows all the matches. </p>"	"<pre>str_view(string, pattern, match = NA)<br />str_view_all(string, pattern, match = NA) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for. </p> <p>The default interpretation is a regular expression, as described in stringi-search-regex. Control options with <code>regex()</code>. </p> <p>Match a fixed string (i.e. by comparing only bytes), using <code>fixed(x)</code>. This is fast, but approximate. Generally, for matching human text, you'll want <code>coll(x)</code> which respects character matching rules for the specified locale. </p> <p>Match character, word, line and sentence boundaries with <code>boundary()</code>. An empty pattern, '', is equivalent to <code>boundary('character')</code>.</p> </td> </tr> <tr valign='top'> <td><code>match</code></td> <td> <p>If <code>TRUE</code>, shows only strings that match the pattern. If <code>FALSE</code>, shows only the strings that don't match the pattern. Otherwise (the default, <code>NA</code>) displays both matches and non-matches.</p> </td> </tr> </table> "	FALSE
"str_view"	"stringr"	"View HTML rendering of regular expression match."	"<p><code>str_view</code> shows the first match; <code>str_view_all</code> shows all the matches. </p>"	"<pre>str_view(string, pattern, match = NA)<br />str_view_all(string, pattern, match = NA) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>Input vector. Either a character vector, or something coercible to one.</p> </td> </tr> <tr valign='top'> <td><code>pattern</code></td> <td> <p>Pattern to look for. </p> <p>The default interpretation is a regular expression, as described in stringi-search-regex. Control options with <code>regex()</code>. </p> <p>Match a fixed string (i.e. by comparing only bytes), using <code>fixed(x)</code>. This is fast, but approximate. Generally, for matching human text, you'll want <code>coll(x)</code> which respects character matching rules for the specified locale. </p> <p>Match character, word, line and sentence boundaries with <code>boundary()</code>. An empty pattern, '', is equivalent to <code>boundary('character')</code>.</p> </td> </tr> <tr valign='top'> <td><code>match</code></td> <td> <p>If <code>TRUE</code>, shows only strings that match the pattern. If <code>FALSE</code>, shows only the strings that don't match the pattern. Otherwise (the default, <code>NA</code>) displays both matches and non-matches.</p> </td> </tr> </table> "	FALSE
"str_wrap"	"stringr"	"Wrap strings into nicely formatted paragraphs."	"<p>This is a wrapper around <code>stri_wrap</code> which implements the Knuth-Plass paragraph wrapping algorithm. </p>"	"<pre>str_wrap(string, width = 80, indent = 0, exdent = 0) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>character vector of strings to reformat.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>positive integer giving target line width in characters. A width less than or equal to 1 will put each word on its own line.</p> </td> </tr> <tr valign='top'> <td><code>indent</code></td> <td> <p>non-negative integer giving indentation of first line in each paragraph</p> </td> </tr> <tr valign='top'> <td><code>exdent</code></td> <td> <p>non-negative integer giving indentation of following lines in each paragraph</p> </td> </tr> </table> "	FALSE
"word"	"stringr"	"Extract words from a sentence."	"<p>Extract words from a sentence. </p>"	"<pre>word(string, start = 1L, end = start, sep = fixed(' ')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>string</code></td> <td> <p>input character vector.</p> </td> </tr> <tr valign='top'> <td><code>start</code></td> <td> <p>integer vector giving position of first word to extract. Defaults to first word. If negative, counts backwards from last character.</p> </td> </tr> <tr valign='top'> <td><code>end</code></td> <td> <p>integer vector giving position of last word to extract. Defaults to first word. If negative, counts backwards from last character.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>separator between words.  Defaults to single space.</p> </td> </tr> </table> "	FALSE
"stringr-data"	"stringr"	"Sample character vectors for practicing string manipulations."	"<p><code>fruit</code> and <code>word</code> come from the <code>rcorpora</code> package written by Gabor Csardi; the data was collected by Darius Kazemi and made available at <a href='https://github.com/dariusk/corpora'>https://github.com/dariusk/corpora</a>. <code>sentences</code> is a collection of 'Harvard sentences' used for standardised testing of voice. </p>"	"<pre>sentences<br />fruit<br />words </pre>"	NA	FALSE
"tibble-package"	"tibble"	"Simple Data Frames"	"<p>Provides a 'tbl_df' class that offers better checking and printing capabilities than traditional data frames. </p>"	NA	NA	FALSE
"add_column"	"tibble"	"Add columns to a data frame"	"<p>This is a convenient way to add one or more columns to an existing data frame. </p>"	"<pre>add_column(.data, ..., .before = NULL, .after = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>Data frame to append to.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Name-value pairs, all values must have one element for each row in the data frame, or be of length 1</p> </td> </tr> <tr valign='top'> <td><code>.before, .after</code></td> <td> <p>One-based column index or column name where to add the new columns, default: after last column</p> </td> </tr> </table> "	FALSE
"add_row"	"tibble"	"Add rows to a data frame"	"<p>This is a convenient way to add one or more rows of data to an existing data frame. See <code>tribble</code> for an easy way to create an complete data frame row-by-row. </p>"	"<pre>add_row(.data, ..., .before = NULL, .after = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.data</code></td> <td> <p>Data frame to append to.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Name-value pairs. If you don't supply the name of a variable, it'll be given the value <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>.before, .after</code></td> <td> <p>One-based row index where to add the new rows, default: after last row</p> </td> </tr> </table> "	FALSE
"all_equal"	"tibble"	"Flexible equality comparison for data frames."	"<p>When comparing two <code>tbl_df</code> using <code>all.equal</code>, column and row order is ignored by default, and types are not coerced.  The <code>dplyr</code> package provides a much more efficient implementation for this functionality. </p>"	"<pre>all_equal(target, current, ignore_col_order = TRUE, ignore_row_order = TRUE,<br />   convert = FALSE, ...)<br />## S3 method for class 'tbl_df' all.equal(target, current, ignore_col_order = TRUE,<br />   ignore_row_order = TRUE, convert = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>target, current</code></td> <td> <p>Two data frames to compare.</p> </td> </tr> <tr valign='top'> <td><code>ignore_col_order</code></td> <td> <p>Should order of columns be ignored?</p> </td> </tr> <tr valign='top'> <td><code>ignore_row_order</code></td> <td> <p>Should order of rows be ignored?</p> </td> </tr> <tr valign='top'> <td><code>convert</code></td> <td> <p>Should similar classes be converted? Currently this will convert factor to character and integer to double.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Ignored. Needed for compatibility with <code>all.equal</code>.</p> </td> </tr> </table> "	FALSE
"all_equal"	"tibble"	"Flexible equality comparison for data frames."	"<p>When comparing two <code>tbl_df</code> using <code>all.equal</code>, column and row order is ignored by default, and types are not coerced.  The <code>dplyr</code> package provides a much more efficient implementation for this functionality. </p>"	"<pre>all_equal(target, current, ignore_col_order = TRUE, ignore_row_order = TRUE,<br />   convert = FALSE, ...)<br />## S3 method for class 'tbl_df' all.equal(target, current, ignore_col_order = TRUE,<br />   ignore_row_order = TRUE, convert = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>target, current</code></td> <td> <p>Two data frames to compare.</p> </td> </tr> <tr valign='top'> <td><code>ignore_col_order</code></td> <td> <p>Should order of columns be ignored?</p> </td> </tr> <tr valign='top'> <td><code>ignore_row_order</code></td> <td> <p>Should order of rows be ignored?</p> </td> </tr> <tr valign='top'> <td><code>convert</code></td> <td> <p>Should similar classes be converted? Currently this will convert factor to character and integer to double.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Ignored. Needed for compatibility with <code>all.equal</code>.</p> </td> </tr> </table> "	FALSE
"as_tibble"	"tibble"	"Coerce lists and matrices to data frames."	"<p><code>as.data.frame</code> is effectively a thin wrapper around <code>data.frame</code>, and hence is rather slow (because it calls <code>data.frame</code> on each element before <code>cbind</code>ing together). <code>as_tibble</code> is a new S3 generic with more efficient methods for matrices and data frames. </p>"	"<pre>as_tibble(x, ...)<br />## S3 method for class 'tbl_df' as_tibble(x, ...)<br />## S3 method for class 'data.frame' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'list' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'matrix' as_tibble(x, ...)<br />## S3 method for class 'table' as_tibble(x, n = 'n', ...)<br />## S3 method for class 'NULL' as_tibble(x, ...)<br />## Default S3 method: as_tibble(x, ...)<br />as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list. Each element of the list must have the same length.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to individual methods.</p> </td> </tr> <tr valign='top'> <td><code>validate</code></td> <td> <p>When <code>TRUE</code>, verifies that the input is a valid data frame (i.e. all columns are named, and are 1d vectors or lists). You may want to suppress this when you know that you already have a valid data frame and you want to save some time.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Name for count column, default: <code>'n'</code>.</p> </td> </tr> </table> "	FALSE
"as_tibble"	"tibble"	"Coerce lists and matrices to data frames."	"<p><code>as.data.frame</code> is effectively a thin wrapper around <code>data.frame</code>, and hence is rather slow (because it calls <code>data.frame</code> on each element before <code>cbind</code>ing together). <code>as_tibble</code> is a new S3 generic with more efficient methods for matrices and data frames. </p>"	"<pre>as_tibble(x, ...)<br />## S3 method for class 'tbl_df' as_tibble(x, ...)<br />## S3 method for class 'data.frame' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'list' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'matrix' as_tibble(x, ...)<br />## S3 method for class 'table' as_tibble(x, n = 'n', ...)<br />## S3 method for class 'NULL' as_tibble(x, ...)<br />## Default S3 method: as_tibble(x, ...)<br />as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list. Each element of the list must have the same length.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to individual methods.</p> </td> </tr> <tr valign='top'> <td><code>validate</code></td> <td> <p>When <code>TRUE</code>, verifies that the input is a valid data frame (i.e. all columns are named, and are 1d vectors or lists). You may want to suppress this when you know that you already have a valid data frame and you want to save some time.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Name for count column, default: <code>'n'</code>.</p> </td> </tr> </table> "	FALSE
"as_tibble"	"tibble"	"Coerce lists and matrices to data frames."	"<p><code>as.data.frame</code> is effectively a thin wrapper around <code>data.frame</code>, and hence is rather slow (because it calls <code>data.frame</code> on each element before <code>cbind</code>ing together). <code>as_tibble</code> is a new S3 generic with more efficient methods for matrices and data frames. </p>"	"<pre>as_tibble(x, ...)<br />## S3 method for class 'tbl_df' as_tibble(x, ...)<br />## S3 method for class 'data.frame' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'list' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'matrix' as_tibble(x, ...)<br />## S3 method for class 'table' as_tibble(x, n = 'n', ...)<br />## S3 method for class 'NULL' as_tibble(x, ...)<br />## Default S3 method: as_tibble(x, ...)<br />as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list. Each element of the list must have the same length.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to individual methods.</p> </td> </tr> <tr valign='top'> <td><code>validate</code></td> <td> <p>When <code>TRUE</code>, verifies that the input is a valid data frame (i.e. all columns are named, and are 1d vectors or lists). You may want to suppress this when you know that you already have a valid data frame and you want to save some time.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Name for count column, default: <code>'n'</code>.</p> </td> </tr> </table> "	FALSE
"as_tibble"	"tibble"	"Coerce lists and matrices to data frames."	"<p><code>as.data.frame</code> is effectively a thin wrapper around <code>data.frame</code>, and hence is rather slow (because it calls <code>data.frame</code> on each element before <code>cbind</code>ing together). <code>as_tibble</code> is a new S3 generic with more efficient methods for matrices and data frames. </p>"	"<pre>as_tibble(x, ...)<br />## S3 method for class 'tbl_df' as_tibble(x, ...)<br />## S3 method for class 'data.frame' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'list' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'matrix' as_tibble(x, ...)<br />## S3 method for class 'table' as_tibble(x, n = 'n', ...)<br />## S3 method for class 'NULL' as_tibble(x, ...)<br />## Default S3 method: as_tibble(x, ...)<br />as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list. Each element of the list must have the same length.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to individual methods.</p> </td> </tr> <tr valign='top'> <td><code>validate</code></td> <td> <p>When <code>TRUE</code>, verifies that the input is a valid data frame (i.e. all columns are named, and are 1d vectors or lists). You may want to suppress this when you know that you already have a valid data frame and you want to save some time.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Name for count column, default: <code>'n'</code>.</p> </td> </tr> </table> "	FALSE
"as_tibble"	"tibble"	"Coerce lists and matrices to data frames."	"<p><code>as.data.frame</code> is effectively a thin wrapper around <code>data.frame</code>, and hence is rather slow (because it calls <code>data.frame</code> on each element before <code>cbind</code>ing together). <code>as_tibble</code> is a new S3 generic with more efficient methods for matrices and data frames. </p>"	"<pre>as_tibble(x, ...)<br />## S3 method for class 'tbl_df' as_tibble(x, ...)<br />## S3 method for class 'data.frame' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'list' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'matrix' as_tibble(x, ...)<br />## S3 method for class 'table' as_tibble(x, n = 'n', ...)<br />## S3 method for class 'NULL' as_tibble(x, ...)<br />## Default S3 method: as_tibble(x, ...)<br />as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list. Each element of the list must have the same length.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to individual methods.</p> </td> </tr> <tr valign='top'> <td><code>validate</code></td> <td> <p>When <code>TRUE</code>, verifies that the input is a valid data frame (i.e. all columns are named, and are 1d vectors or lists). You may want to suppress this when you know that you already have a valid data frame and you want to save some time.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Name for count column, default: <code>'n'</code>.</p> </td> </tr> </table> "	FALSE
"as_tibble"	"tibble"	"Coerce lists and matrices to data frames."	"<p><code>as.data.frame</code> is effectively a thin wrapper around <code>data.frame</code>, and hence is rather slow (because it calls <code>data.frame</code> on each element before <code>cbind</code>ing together). <code>as_tibble</code> is a new S3 generic with more efficient methods for matrices and data frames. </p>"	"<pre>as_tibble(x, ...)<br />## S3 method for class 'tbl_df' as_tibble(x, ...)<br />## S3 method for class 'data.frame' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'list' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'matrix' as_tibble(x, ...)<br />## S3 method for class 'table' as_tibble(x, n = 'n', ...)<br />## S3 method for class 'NULL' as_tibble(x, ...)<br />## Default S3 method: as_tibble(x, ...)<br />as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list. Each element of the list must have the same length.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to individual methods.</p> </td> </tr> <tr valign='top'> <td><code>validate</code></td> <td> <p>When <code>TRUE</code>, verifies that the input is a valid data frame (i.e. all columns are named, and are 1d vectors or lists). You may want to suppress this when you know that you already have a valid data frame and you want to save some time.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Name for count column, default: <code>'n'</code>.</p> </td> </tr> </table> "	FALSE
"as_tibble"	"tibble"	"Coerce lists and matrices to data frames."	"<p><code>as.data.frame</code> is effectively a thin wrapper around <code>data.frame</code>, and hence is rather slow (because it calls <code>data.frame</code> on each element before <code>cbind</code>ing together). <code>as_tibble</code> is a new S3 generic with more efficient methods for matrices and data frames. </p>"	"<pre>as_tibble(x, ...)<br />## S3 method for class 'tbl_df' as_tibble(x, ...)<br />## S3 method for class 'data.frame' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'list' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'matrix' as_tibble(x, ...)<br />## S3 method for class 'table' as_tibble(x, n = 'n', ...)<br />## S3 method for class 'NULL' as_tibble(x, ...)<br />## Default S3 method: as_tibble(x, ...)<br />as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list. Each element of the list must have the same length.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to individual methods.</p> </td> </tr> <tr valign='top'> <td><code>validate</code></td> <td> <p>When <code>TRUE</code>, verifies that the input is a valid data frame (i.e. all columns are named, and are 1d vectors or lists). You may want to suppress this when you know that you already have a valid data frame and you want to save some time.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Name for count column, default: <code>'n'</code>.</p> </td> </tr> </table> "	FALSE
"as_tibble"	"tibble"	"Coerce lists and matrices to data frames."	"<p><code>as.data.frame</code> is effectively a thin wrapper around <code>data.frame</code>, and hence is rather slow (because it calls <code>data.frame</code> on each element before <code>cbind</code>ing together). <code>as_tibble</code> is a new S3 generic with more efficient methods for matrices and data frames. </p>"	"<pre>as_tibble(x, ...)<br />## S3 method for class 'tbl_df' as_tibble(x, ...)<br />## S3 method for class 'data.frame' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'list' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'matrix' as_tibble(x, ...)<br />## S3 method for class 'table' as_tibble(x, n = 'n', ...)<br />## S3 method for class 'NULL' as_tibble(x, ...)<br />## Default S3 method: as_tibble(x, ...)<br />as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list. Each element of the list must have the same length.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to individual methods.</p> </td> </tr> <tr valign='top'> <td><code>validate</code></td> <td> <p>When <code>TRUE</code>, verifies that the input is a valid data frame (i.e. all columns are named, and are 1d vectors or lists). You may want to suppress this when you know that you already have a valid data frame and you want to save some time.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Name for count column, default: <code>'n'</code>.</p> </td> </tr> </table> "	FALSE
"as_tibble"	"tibble"	"Coerce lists and matrices to data frames."	"<p><code>as.data.frame</code> is effectively a thin wrapper around <code>data.frame</code>, and hence is rather slow (because it calls <code>data.frame</code> on each element before <code>cbind</code>ing together). <code>as_tibble</code> is a new S3 generic with more efficient methods for matrices and data frames. </p>"	"<pre>as_tibble(x, ...)<br />## S3 method for class 'tbl_df' as_tibble(x, ...)<br />## S3 method for class 'data.frame' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'list' as_tibble(x, validate = TRUE, ...)<br />## S3 method for class 'matrix' as_tibble(x, ...)<br />## S3 method for class 'table' as_tibble(x, n = 'n', ...)<br />## S3 method for class 'NULL' as_tibble(x, ...)<br />## Default S3 method: as_tibble(x, ...)<br />as_data_frame(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list. Each element of the list must have the same length.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to individual methods.</p> </td> </tr> <tr valign='top'> <td><code>validate</code></td> <td> <p>When <code>TRUE</code>, verifies that the input is a valid data frame (i.e. all columns are named, and are 1d vectors or lists). You may want to suppress this when you know that you already have a valid data frame and you want to save some time.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>Name for count column, default: <code>'n'</code>.</p> </td> </tr> </table> "	FALSE
"rownames"	"tibble"	"Tools for working with row names"	"<p>While a tibble can have row names (e.g., when converting from a regular data frame), they are removed when subsetting with the <code>[</code> operator. A warning will be raised when attempting to assign non-<code>NULL</code> row names to a tibble. Generally, it is best to avoid row names, because they are basically a character column with different semantics to every other column. These functions allow to you detect if a data frame has row names (<code>has_rownames</code>), remove them (<code>remove_rownames</code>), or convert them back-and-forth between an explicit column (<code>rownames_to_column</code> and <code>column_to_rownames</code>). </p>"	"<pre>has_rownames(df)<br />remove_rownames(df)<br />rownames_to_column(df, var = 'rowname')<br />column_to_rownames(df, var = 'rowname') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>df</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>var</code></td> <td> <p>Name of column to use for rownames.</p> </td> </tr> </table> "	FALSE
"tibble"	"tibble"	"Build a data frame or list."	"<p><code>tibble</code> is a trimmed down version of <code>data.frame</code> that: </p> <ol> <li> <p> Never coerces inputs (i.e. strings stay as strings!). </p> </li> <li> <p> Never adds <code>row.names</code>. </p> </li> <li> <p> Never munges column names. </p> </li> <li> <p> Only recycles length 1 inputs. </p> </li> <li> <p> Evaluates its arguments lazily and in order. </p> </li> <li> <p> Adds <code>tbl_df</code> class to output. </p> </li> <li> <p> Automatically adds column names. </p> </li> </ol> "	"<pre>tibble(...)<br />tibble_(xs)<br />data_frame(...)<br />data_frame_(xs)<br />lst(...)<br />lst_(xs) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A set of name-value pairs. Arguments are evaluated sequentially, so you can refer to previously created variables.</p> </td> </tr> <tr valign='top'> <td><code>xs</code></td> <td> <p>A list of unevaluated expressions created with <code>~</code>, <code>quote()</code>, or <code>lazy</code>.</p> </td> </tr> </table> "	FALSE
"tibble"	"tibble"	"Build a data frame or list."	"<p><code>tibble</code> is a trimmed down version of <code>data.frame</code> that: </p> <ol> <li> <p> Never coerces inputs (i.e. strings stay as strings!). </p> </li> <li> <p> Never adds <code>row.names</code>. </p> </li> <li> <p> Never munges column names. </p> </li> <li> <p> Only recycles length 1 inputs. </p> </li> <li> <p> Evaluates its arguments lazily and in order. </p> </li> <li> <p> Adds <code>tbl_df</code> class to output. </p> </li> <li> <p> Automatically adds column names. </p> </li> </ol> "	"<pre>tibble(...)<br />tibble_(xs)<br />data_frame(...)<br />data_frame_(xs)<br />lst(...)<br />lst_(xs) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A set of name-value pairs. Arguments are evaluated sequentially, so you can refer to previously created variables.</p> </td> </tr> <tr valign='top'> <td><code>xs</code></td> <td> <p>A list of unevaluated expressions created with <code>~</code>, <code>quote()</code>, or <code>lazy</code>.</p> </td> </tr> </table> "	FALSE
"enframe"	"tibble"	"Converting atomic vectors to data frames"	"<p>A helper function that converts named atomic vectors or lists to two-column data frames. For unnamed vectors, the natural sequence is used as name column. </p>"	"<pre>enframe(x, name = 'name', value = 'value') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An atomic vector</p> </td> </tr> <tr valign='top'> <td><code>name, value</code></td> <td> <p>Names of the columns that store the names and values</p> </td> </tr> </table> "	FALSE
"tribble"	"tibble"	"Row-wise tibble creation"	"<p>Create <code>tibble</code>s laying out the data in rows, rather than in columns. This is useful for small tables of data where readability is important.  Please see tibble-package for a general introduction. </p>"	"<pre>tribble(...)<br />frame_data(...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>...</code></td> <td> <p>Arguments specifying the structure of a <code>tibble</code>. Variable names should be formulas, and may only appear before the data.</p> </td> </tr></table> "	FALSE
"glimpse"	"tibble"	"Get a glimpse of your data."	"<p>This is like a transposed version of print: columns run down the page, and data runs across. This makes it possible to see every column in a data frame. It's a little like <code>str</code> applied to a data frame but it tries to show you as much data as possible. (And it always shows the underlying data, even when applied to a remote data source.) </p>"	"<pre>glimpse(x, width = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>An object to glimpse at.</p> </td> </tr> <tr valign='top'> <td><code>width</code></td> <td> <p>Width of output: defaults to the setting of the option <code>tibble.width</code> (if finite) or the width of the console.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed onto individual methods.</p> </td> </tr> </table> "	FALSE
"has_name"	"tibble"	"Convenience function to check presence of a named element"	"<p>This function returns a logical value that indicates if a data frame or another named object contains an element with a specific name. </p>"	"<pre>has_name(x, name) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A data frame or another named object</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>Element name(s) to check</p> </td> </tr> </table> "	FALSE
"rownames"	"tibble"	"Tools for working with row names"	"<p>While a tibble can have row names (e.g., when converting from a regular data frame), they are removed when subsetting with the <code>[</code> operator. A warning will be raised when attempting to assign non-<code>NULL</code> row names to a tibble. Generally, it is best to avoid row names, because they are basically a character column with different semantics to every other column. These functions allow to you detect if a data frame has row names (<code>has_rownames</code>), remove them (<code>remove_rownames</code>), or convert them back-and-forth between an explicit column (<code>rownames_to_column</code> and <code>column_to_rownames</code>). </p>"	"<pre>has_rownames(df)<br />remove_rownames(df)<br />rownames_to_column(df, var = 'rowname')<br />column_to_rownames(df, var = 'rowname') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>df</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>var</code></td> <td> <p>Name of column to use for rownames.</p> </td> </tr> </table> "	FALSE
"is.tibble"	"tibble"	"Test if the object is a tibble."	"<p>Test if the object is a tibble. </p>"	"<pre>is.tibble(x)<br />is_tibble(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>An object</p> </td> </tr></table> "	FALSE
"is.tibble"	"tibble"	"Test if the object is a tibble."	"<p>Test if the object is a tibble. </p>"	"<pre>is.tibble(x)<br />is_tibble(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>An object</p> </td> </tr></table> "	FALSE
"tibble"	"tibble"	"Build a data frame or list."	"<p><code>tibble</code> is a trimmed down version of <code>data.frame</code> that: </p> <ol> <li> <p> Never coerces inputs (i.e. strings stay as strings!). </p> </li> <li> <p> Never adds <code>row.names</code>. </p> </li> <li> <p> Never munges column names. </p> </li> <li> <p> Only recycles length 1 inputs. </p> </li> <li> <p> Evaluates its arguments lazily and in order. </p> </li> <li> <p> Adds <code>tbl_df</code> class to output. </p> </li> <li> <p> Automatically adds column names. </p> </li> </ol> "	"<pre>tibble(...)<br />tibble_(xs)<br />data_frame(...)<br />data_frame_(xs)<br />lst(...)<br />lst_(xs) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A set of name-value pairs. Arguments are evaluated sequentially, so you can refer to previously created variables.</p> </td> </tr> <tr valign='top'> <td><code>xs</code></td> <td> <p>A list of unevaluated expressions created with <code>~</code>, <code>quote()</code>, or <code>lazy</code>.</p> </td> </tr> </table> "	FALSE
"tibble"	"tibble"	"Build a data frame or list."	"<p><code>tibble</code> is a trimmed down version of <code>data.frame</code> that: </p> <ol> <li> <p> Never coerces inputs (i.e. strings stay as strings!). </p> </li> <li> <p> Never adds <code>row.names</code>. </p> </li> <li> <p> Never munges column names. </p> </li> <li> <p> Only recycles length 1 inputs. </p> </li> <li> <p> Evaluates its arguments lazily and in order. </p> </li> <li> <p> Adds <code>tbl_df</code> class to output. </p> </li> <li> <p> Automatically adds column names. </p> </li> </ol> "	"<pre>tibble(...)<br />tibble_(xs)<br />data_frame(...)<br />data_frame_(xs)<br />lst(...)<br />lst_(xs) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A set of name-value pairs. Arguments are evaluated sequentially, so you can refer to previously created variables.</p> </td> </tr> <tr valign='top'> <td><code>xs</code></td> <td> <p>A list of unevaluated expressions created with <code>~</code>, <code>quote()</code>, or <code>lazy</code>.</p> </td> </tr> </table> "	FALSE
"rownames"	"tibble"	"Tools for working with row names"	"<p>While a tibble can have row names (e.g., when converting from a regular data frame), they are removed when subsetting with the <code>[</code> operator. A warning will be raised when attempting to assign non-<code>NULL</code> row names to a tibble. Generally, it is best to avoid row names, because they are basically a character column with different semantics to every other column. These functions allow to you detect if a data frame has row names (<code>has_rownames</code>), remove them (<code>remove_rownames</code>), or convert them back-and-forth between an explicit column (<code>rownames_to_column</code> and <code>column_to_rownames</code>). </p>"	"<pre>has_rownames(df)<br />remove_rownames(df)<br />rownames_to_column(df, var = 'rowname')<br />column_to_rownames(df, var = 'rowname') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>df</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>var</code></td> <td> <p>Name of column to use for rownames.</p> </td> </tr> </table> "	FALSE
"repair_names"	"tibble"	"Repair object names."	"<p><code>repair_names</code> ensures its input has non-missing and unique names (duplicated names get a numeric suffix). Valid names are left as is. </p>"	"<pre>repair_names(x, prefix = 'V', sep = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A named vector.</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>A string, the prefix to use for new column names.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>A string inserted between the column name and de-duplicating number.</p> </td> </tr> </table> "	FALSE
"rownames"	"tibble"	"Tools for working with row names"	"<p>While a tibble can have row names (e.g., when converting from a regular data frame), they are removed when subsetting with the <code>[</code> operator. A warning will be raised when attempting to assign non-<code>NULL</code> row names to a tibble. Generally, it is best to avoid row names, because they are basically a character column with different semantics to every other column. These functions allow to you detect if a data frame has row names (<code>has_rownames</code>), remove them (<code>remove_rownames</code>), or convert them back-and-forth between an explicit column (<code>rownames_to_column</code> and <code>column_to_rownames</code>). </p>"	"<pre>has_rownames(df)<br />remove_rownames(df)<br />rownames_to_column(df, var = 'rowname')<br />column_to_rownames(df, var = 'rowname') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>df</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>var</code></td> <td> <p>Name of column to use for rownames.</p> </td> </tr> </table> "	FALSE
"rownames"	"tibble"	"Tools for working with row names"	"<p>While a tibble can have row names (e.g., when converting from a regular data frame), they are removed when subsetting with the <code>[</code> operator. A warning will be raised when attempting to assign non-<code>NULL</code> row names to a tibble. Generally, it is best to avoid row names, because they are basically a character column with different semantics to every other column. These functions allow to you detect if a data frame has row names (<code>has_rownames</code>), remove them (<code>remove_rownames</code>), or convert them back-and-forth between an explicit column (<code>rownames_to_column</code> and <code>column_to_rownames</code>). </p>"	"<pre>has_rownames(df)<br />remove_rownames(df)<br />rownames_to_column(df, var = 'rowname')<br />column_to_rownames(df, var = 'rowname') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>df</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>var</code></td> <td> <p>Name of column to use for rownames.</p> </td> </tr> </table> "	FALSE
"tibble"	"tibble"	"Build a data frame or list."	"<p><code>tibble</code> is a trimmed down version of <code>data.frame</code> that: </p> <ol> <li> <p> Never coerces inputs (i.e. strings stay as strings!). </p> </li> <li> <p> Never adds <code>row.names</code>. </p> </li> <li> <p> Never munges column names. </p> </li> <li> <p> Only recycles length 1 inputs. </p> </li> <li> <p> Evaluates its arguments lazily and in order. </p> </li> <li> <p> Adds <code>tbl_df</code> class to output. </p> </li> <li> <p> Automatically adds column names. </p> </li> </ol> "	"<pre>tibble(...)<br />tibble_(xs)<br />data_frame(...)<br />data_frame_(xs)<br />lst(...)<br />lst_(xs) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A set of name-value pairs. Arguments are evaluated sequentially, so you can refer to previously created variables.</p> </td> </tr> <tr valign='top'> <td><code>xs</code></td> <td> <p>A list of unevaluated expressions created with <code>~</code>, <code>quote()</code>, or <code>lazy</code>.</p> </td> </tr> </table> "	FALSE
"tibble"	"tibble"	"Build a data frame or list."	"<p><code>tibble</code> is a trimmed down version of <code>data.frame</code> that: </p> <ol> <li> <p> Never coerces inputs (i.e. strings stay as strings!). </p> </li> <li> <p> Never adds <code>row.names</code>. </p> </li> <li> <p> Never munges column names. </p> </li> <li> <p> Only recycles length 1 inputs. </p> </li> <li> <p> Evaluates its arguments lazily and in order. </p> </li> <li> <p> Adds <code>tbl_df</code> class to output. </p> </li> <li> <p> Automatically adds column names. </p> </li> </ol> "	"<pre>tibble(...)<br />tibble_(xs)<br />data_frame(...)<br />data_frame_(xs)<br />lst(...)<br />lst_(xs) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>...</code></td> <td> <p>A set of name-value pairs. Arguments are evaluated sequentially, so you can refer to previously created variables.</p> </td> </tr> <tr valign='top'> <td><code>xs</code></td> <td> <p>A list of unevaluated expressions created with <code>~</code>, <code>quote()</code>, or <code>lazy</code>.</p> </td> </tr> </table> "	FALSE
"tribble"	"tibble"	"Row-wise tibble creation"	"<p>Create <code>tibble</code>s laying out the data in rows, rather than in columns. This is useful for small tables of data where readability is important.  Please see tibble-package for a general introduction. </p>"	"<pre>tribble(...)<br />frame_data(...) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>...</code></td> <td> <p>Arguments specifying the structure of a <code>tibble</code>. Variable names should be formulas, and may only appear before the data.</p> </td> </tr></table> "	FALSE
"session_history"	"rvest"	"History navigation tools"	"<p>History navigation tools </p>"	"<pre>session_history(x)<br />back(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A session.</p> </td> </tr></table>"	FALSE
"encoding"	"rvest"	"Guess and repair faulty character encoding."	"<p>These functions help you respond to web pages that declare incorrect encodings. You can use <code>guess_encoding</code> to figure out what the real encoding is (and then supply that to the <code>encoding</code> argument of html), or use <code>repair_encoding</code> to fix character vectors after the fact. </p>"	"<pre>guess_encoding(x)<br />repair_encoding(x, from = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector.</p> </td> </tr> <tr valign='top'> <td><code>from</code></td> <td> <p>The encoding that the string is actually in. If <code>NULL</code>,</p> </td> </tr> </table> "	FALSE
"jump_to"	"rvest"	"Navigate to a new url."	"<p><code>jump_to()</code> takes a url (either relative or absolute); <code>follow_link</code> takes an expression that refers to a link (an <code>&lt;a&gt;</code> tag) on the current page. </p>"	"<pre>jump_to(x, url, ...)<br />follow_link(x, i, css, xpath, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A session.</p> </td> </tr> <tr valign='top'> <td><code>url</code></td> <td> <p>A URL, either relative or absolute, to navigate to.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Any additional httr configs to apply to this request.</p> </td> </tr> <tr valign='top'> <td><code>i</code></td> <td> <p>You can select with: </p><br /><dl> <dt>an integer</dt> <dd> <p>selects the ith link</p> </dd> <dt>a string</dt> <dd> <p>first link containing that text (case sensitive)</p> </dd> </dl> </td> </tr> <tr valign='top'> <td><code>css</code></td> <td> <p>Nodes to select. Supply one of <code>css</code> or <code>xpath</code> depending on whether you want to use a css or xpath 1.0 selector.</p> </td> </tr> <tr valign='top'> <td><code>xpath</code></td> <td> <p>Nodes to select. Supply one of <code>css</code> or <code>xpath</code> depending on whether you want to use a css or xpath 1.0 selector.</p> </td> </tr> </table> "	FALSE
"google_form"	"rvest"	"Make link to google form given id"	"<p>Make link to google form given id </p>"	"<pre>google_form(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>Unique identifier for form</p> </td> </tr></table> "	FALSE
"encoding"	"rvest"	"Guess and repair faulty character encoding."	"<p>These functions help you respond to web pages that declare incorrect encodings. You can use <code>guess_encoding</code> to figure out what the real encoding is (and then supply that to the <code>encoding</code> argument of html), or use <code>repair_encoding</code> to fix character vectors after the fact. </p>"	"<pre>guess_encoding(x)<br />repair_encoding(x, from = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector.</p> </td> </tr> <tr valign='top'> <td><code>from</code></td> <td> <p>The encoding that the string is actually in. If <code>NULL</code>,</p> </td> </tr> </table> "	FALSE
"html"	"rvest"	"Parse an HTML page."	"<p>html is deprecated: please use <code>read_html</code>() instead. </p>"	"<pre>html(x, ..., encoding = '')<br />## S3 method for class 'response' read_xml(x, ..., encoding = '', as_html = FALSE)<br />## S3 method for class 'session' read_xml(x, ..., as_html = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A url, a local path, a string containing html, or a response from an httr request.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If <code>x</code> is a URL, additional arguments are passed on to <code>GET()</code>.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>Specify encoding of document. See <code>iconvlist()</code> for complete list. If you have problems determining the correct encoding, try <code>stri_enc_detect</code></p> </td> </tr> <tr valign='top'> <td><code>as_html</code></td> <td> <p>Optionally parse an xml file as if it's html.</p> </td> </tr> </table> "	FALSE
"html_text"	"rvest"	"Extract attributes, text and tag name from html."	"<p>Extract attributes, text and tag name from html. </p>"	"<pre>html_text(x, trim = FALSE)<br />html_name(x)<br />html_children(x)<br />html_attrs(x)<br />html_attr(x, name, default = NA_character_) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> will trim leading and trailing spaces.</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>Name of attribute to retrieve.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>A string used as a default value when the attribute does not exist in every node.</p> </td> </tr> </table> "	FALSE
"html_text"	"rvest"	"Extract attributes, text and tag name from html."	"<p>Extract attributes, text and tag name from html. </p>"	"<pre>html_text(x, trim = FALSE)<br />html_name(x)<br />html_children(x)<br />html_attrs(x)<br />html_attr(x, name, default = NA_character_) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> will trim leading and trailing spaces.</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>Name of attribute to retrieve.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>A string used as a default value when the attribute does not exist in every node.</p> </td> </tr> </table> "	FALSE
"html_text"	"rvest"	"Extract attributes, text and tag name from html."	"<p>Extract attributes, text and tag name from html. </p>"	"<pre>html_text(x, trim = FALSE)<br />html_name(x)<br />html_children(x)<br />html_attrs(x)<br />html_attr(x, name, default = NA_character_) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> will trim leading and trailing spaces.</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>Name of attribute to retrieve.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>A string used as a default value when the attribute does not exist in every node.</p> </td> </tr> </table> "	FALSE
"html_form"	"rvest"	"Parse forms in a page."	"<p>Parse forms in a page. </p>"	"<pre>html_form(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A node, node set or document.</p> </td> </tr></table> "	FALSE
"html_text"	"rvest"	"Extract attributes, text and tag name from html."	"<p>Extract attributes, text and tag name from html. </p>"	"<pre>html_text(x, trim = FALSE)<br />html_name(x)<br />html_children(x)<br />html_attrs(x)<br />html_attr(x, name, default = NA_character_) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> will trim leading and trailing spaces.</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>Name of attribute to retrieve.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>A string used as a default value when the attribute does not exist in every node.</p> </td> </tr> </table> "	FALSE
"html_nodes"	"rvest"	"Select nodes from an HTML document"	"<p>More easily extract pieces out of HTML documents using XPath and css selectors. CSS selectors are particularly useful in conjunction with <a href='http://selectorgadget.com/'>http://selectorgadget.com/</a>: it makes it easy to find exactly which selector you should be using. If you have't used css selectors before, work your way through the fun tutorial at <a href='http://flukeout.github.io/'>http://flukeout.github.io/</a> </p>"	"<pre>html_nodes(x, css, xpath)<br />html_node(x, css, xpath) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Either a document, a node set or a single node.</p> </td> </tr> <tr valign='top'> <td><code>css, xpath</code></td> <td> <p>Nodes to select. Supply one of <code>css</code> or <code>xpath</code> depending on whether you want to use a css or xpath 1.0 selector.</p> </td> </tr> </table> "	FALSE
"html_nodes"	"rvest"	"Select nodes from an HTML document"	"<p>More easily extract pieces out of HTML documents using XPath and css selectors. CSS selectors are particularly useful in conjunction with <a href='http://selectorgadget.com/'>http://selectorgadget.com/</a>: it makes it easy to find exactly which selector you should be using. If you have't used css selectors before, work your way through the fun tutorial at <a href='http://flukeout.github.io/'>http://flukeout.github.io/</a> </p>"	"<pre>html_nodes(x, css, xpath)<br />html_node(x, css, xpath) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>Either a document, a node set or a single node.</p> </td> </tr> <tr valign='top'> <td><code>css, xpath</code></td> <td> <p>Nodes to select. Supply one of <code>css</code> or <code>xpath</code> depending on whether you want to use a css or xpath 1.0 selector.</p> </td> </tr> </table> "	FALSE
"html_session"	"rvest"	"Simulate a session in an html browser."	"<p>Simulate a session in an html browser. </p>"	"<pre>html_session(url, ...)<br />is.session(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url</code></td> <td> <p>Location to start session</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Any additional httr config to use throughout session.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object to test to see if it's a session.</p> </td> </tr> </table> "	FALSE
"html_table"	"rvest"	"Parse an html table into a data frame."	"<p>Parse an html table into a data frame. </p>"	"<pre>html_table(x, header = NA, trim = TRUE, fill = FALSE, dec = '.') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A node, node set or document.</p> </td> </tr> <tr valign='top'> <td><code>header</code></td> <td> <p>Use first row as header? If <code>NA</code>, will use first row if it consists of <code>&lt;th&gt;</code> tags.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>Remove leading and trailing whitespace within each cell?</p> </td> </tr> <tr valign='top'> <td><code>fill</code></td> <td> <p>If <code>TRUE</code>, automatically fill rows with fewer than the maximum number of columns with <code>NA</code>s.</p> </td> </tr> <tr valign='top'> <td><code>dec</code></td> <td> <p>The character used as decimal mark.</p> </td> </tr> </table> "	FALSE
"html_text"	"rvest"	"Extract attributes, text and tag name from html."	"<p>Extract attributes, text and tag name from html. </p>"	"<pre>html_text(x, trim = FALSE)<br />html_name(x)<br />html_children(x)<br />html_attrs(x)<br />html_attr(x, name, default = NA_character_) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> will trim leading and trailing spaces.</p> </td> </tr> <tr valign='top'> <td><code>name</code></td> <td> <p>Name of attribute to retrieve.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>A string used as a default value when the attribute does not exist in every node.</p> </td> </tr> </table> "	FALSE
"html_session"	"rvest"	"Simulate a session in an html browser."	"<p>Simulate a session in an html browser. </p>"	"<pre>html_session(url, ...)<br />is.session(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>url</code></td> <td> <p>Location to start session</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Any additional httr config to use throughout session.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>An object to test to see if it's a session.</p> </td> </tr> </table> "	FALSE
"jump_to"	"rvest"	"Navigate to a new url."	"<p><code>jump_to()</code> takes a url (either relative or absolute); <code>follow_link</code> takes an expression that refers to a link (an <code>&lt;a&gt;</code> tag) on the current page. </p>"	"<pre>jump_to(x, url, ...)<br />follow_link(x, i, css, xpath, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A session.</p> </td> </tr> <tr valign='top'> <td><code>url</code></td> <td> <p>A URL, either relative or absolute, to navigate to.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Any additional httr configs to apply to this request.</p> </td> </tr> <tr valign='top'> <td><code>i</code></td> <td> <p>You can select with: </p><br /><dl> <dt>an integer</dt> <dd> <p>selects the ith link</p> </dd> <dt>a string</dt> <dd> <p>first link containing that text (case sensitive)</p> </dd> </dl> </td> </tr> <tr valign='top'> <td><code>css</code></td> <td> <p>Nodes to select. Supply one of <code>css</code> or <code>xpath</code> depending on whether you want to use a css or xpath 1.0 selector.</p> </td> </tr> <tr valign='top'> <td><code>xpath</code></td> <td> <p>Nodes to select. Supply one of <code>css</code> or <code>xpath</code> depending on whether you want to use a css or xpath 1.0 selector.</p> </td> </tr> </table> "	FALSE
"pluck"	"rvest"	"Extract elements of a list by position."	"<p>Extract elements of a list by position. </p>"	"<pre>pluck(x, i, type) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A list</p> </td> </tr> <tr valign='top'> <td><code>i</code></td> <td> <p>A string or integer.</p> </td> </tr> <tr valign='top'> <td><code>type</code></td> <td> <p>Type of output, if known</p> </td> </tr> </table>"	FALSE
"html"	"rvest"	"Parse an HTML page."	"<p>html is deprecated: please use <code>read_html</code>() instead. </p>"	"<pre>html(x, ..., encoding = '')<br />## S3 method for class 'response' read_xml(x, ..., encoding = '', as_html = FALSE)<br />## S3 method for class 'session' read_xml(x, ..., as_html = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A url, a local path, a string containing html, or a response from an httr request.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If <code>x</code> is a URL, additional arguments are passed on to <code>GET()</code>.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>Specify encoding of document. See <code>iconvlist()</code> for complete list. If you have problems determining the correct encoding, try <code>stri_enc_detect</code></p> </td> </tr> <tr valign='top'> <td><code>as_html</code></td> <td> <p>Optionally parse an xml file as if it's html.</p> </td> </tr> </table> "	FALSE
"html"	"rvest"	"Parse an HTML page."	"<p>html is deprecated: please use <code>read_html</code>() instead. </p>"	"<pre>html(x, ..., encoding = '')<br />## S3 method for class 'response' read_xml(x, ..., encoding = '', as_html = FALSE)<br />## S3 method for class 'session' read_xml(x, ..., as_html = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A url, a local path, a string containing html, or a response from an httr request.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If <code>x</code> is a URL, additional arguments are passed on to <code>GET()</code>.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>Specify encoding of document. See <code>iconvlist()</code> for complete list. If you have problems determining the correct encoding, try <code>stri_enc_detect</code></p> </td> </tr> <tr valign='top'> <td><code>as_html</code></td> <td> <p>Optionally parse an xml file as if it's html.</p> </td> </tr> </table> "	FALSE
"encoding"	"rvest"	"Guess and repair faulty character encoding."	"<p>These functions help you respond to web pages that declare incorrect encodings. You can use <code>guess_encoding</code> to figure out what the real encoding is (and then supply that to the <code>encoding</code> argument of html), or use <code>repair_encoding</code> to fix character vectors after the fact. </p>"	"<pre>guess_encoding(x)<br />repair_encoding(x, from = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector.</p> </td> </tr> <tr valign='top'> <td><code>from</code></td> <td> <p>The encoding that the string is actually in. If <code>NULL</code>,</p> </td> </tr> </table> "	FALSE
"session_history"	"rvest"	"History navigation tools"	"<p>History navigation tools </p>"	"<pre>session_history(x)<br />back(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A session.</p> </td> </tr></table>"	FALSE
"set_values"	"rvest"	"Set values in a form."	"<p>Set values in a form. </p>"	"<pre>set_values(form, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>form</code></td> <td> <p>Form to modify</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Name-value pairs giving fields to modify</p> </td> </tr> </table> "	FALSE
"submit_form"	"rvest"	"Submit a form back to the server."	"<p>Submit a form back to the server. </p>"	"<pre>submit_form(session, form, submit = NULL, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>session</code></td> <td> <p>Session to submit form to.</p> </td> </tr> <tr valign='top'> <td><code>form</code></td> <td> <p>Form to submit</p> </td> </tr> <tr valign='top'> <td><code>submit</code></td> <td> <p>Name of submit button to use. If not supplied, defaults to first submission button on the form (with a message).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to <code>GET()</code> or <code>POST()</code></p> </td> </tr> </table> "	FALSE
"complete"	"tidyr"	"Complete a data frame with missing combinations of data."	"<p>Turns implicit missing values into explicit missing values. This is a wrapper around <code>expand()</code>, <code>left_join()</code> and <code>replace_na</code> that's useful for completing missing combinations of data. </p>"	"<pre>complete(data, ..., fill = list()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to expand. </p> <p>To find all unique combinations of x, y and z, including those not found in the data, supply each variable as a separate argument. To find only the combinations that occur in the data, use nest: <code>expand(df, nesting(x, y, z))</code>. </p> <p>You can combine the two forms. For example, <code>expand(df, nesting(school_id, student_id), date)</code> would produce a row for every student for each date. </p> <p>For factors, the full set of levels (not just those that appear in the data) are used. For continuous variables, you may need to fill in values that don't appear in the data: to do so use expressions like <code>year = 2010:2020</code> or <code>year = full_seq(year)</code>. </p> <p>Length-zero (empty) elements are automatically dropped.</p> </td> </tr> <tr valign='top'> <td><code>fill</code></td> <td> <p>A named list that for each variable supplies a single value to use instead of <code>NA</code> for missing combinations.</p> </td> </tr> </table> "	FALSE
"expand"	"tidyr"	"Expand data frame to include all combinations of values"	"<p><code>expand()</code> is often useful in conjunction with <code>left_join</code> if you want to convert implicit missing values to explicit missing values. Or you can use it in conjunction with <code>anti_join()</code> to figure out which combinations are missing. </p>"	"<pre>expand(data, ...)<br />crossing(...)<br />crossing_(x)<br />nesting(...)<br />nesting_(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to expand. </p> <p>To find all unique combinations of x, y and z, including those not found in the data, supply each variable as a separate argument. To find only the combinations that occur in the data, use nest: <code>expand(df, nesting(x, y, z))</code>. </p> <p>You can combine the two forms. For example, <code>expand(df, nesting(school_id, student_id), date)</code> would produce a row for every student for each date. </p> <p>For factors, the full set of levels (not just those that appear in the data) are used. For continuous variables, you may need to fill in values that don't appear in the data: to do so use expressions like <code>year = 2010:2020</code> or <code>year = full_seq(year)</code>. </p> <p>Length-zero (empty) elements are automatically dropped.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>For <code>nesting_</code> and <code>crossing_</code> a list of variables.</p> </td> </tr> </table> "	FALSE
"expand"	"tidyr"	"Expand data frame to include all combinations of values"	"<p><code>expand()</code> is often useful in conjunction with <code>left_join</code> if you want to convert implicit missing values to explicit missing values. Or you can use it in conjunction with <code>anti_join()</code> to figure out which combinations are missing. </p>"	"<pre>expand(data, ...)<br />crossing(...)<br />crossing_(x)<br />nesting(...)<br />nesting_(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to expand. </p> <p>To find all unique combinations of x, y and z, including those not found in the data, supply each variable as a separate argument. To find only the combinations that occur in the data, use nest: <code>expand(df, nesting(x, y, z))</code>. </p> <p>You can combine the two forms. For example, <code>expand(df, nesting(school_id, student_id), date)</code> would produce a row for every student for each date. </p> <p>For factors, the full set of levels (not just those that appear in the data) are used. For continuous variables, you may need to fill in values that don't appear in the data: to do so use expressions like <code>year = 2010:2020</code> or <code>year = full_seq(year)</code>. </p> <p>Length-zero (empty) elements are automatically dropped.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>For <code>nesting_</code> and <code>crossing_</code> a list of variables.</p> </td> </tr> </table> "	FALSE
"drop_na"	"tidyr"	"Drop rows containing missing values"	"<p>Drop rows containing missing values </p>"	"<pre>drop_na(data, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of variables to consider while dropping rows. If empty, consider all variables. Use bare variable names. Select all variables between x and z with <code>x:z</code>, exclude y with <code>-y</code>. For more options, see the select documentation.</p> </td> </tr> </table> "	FALSE
"expand"	"tidyr"	"Expand data frame to include all combinations of values"	"<p><code>expand()</code> is often useful in conjunction with <code>left_join</code> if you want to convert implicit missing values to explicit missing values. Or you can use it in conjunction with <code>anti_join()</code> to figure out which combinations are missing. </p>"	"<pre>expand(data, ...)<br />crossing(...)<br />crossing_(x)<br />nesting(...)<br />nesting_(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to expand. </p> <p>To find all unique combinations of x, y and z, including those not found in the data, supply each variable as a separate argument. To find only the combinations that occur in the data, use nest: <code>expand(df, nesting(x, y, z))</code>. </p> <p>You can combine the two forms. For example, <code>expand(df, nesting(school_id, student_id), date)</code> would produce a row for every student for each date. </p> <p>For factors, the full set of levels (not just those that appear in the data) are used. For continuous variables, you may need to fill in values that don't appear in the data: to do so use expressions like <code>year = 2010:2020</code> or <code>year = full_seq(year)</code>. </p> <p>Length-zero (empty) elements are automatically dropped.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>For <code>nesting_</code> and <code>crossing_</code> a list of variables.</p> </td> </tr> </table> "	FALSE
"extract"	"tidyr"	"Extract one column into multiple columns."	"<p>Given a regular expression with capturing groups, <code>extract()</code> turns each group into a new column. If the groups don't match, or the input is NA, the output will be NA. </p>"	"<pre>extract(data, col, into, regex = '([[:alnum:]]+)', remove = TRUE,<br />   convert = FALSE, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>col</code></td> <td> <p>Bare column name.</p> </td> </tr> <tr valign='top'> <td><code>into</code></td> <td> <p>Names of new variables to create as character vector.</p> </td> </tr> <tr valign='top'> <td><code>regex</code></td> <td> <p>a regular expression used to extract the desired values.</p> </td> </tr> <tr valign='top'> <td><code>remove</code></td> <td> <p>If <code>TRUE</code>, remove input column from output data frame.</p> </td> </tr> <tr valign='top'> <td><code>convert</code></td> <td> <p>If <code>TRUE</code>, will run <code>type.convert</code> with <code>as.is = TRUE</code> on new columns. This is useful if the component columns are integer, numeric or logical.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Other arguments passed on to <code>regexec</code> to control how the regular expression is processed.</p> </td> </tr> </table> "	FALSE
"extract_numeric"	"tidyr"	"Extract numeric component of variable."	"<p>DEPRECATED: please use <code>readr::parse_number()</code> instead. </p>"	"<pre>extract_numeric(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A character vector (or a factor).</p> </td> </tr></table>"	FALSE
"fill"	"tidyr"	"Fill in missing values."	"<p>Fills missing values in using the previous entry. This is useful in the common output format where values are not repeated, they're recorded each time they change. </p>"	"<pre>fill(data, ..., .direction = c('down', 'up')) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to fill. Use bare variable names. Select all variables between x and z with <code>x:z</code>, exclude y with <code>-y</code>. For more options, see the select documentation.</p> </td> </tr> <tr valign='top'> <td><code>.direction</code></td> <td> <p>Direction in which to fill missing values. Currently either 'down' (the default) or 'up'.</p> </td> </tr> </table> "	FALSE
"full_seq"	"tidyr"	"Create the full sequence of values in a vector."	"<p>This is useful if you want to fill in missing values that should have been observed but weren't. For example, <code>full_seq(c(1, 2, 4, 6), 1)</code> will return <code>1:6</code>. </p>"	"<pre>full_seq(x, period, tol = 1e-06) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A numeric vector.</p> </td> </tr> <tr valign='top'> <td><code>period</code></td> <td> <p>Gap between each observation. The existing data will be checked to ensure that it is actually of this periodicity.</p> </td> </tr> <tr valign='top'> <td><code>tol</code></td> <td> <p>Numerical tolerance for checking periodicity.</p> </td> </tr> </table> "	FALSE
"gather"	"tidyr"	"Gather columns into key-value pairs."	"<p>Gather takes multiple columns and collapses into key-value pairs, duplicating all other columns as needed. You use <code>gather()</code> when you notice that you have columns that are not variables. </p>"	"<pre>gather(data, key, value, ..., na.rm = FALSE, convert = FALSE,<br />   factor_key = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>key, value</code></td> <td> <p>Names of key and value columns to create in output.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to gather. Use bare variable names. Select all variables between x and z with <code>x:z</code>, exclude y with <code>-y</code>. For more options, see the select documentation.</p> </td> </tr> <tr valign='top'> <td><code>na.rm</code></td> <td> <p>If <code>TRUE</code>, will remove rows from output where the value column in <code>NA</code>.</p> </td> </tr> <tr valign='top'> <td><code>convert</code></td> <td> <p>If <code>TRUE</code> will automatically run <code>type.convert</code> on the key column. This is useful if the column names are actually numeric, integer, or logical.</p> </td> </tr> <tr valign='top'> <td><code>factor_key</code></td> <td> <p>If <code>FALSE</code>, the default, the key values will be stored as a character vector. If <code>TRUE</code>, will be stored as a factor, which preserves the original ordering of the columns.</p> </td> </tr> </table> "	FALSE
"nest"	"tidyr"	"Nest repeated values in a list-variable."	"<p>There are many possible ways one could choose to nest columns inside a data frame. <code>nest()</code> creates a list of data frames containing all the nested variables: this seems to be the most useful form in practice. </p>"	"<pre>nest(data, ..., .key = data) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to nest. Use bare variable names. Select all variables between x and z with <code>x:z</code>, exclude y with <code>-y</code>. For more options, see the select documentation.</p> </td> </tr> <tr valign='top'> <td><code>.key</code></td> <td> <p>The name of the new column.</p> </td> </tr> </table> "	FALSE
"expand"	"tidyr"	"Expand data frame to include all combinations of values"	"<p><code>expand()</code> is often useful in conjunction with <code>left_join</code> if you want to convert implicit missing values to explicit missing values. Or you can use it in conjunction with <code>anti_join()</code> to figure out which combinations are missing. </p>"	"<pre>expand(data, ...)<br />crossing(...)<br />crossing_(x)<br />nesting(...)<br />nesting_(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to expand. </p> <p>To find all unique combinations of x, y and z, including those not found in the data, supply each variable as a separate argument. To find only the combinations that occur in the data, use nest: <code>expand(df, nesting(x, y, z))</code>. </p> <p>You can combine the two forms. For example, <code>expand(df, nesting(school_id, student_id), date)</code> would produce a row for every student for each date. </p> <p>For factors, the full set of levels (not just those that appear in the data) are used. For continuous variables, you may need to fill in values that don't appear in the data: to do so use expressions like <code>year = 2010:2020</code> or <code>year = full_seq(year)</code>. </p> <p>Length-zero (empty) elements are automatically dropped.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>For <code>nesting_</code> and <code>crossing_</code> a list of variables.</p> </td> </tr> </table> "	FALSE
"expand"	"tidyr"	"Expand data frame to include all combinations of values"	"<p><code>expand()</code> is often useful in conjunction with <code>left_join</code> if you want to convert implicit missing values to explicit missing values. Or you can use it in conjunction with <code>anti_join()</code> to figure out which combinations are missing. </p>"	"<pre>expand(data, ...)<br />crossing(...)<br />crossing_(x)<br />nesting(...)<br />nesting_(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to expand. </p> <p>To find all unique combinations of x, y and z, including those not found in the data, supply each variable as a separate argument. To find only the combinations that occur in the data, use nest: <code>expand(df, nesting(x, y, z))</code>. </p> <p>You can combine the two forms. For example, <code>expand(df, nesting(school_id, student_id), date)</code> would produce a row for every student for each date. </p> <p>For factors, the full set of levels (not just those that appear in the data) are used. For continuous variables, you may need to fill in values that don't appear in the data: to do so use expressions like <code>year = 2010:2020</code> or <code>year = full_seq(year)</code>. </p> <p>Length-zero (empty) elements are automatically dropped.</p> </td> </tr> <tr valign='top'> <td><code>x</code></td> <td> <p>For <code>nesting_</code> and <code>crossing_</code> a list of variables.</p> </td> </tr> </table> "	FALSE
"who"	"tidyr"	"World Health Organization TB data"	"<p>A subset of data from the World Health Organization Global Tuberculosis Report, and accompanying global populations. </p>"	"<pre>who<br />population </pre>"	NA	FALSE
"replace_na"	"tidyr"	"Replace missing values"	"<p>Replace missing values </p>"	"<pre>replace_na(data, replace = list(), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>replace</code></td> <td> <p>A named list given the value to replace <code>NA</code> with for each column.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments for methods. Currently unused.</p> </td> </tr> </table> "	FALSE
"separate"	"tidyr"	"Separate one column into multiple columns."	"<p>Given either regular expression or a vector of character positions, <code>separate()</code> turns a single character column into multiple columns. </p>"	"<pre>separate(data, col, into, sep = '[^[:alnum:]]+', remove = TRUE,<br />   convert = FALSE, extra = 'warn', fill = 'warn', ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>col</code></td> <td> <p>Bare column name.</p> </td> </tr> <tr valign='top'> <td><code>into</code></td> <td> <p>Names of new variables to create as character vector.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>Separator between columns. </p> <p>If character, is interpreted as a regular expression. The default value is a regular expression that matches any sequence of non-alphanumeric values. </p> <p>If numeric, interpreted as positions to split at. Positive values start at 1 at the far-left of the string; negative value start at -1 at the far-right of the string. The length of <code>sep</code> should be one less than <code>into</code>.</p> </td> </tr> <tr valign='top'> <td><code>remove</code></td> <td> <p>If <code>TRUE</code>, remove input column from output data frame.</p> </td> </tr> <tr valign='top'> <td><code>convert</code></td> <td> <p>If <code>TRUE</code>, will run <code>type.convert</code> with <code>as.is = TRUE</code> on new columns. This is useful if the component columns are integer, numeric or logical.</p> </td> </tr> <tr valign='top'> <td><code>extra</code></td> <td> <p>If <code>sep</code> is a character vector, this controls what happens when there are too many pieces. There are three valid options: </p><br /><ul> <li> <p> 'warn' (the default): emit a warning and drop extra values. </p> </li> <li> <p> 'drop': drop any extra values without a warning. </p> </li> <li> <p> 'merge': only splits at most <code>length(into)</code> times </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>fill</code></td> <td> <p>If <code>sep</code> is a character vector, this controls what happens when there are not enough pieces. There are three valid options: </p><br /><ul> <li> <p> 'warn' (the default): emit a warning and fill from the right </p> </li> <li> <p> 'right': fill with missing values on the right </p> </li> <li> <p> 'left': fill with missing values on the left </p> </li> </ul> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Defunct, will be removed in the next version of the package.</p> </td> </tr> </table> "	FALSE
"separate_rows"	"tidyr"	"Separate a collapsed column into multiple rows."	"<p>If a variable contains observations with multiple delimited values, this separates the values and places each one in its own row. </p>"	"<pre>separate_rows(data, ..., sep = '[^[:alnum:].]+', convert = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to separate. Use bare variable names. Select all variables between x and z with <code>x:z</code>, exclude y with <code>-y</code>. For more options, see the select documentation.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>Separator delimiting collapsed values.</p> </td> </tr> <tr valign='top'> <td><code>convert</code></td> <td> <p>If <code>TRUE</code>, will run <code>type.convert</code> with <code>as.is = TRUE</code> on new columns. This is useful if the component columns are integer, numeric or logical.</p> </td> </tr> </table> "	FALSE
"separate_rows_"	"tidyr"	"Standard-evaluation version of separate_rows."	"<p>This is a S3 generic. </p>"	"<pre>separate_rows_(data, cols, sep = '[^[:alnum:].]+', convert = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>cols</code></td> <td> <p>Name of columns that need to be separated.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>Separator delimiting collapsed values.</p> </td> </tr> <tr valign='top'> <td><code>convert</code></td> <td> <p>If <code>TRUE</code>, will run <code>type.convert</code> with <code>as.is = TRUE</code> on new columns. This is useful if the component columns are integer, numeric or logical.</p> </td> </tr> </table>"	FALSE
"smiths"	"tidyr"	"Some data about the Smith family."	"<p>A small demo dataset describing John and Mary Smith. </p>"	"<pre>smiths </pre>"	NA	FALSE
"spread"	"tidyr"	"Spread a key-value pair across multiple columns."	"<p>Spread a key-value pair across multiple columns. </p>"	"<pre>spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE,<br />   sep = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>key</code></td> <td> <p>The bare (unquoted) name of the column whose values will be used as column headings.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>The bare (unquoted) name of the column whose values will populate the cells.</p> </td> </tr> <tr valign='top'> <td><code>fill</code></td> <td> <p>If set, missing values will be replaced with this value. Note that there are two types of missingness in the input: explicit missing values (i.e. <code>NA</code>), and implicit missings, rows that simply aren't present. Both types of missing value will be replaced by <code>fill</code>.</p> </td> </tr> <tr valign='top'> <td><code>convert</code></td> <td> <p>If <code>TRUE</code>, <code>type.convert</code> with <code>asis = TRUE</code> will be run on each of the new columns. This is useful if the value column was a mix of variables that was coerced to a string. If the class of the value column was factor or date, note that will not be true of the new columns that are produced, which are coerced to character before type conversion.</p> </td> </tr> <tr valign='top'> <td><code>drop</code></td> <td> <p>If <code>FALSE</code>, will keep factor levels that don't appear in the data, filling in missing combinations with <code>fill</code>.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>If <code>NULL</code>, the column names will be taken from the values of <code>key</code> variable. If non-<code>NULL</code>, the column names will be given by '&lt;key_name&gt;&lt;sep&gt;&lt;key_value&gt;'.</p> </td> </tr> </table> "	FALSE
"table1"	"tidyr"	"Example tabular representations"	"<p>Data sets that demonstrate multiple ways to layout the same tabular data. </p>"	"<pre>table1<br />table2<br />table3<br />table4a<br />table4b<br />table5 </pre>"	NA	FALSE
"table1"	"tidyr"	"Example tabular representations"	"<p>Data sets that demonstrate multiple ways to layout the same tabular data. </p>"	"<pre>table1<br />table2<br />table3<br />table4a<br />table4b<br />table5 </pre>"	NA	FALSE
"table1"	"tidyr"	"Example tabular representations"	"<p>Data sets that demonstrate multiple ways to layout the same tabular data. </p>"	"<pre>table1<br />table2<br />table3<br />table4a<br />table4b<br />table5 </pre>"	NA	FALSE
"table1"	"tidyr"	"Example tabular representations"	"<p>Data sets that demonstrate multiple ways to layout the same tabular data. </p>"	"<pre>table1<br />table2<br />table3<br />table4a<br />table4b<br />table5 </pre>"	NA	FALSE
"table1"	"tidyr"	"Example tabular representations"	"<p>Data sets that demonstrate multiple ways to layout the same tabular data. </p>"	"<pre>table1<br />table2<br />table3<br />table4a<br />table4b<br />table5 </pre>"	NA	FALSE
"table1"	"tidyr"	"Example tabular representations"	"<p>Data sets that demonstrate multiple ways to layout the same tabular data. </p>"	"<pre>table1<br />table2<br />table3<br />table4a<br />table4b<br />table5 </pre>"	NA	FALSE
"unite"	"tidyr"	"Unite multiple columns into one."	"<p>Convenience function to paste together multiple columns into one. </p>"	"<pre>unite(data, col, ..., sep = '_', remove = TRUE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>col</code></td> <td> <p>(Bare) name of column to add</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to unite. Use bare variable names. Select all variables between x and z with <code>x:z</code>, exclude y with <code>-y</code>. For more options, see the select documentation.</p> </td> </tr> <tr valign='top'> <td><code>sep</code></td> <td> <p>Separator to use between values.</p> </td> </tr> <tr valign='top'> <td><code>remove</code></td> <td> <p>If <code>TRUE</code>, remove input columns from output data frame.</p> </td> </tr> </table> "	FALSE
"unnest"	"tidyr"	"Unnest a list column."	"<p>If you have a list-column, this makes each element of the list its own row. List-columns can either be atomic vectors or data frames. Each row must have the same number of entries. </p>"	"<pre>unnest(data, ..., .drop = NA, .id = NULL, .sep = NULL) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>data</code></td> <td> <p>A data frame.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Specification of columns to nest. Use bare variable names or functions of variables. If omitted, defaults to all list-cols.</p> </td> </tr> <tr valign='top'> <td><code>.drop</code></td> <td> <p>Should additional list columns be dropped? By default, <code>unnest</code> will drop them if unnesting the specified columns requires the rows to be duplicated.</p> </td> </tr> <tr valign='top'> <td><code>.id</code></td> <td> <p>Data frame idenfier - if supplied, will create a new column with name <code>.id</code>, giving a unique identifer. This is most useful if the list column is named.</p> </td> </tr> <tr valign='top'> <td><code>.sep</code></td> <td> <p>If non-<code>NULL</code>, the names of unnested data frame columns will combine the name of the original list-col with the names from nested data frame, separated by <code>.sep</code>.</p> </td> </tr> </table> "	FALSE
"who"	"tidyr"	"World Health Organization TB data"	"<p>A subset of data from the World Health Organization Global Tuberculosis Report, and accompanying global populations. </p>"	"<pre>who<br />population </pre>"	NA	FALSE
"as_list"	"xml2"	"Coerce xml nodes to a list."	"<p>This turns an XML document (or node or nodeset) into the equivalent R list. Note that this is <code>as_list()</code>, not <code>as.list()</code>: <code>lapply()</code> automatically calls <code>as.list()</code> on its inputs, so we can't override the default. </p>"	"<pre>as_list(x, ns = character(), ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Needed for compatibility with generic. Unused.</p> </td> </tr> </table> "	FALSE
"as_xml_document"	"xml2"	"Coerce a R list to xml nodes."	"<p>This turns an R list into the equivalent XML document. Not all R lists will produce valid XML, in particular there can only be one root node and all child nodes need to be named (or empty) lists. R attributes become XML attributes and R names become XML node names. </p>"	"<pre>as_xml_document(x, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Needed for compatibility with generic. Unused.</p> </td> </tr> </table> "	FALSE
"xml_structure"	"xml2"	"Show the structure of an html/xml document."	"<p>Show the structure of an html/xml document without displaying any of the values. This is useful if you want to get a high level view of the way a document is organised. Compared to <code>xml_structure</code>, <code>html_structure</code> prints the id and class attributes. </p>"	"<pre>xml_structure(x, indent = 2)<br />html_structure(x, indent = 2) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>HTML/XML document (or part there of)</p> </td> </tr> <tr valign='top'> <td><code>indent</code></td> <td> <p>Number of spaces to ident</p> </td> </tr> </table> "	FALSE
"read_xml"	"xml2"	"Read HTML or XML."	"<p>Read HTML or XML. </p>"	"<pre>read_xml(x, encoding = '', ..., as_html = FALSE, options = 'NOBLANKS')<br />read_html(x, encoding = '', ..., options = c('RECOVER', 'NOERROR',<br />   'NOBLANKS'))<br />## S3 method for class 'character' read_xml(x, encoding = '', ..., as_html = FALSE,<br />   options = 'NOBLANKS')<br />## S3 method for class 'raw' read_xml(x, encoding = '', base_url = '', ...,<br />   as_html = FALSE, options = 'NOBLANKS')<br />## S3 method for class 'connection' read_xml(x, encoding = '', n = 64 * 1024,<br />   verbose = FALSE, ..., base_url = '', as_html = FALSE,<br />   options = 'NOBLANKS') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A string, a connection, or a raw vector. </p> <p>A string can be either a path, a url or literal xml. Urls will be converted into connections either using <code>base::url</code> or, if installed, <code>curl::curl</code>. Local paths ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, <code>.zip</code> will be automatically uncompressed. </p> <p>If a connection, the complete connection is read into a raw vector before being parsed.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>Specify a default encoding for the document. Unless otherwise specified XML documents are assumed to be in UTF-8 or UTF-16. If the document is not UTF-8/16, and lacks an explicit encoding directive, this allows you to supply a default.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to methods.</p> </td> </tr> <tr valign='top'> <td><code>as_html</code></td> <td> <p>Optionally parse an xml file as if it's html.</p> </td> </tr> <tr valign='top'> <td><code>options</code></td> <td> <p>Set parsing options for the libxml2 parser. Zero of more of </p><br /><dl> <dt>RECOVER</dt> <dd> <p>recover on errors</p> </dd> <dt>NOENT</dt> <dd> <p>substitute entities</p> </dd> <dt>DTDLOAD</dt> <dd> <p>load the external subset</p> </dd> <dt>DTDATTR</dt> <dd> <p>default DTD attributes</p> </dd> <dt>DTDVALID</dt> <dd> <p>validate with the DTD</p> </dd> <dt>NOERROR</dt> <dd> <p>suppress error reports</p> </dd> <dt>NOWARNING</dt> <dd> <p>suppress warning reports</p> </dd> <dt>PEDANTIC</dt> <dd> <p>pedantic error reporting</p> </dd> <dt>NOBLANKS</dt> <dd> <p>remove blank nodes</p> </dd> <dt>SAX1</dt> <dd> <p>use the SAX1 interface internally</p> </dd> <dt>XINCLUDE</dt> <dd> <p>Implement XInclude substitition</p> </dd> <dt>NONET</dt> <dd> <p>Forbid network access</p> </dd> <dt>NODICT</dt> <dd> <p>Do not reuse the context dictionary</p> </dd> <dt>NSCLEAN</dt> <dd> <p>remove redundant namespaces declarations</p> </dd> <dt>NOCDATA</dt> <dd> <p>merge CDATA as text nodes</p> </dd> <dt>NOXINCNODE</dt> <dd> <p>do not generate XINCLUDE START/END nodes</p> </dd> <dt>COMPACT</dt> <dd> <p>compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)</p> </dd> <dt>OLD10</dt> <dd> <p>parse using XML-1.0 before update 5</p> </dd> <dt>NOBASEFIX</dt> <dd> <p>do not fixup XINCLUDE xml:base uris</p> </dd> <dt>HUGE</dt> <dd> <p>relax any hardcoded limit from the parser</p> </dd> <dt>OLDSAX</dt> <dd> <p>parse using SAX2 interface before 2.7.0</p> </dd> <dt>IGNORE_ENC</dt> <dd> <p>ignore internal document encoding hint</p> </dd> <dt>BIG_LINES</dt> <dd> <p>Store big lines numbers in text PSVI field</p> </dd> </dl> </td> </tr> <tr valign='top'> <td><code>base_url</code></td> <td> <p>When loading from a connection, raw vector or literal html/xml, this allows you to specify a base url for the document. Base urls are used to turn relative urls into absolute urls.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>If <code>file</code> is a connection, the number of bytes to read per iteration. Defaults to 64kb.</p> </td> </tr> <tr valign='top'> <td><code>verbose</code></td> <td> <p>When reading from a slow connection, this prints some output on every iteration so you know its working.</p> </td> </tr> </table> "	FALSE
"read_xml"	"xml2"	"Read HTML or XML."	"<p>Read HTML or XML. </p>"	"<pre>read_xml(x, encoding = '', ..., as_html = FALSE, options = 'NOBLANKS')<br />read_html(x, encoding = '', ..., options = c('RECOVER', 'NOERROR',<br />   'NOBLANKS'))<br />## S3 method for class 'character' read_xml(x, encoding = '', ..., as_html = FALSE,<br />   options = 'NOBLANKS')<br />## S3 method for class 'raw' read_xml(x, encoding = '', base_url = '', ...,<br />   as_html = FALSE, options = 'NOBLANKS')<br />## S3 method for class 'connection' read_xml(x, encoding = '', n = 64 * 1024,<br />   verbose = FALSE, ..., base_url = '', as_html = FALSE,<br />   options = 'NOBLANKS') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A string, a connection, or a raw vector. </p> <p>A string can be either a path, a url or literal xml. Urls will be converted into connections either using <code>base::url</code> or, if installed, <code>curl::curl</code>. Local paths ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, <code>.zip</code> will be automatically uncompressed. </p> <p>If a connection, the complete connection is read into a raw vector before being parsed.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>Specify a default encoding for the document. Unless otherwise specified XML documents are assumed to be in UTF-8 or UTF-16. If the document is not UTF-8/16, and lacks an explicit encoding directive, this allows you to supply a default.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to methods.</p> </td> </tr> <tr valign='top'> <td><code>as_html</code></td> <td> <p>Optionally parse an xml file as if it's html.</p> </td> </tr> <tr valign='top'> <td><code>options</code></td> <td> <p>Set parsing options for the libxml2 parser. Zero of more of </p><br /><dl> <dt>RECOVER</dt> <dd> <p>recover on errors</p> </dd> <dt>NOENT</dt> <dd> <p>substitute entities</p> </dd> <dt>DTDLOAD</dt> <dd> <p>load the external subset</p> </dd> <dt>DTDATTR</dt> <dd> <p>default DTD attributes</p> </dd> <dt>DTDVALID</dt> <dd> <p>validate with the DTD</p> </dd> <dt>NOERROR</dt> <dd> <p>suppress error reports</p> </dd> <dt>NOWARNING</dt> <dd> <p>suppress warning reports</p> </dd> <dt>PEDANTIC</dt> <dd> <p>pedantic error reporting</p> </dd> <dt>NOBLANKS</dt> <dd> <p>remove blank nodes</p> </dd> <dt>SAX1</dt> <dd> <p>use the SAX1 interface internally</p> </dd> <dt>XINCLUDE</dt> <dd> <p>Implement XInclude substitition</p> </dd> <dt>NONET</dt> <dd> <p>Forbid network access</p> </dd> <dt>NODICT</dt> <dd> <p>Do not reuse the context dictionary</p> </dd> <dt>NSCLEAN</dt> <dd> <p>remove redundant namespaces declarations</p> </dd> <dt>NOCDATA</dt> <dd> <p>merge CDATA as text nodes</p> </dd> <dt>NOXINCNODE</dt> <dd> <p>do not generate XINCLUDE START/END nodes</p> </dd> <dt>COMPACT</dt> <dd> <p>compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)</p> </dd> <dt>OLD10</dt> <dd> <p>parse using XML-1.0 before update 5</p> </dd> <dt>NOBASEFIX</dt> <dd> <p>do not fixup XINCLUDE xml:base uris</p> </dd> <dt>HUGE</dt> <dd> <p>relax any hardcoded limit from the parser</p> </dd> <dt>OLDSAX</dt> <dd> <p>parse using SAX2 interface before 2.7.0</p> </dd> <dt>IGNORE_ENC</dt> <dd> <p>ignore internal document encoding hint</p> </dd> <dt>BIG_LINES</dt> <dd> <p>Store big lines numbers in text PSVI field</p> </dd> </dl> </td> </tr> <tr valign='top'> <td><code>base_url</code></td> <td> <p>When loading from a connection, raw vector or literal html/xml, this allows you to specify a base url for the document. Base urls are used to turn relative urls into absolute urls.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>If <code>file</code> is a connection, the number of bytes to read per iteration. Defaults to 64kb.</p> </td> </tr> <tr valign='top'> <td><code>verbose</code></td> <td> <p>When reading from a slow connection, this prints some output on every iteration so you know its working.</p> </td> </tr> </table> "	FALSE
"read_xml"	"xml2"	"Read HTML or XML."	"<p>Read HTML or XML. </p>"	"<pre>read_xml(x, encoding = '', ..., as_html = FALSE, options = 'NOBLANKS')<br />read_html(x, encoding = '', ..., options = c('RECOVER', 'NOERROR',<br />   'NOBLANKS'))<br />## S3 method for class 'character' read_xml(x, encoding = '', ..., as_html = FALSE,<br />   options = 'NOBLANKS')<br />## S3 method for class 'raw' read_xml(x, encoding = '', base_url = '', ...,<br />   as_html = FALSE, options = 'NOBLANKS')<br />## S3 method for class 'connection' read_xml(x, encoding = '', n = 64 * 1024,<br />   verbose = FALSE, ..., base_url = '', as_html = FALSE,<br />   options = 'NOBLANKS') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A string, a connection, or a raw vector. </p> <p>A string can be either a path, a url or literal xml. Urls will be converted into connections either using <code>base::url</code> or, if installed, <code>curl::curl</code>. Local paths ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, <code>.zip</code> will be automatically uncompressed. </p> <p>If a connection, the complete connection is read into a raw vector before being parsed.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>Specify a default encoding for the document. Unless otherwise specified XML documents are assumed to be in UTF-8 or UTF-16. If the document is not UTF-8/16, and lacks an explicit encoding directive, this allows you to supply a default.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to methods.</p> </td> </tr> <tr valign='top'> <td><code>as_html</code></td> <td> <p>Optionally parse an xml file as if it's html.</p> </td> </tr> <tr valign='top'> <td><code>options</code></td> <td> <p>Set parsing options for the libxml2 parser. Zero of more of </p><br /><dl> <dt>RECOVER</dt> <dd> <p>recover on errors</p> </dd> <dt>NOENT</dt> <dd> <p>substitute entities</p> </dd> <dt>DTDLOAD</dt> <dd> <p>load the external subset</p> </dd> <dt>DTDATTR</dt> <dd> <p>default DTD attributes</p> </dd> <dt>DTDVALID</dt> <dd> <p>validate with the DTD</p> </dd> <dt>NOERROR</dt> <dd> <p>suppress error reports</p> </dd> <dt>NOWARNING</dt> <dd> <p>suppress warning reports</p> </dd> <dt>PEDANTIC</dt> <dd> <p>pedantic error reporting</p> </dd> <dt>NOBLANKS</dt> <dd> <p>remove blank nodes</p> </dd> <dt>SAX1</dt> <dd> <p>use the SAX1 interface internally</p> </dd> <dt>XINCLUDE</dt> <dd> <p>Implement XInclude substitition</p> </dd> <dt>NONET</dt> <dd> <p>Forbid network access</p> </dd> <dt>NODICT</dt> <dd> <p>Do not reuse the context dictionary</p> </dd> <dt>NSCLEAN</dt> <dd> <p>remove redundant namespaces declarations</p> </dd> <dt>NOCDATA</dt> <dd> <p>merge CDATA as text nodes</p> </dd> <dt>NOXINCNODE</dt> <dd> <p>do not generate XINCLUDE START/END nodes</p> </dd> <dt>COMPACT</dt> <dd> <p>compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)</p> </dd> <dt>OLD10</dt> <dd> <p>parse using XML-1.0 before update 5</p> </dd> <dt>NOBASEFIX</dt> <dd> <p>do not fixup XINCLUDE xml:base uris</p> </dd> <dt>HUGE</dt> <dd> <p>relax any hardcoded limit from the parser</p> </dd> <dt>OLDSAX</dt> <dd> <p>parse using SAX2 interface before 2.7.0</p> </dd> <dt>IGNORE_ENC</dt> <dd> <p>ignore internal document encoding hint</p> </dd> <dt>BIG_LINES</dt> <dd> <p>Store big lines numbers in text PSVI field</p> </dd> </dl> </td> </tr> <tr valign='top'> <td><code>base_url</code></td> <td> <p>When loading from a connection, raw vector or literal html/xml, this allows you to specify a base url for the document. Base urls are used to turn relative urls into absolute urls.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>If <code>file</code> is a connection, the number of bytes to read per iteration. Defaults to 64kb.</p> </td> </tr> <tr valign='top'> <td><code>verbose</code></td> <td> <p>When reading from a slow connection, this prints some output on every iteration so you know its working.</p> </td> </tr> </table> "	FALSE
"read_xml"	"xml2"	"Read HTML or XML."	"<p>Read HTML or XML. </p>"	"<pre>read_xml(x, encoding = '', ..., as_html = FALSE, options = 'NOBLANKS')<br />read_html(x, encoding = '', ..., options = c('RECOVER', 'NOERROR',<br />   'NOBLANKS'))<br />## S3 method for class 'character' read_xml(x, encoding = '', ..., as_html = FALSE,<br />   options = 'NOBLANKS')<br />## S3 method for class 'raw' read_xml(x, encoding = '', base_url = '', ...,<br />   as_html = FALSE, options = 'NOBLANKS')<br />## S3 method for class 'connection' read_xml(x, encoding = '', n = 64 * 1024,<br />   verbose = FALSE, ..., base_url = '', as_html = FALSE,<br />   options = 'NOBLANKS') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A string, a connection, or a raw vector. </p> <p>A string can be either a path, a url or literal xml. Urls will be converted into connections either using <code>base::url</code> or, if installed, <code>curl::curl</code>. Local paths ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, <code>.zip</code> will be automatically uncompressed. </p> <p>If a connection, the complete connection is read into a raw vector before being parsed.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>Specify a default encoding for the document. Unless otherwise specified XML documents are assumed to be in UTF-8 or UTF-16. If the document is not UTF-8/16, and lacks an explicit encoding directive, this allows you to supply a default.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to methods.</p> </td> </tr> <tr valign='top'> <td><code>as_html</code></td> <td> <p>Optionally parse an xml file as if it's html.</p> </td> </tr> <tr valign='top'> <td><code>options</code></td> <td> <p>Set parsing options for the libxml2 parser. Zero of more of </p><br /><dl> <dt>RECOVER</dt> <dd> <p>recover on errors</p> </dd> <dt>NOENT</dt> <dd> <p>substitute entities</p> </dd> <dt>DTDLOAD</dt> <dd> <p>load the external subset</p> </dd> <dt>DTDATTR</dt> <dd> <p>default DTD attributes</p> </dd> <dt>DTDVALID</dt> <dd> <p>validate with the DTD</p> </dd> <dt>NOERROR</dt> <dd> <p>suppress error reports</p> </dd> <dt>NOWARNING</dt> <dd> <p>suppress warning reports</p> </dd> <dt>PEDANTIC</dt> <dd> <p>pedantic error reporting</p> </dd> <dt>NOBLANKS</dt> <dd> <p>remove blank nodes</p> </dd> <dt>SAX1</dt> <dd> <p>use the SAX1 interface internally</p> </dd> <dt>XINCLUDE</dt> <dd> <p>Implement XInclude substitition</p> </dd> <dt>NONET</dt> <dd> <p>Forbid network access</p> </dd> <dt>NODICT</dt> <dd> <p>Do not reuse the context dictionary</p> </dd> <dt>NSCLEAN</dt> <dd> <p>remove redundant namespaces declarations</p> </dd> <dt>NOCDATA</dt> <dd> <p>merge CDATA as text nodes</p> </dd> <dt>NOXINCNODE</dt> <dd> <p>do not generate XINCLUDE START/END nodes</p> </dd> <dt>COMPACT</dt> <dd> <p>compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)</p> </dd> <dt>OLD10</dt> <dd> <p>parse using XML-1.0 before update 5</p> </dd> <dt>NOBASEFIX</dt> <dd> <p>do not fixup XINCLUDE xml:base uris</p> </dd> <dt>HUGE</dt> <dd> <p>relax any hardcoded limit from the parser</p> </dd> <dt>OLDSAX</dt> <dd> <p>parse using SAX2 interface before 2.7.0</p> </dd> <dt>IGNORE_ENC</dt> <dd> <p>ignore internal document encoding hint</p> </dd> <dt>BIG_LINES</dt> <dd> <p>Store big lines numbers in text PSVI field</p> </dd> </dl> </td> </tr> <tr valign='top'> <td><code>base_url</code></td> <td> <p>When loading from a connection, raw vector or literal html/xml, this allows you to specify a base url for the document. Base urls are used to turn relative urls into absolute urls.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>If <code>file</code> is a connection, the number of bytes to read per iteration. Defaults to 64kb.</p> </td> </tr> <tr valign='top'> <td><code>verbose</code></td> <td> <p>When reading from a slow connection, this prints some output on every iteration so you know its working.</p> </td> </tr> </table> "	FALSE
"read_xml"	"xml2"	"Read HTML or XML."	"<p>Read HTML or XML. </p>"	"<pre>read_xml(x, encoding = '', ..., as_html = FALSE, options = 'NOBLANKS')<br />read_html(x, encoding = '', ..., options = c('RECOVER', 'NOERROR',<br />   'NOBLANKS'))<br />## S3 method for class 'character' read_xml(x, encoding = '', ..., as_html = FALSE,<br />   options = 'NOBLANKS')<br />## S3 method for class 'raw' read_xml(x, encoding = '', base_url = '', ...,<br />   as_html = FALSE, options = 'NOBLANKS')<br />## S3 method for class 'connection' read_xml(x, encoding = '', n = 64 * 1024,<br />   verbose = FALSE, ..., base_url = '', as_html = FALSE,<br />   options = 'NOBLANKS') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A string, a connection, or a raw vector. </p> <p>A string can be either a path, a url or literal xml. Urls will be converted into connections either using <code>base::url</code> or, if installed, <code>curl::curl</code>. Local paths ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, <code>.zip</code> will be automatically uncompressed. </p> <p>If a connection, the complete connection is read into a raw vector before being parsed.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>Specify a default encoding for the document. Unless otherwise specified XML documents are assumed to be in UTF-8 or UTF-16. If the document is not UTF-8/16, and lacks an explicit encoding directive, this allows you to supply a default.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed on to methods.</p> </td> </tr> <tr valign='top'> <td><code>as_html</code></td> <td> <p>Optionally parse an xml file as if it's html.</p> </td> </tr> <tr valign='top'> <td><code>options</code></td> <td> <p>Set parsing options for the libxml2 parser. Zero of more of </p><br /><dl> <dt>RECOVER</dt> <dd> <p>recover on errors</p> </dd> <dt>NOENT</dt> <dd> <p>substitute entities</p> </dd> <dt>DTDLOAD</dt> <dd> <p>load the external subset</p> </dd> <dt>DTDATTR</dt> <dd> <p>default DTD attributes</p> </dd> <dt>DTDVALID</dt> <dd> <p>validate with the DTD</p> </dd> <dt>NOERROR</dt> <dd> <p>suppress error reports</p> </dd> <dt>NOWARNING</dt> <dd> <p>suppress warning reports</p> </dd> <dt>PEDANTIC</dt> <dd> <p>pedantic error reporting</p> </dd> <dt>NOBLANKS</dt> <dd> <p>remove blank nodes</p> </dd> <dt>SAX1</dt> <dd> <p>use the SAX1 interface internally</p> </dd> <dt>XINCLUDE</dt> <dd> <p>Implement XInclude substitition</p> </dd> <dt>NONET</dt> <dd> <p>Forbid network access</p> </dd> <dt>NODICT</dt> <dd> <p>Do not reuse the context dictionary</p> </dd> <dt>NSCLEAN</dt> <dd> <p>remove redundant namespaces declarations</p> </dd> <dt>NOCDATA</dt> <dd> <p>merge CDATA as text nodes</p> </dd> <dt>NOXINCNODE</dt> <dd> <p>do not generate XINCLUDE START/END nodes</p> </dd> <dt>COMPACT</dt> <dd> <p>compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)</p> </dd> <dt>OLD10</dt> <dd> <p>parse using XML-1.0 before update 5</p> </dd> <dt>NOBASEFIX</dt> <dd> <p>do not fixup XINCLUDE xml:base uris</p> </dd> <dt>HUGE</dt> <dd> <p>relax any hardcoded limit from the parser</p> </dd> <dt>OLDSAX</dt> <dd> <p>parse using SAX2 interface before 2.7.0</p> </dd> <dt>IGNORE_ENC</dt> <dd> <p>ignore internal document encoding hint</p> </dd> <dt>BIG_LINES</dt> <dd> <p>Store big lines numbers in text PSVI field</p> </dd> </dl> </td> </tr> <tr valign='top'> <td><code>base_url</code></td> <td> <p>When loading from a connection, raw vector or literal html/xml, this allows you to specify a base url for the document. Base urls are used to turn relative urls into absolute urls.</p> </td> </tr> <tr valign='top'> <td><code>n</code></td> <td> <p>If <code>file</code> is a connection, the number of bytes to read per iteration. Defaults to 64kb.</p> </td> </tr> <tr valign='top'> <td><code>verbose</code></td> <td> <p>When reading from a slow connection, this prints some output on every iteration so you know its working.</p> </td> </tr> </table> "	FALSE
"url_absolute"	"xml2"	"Convert between relative and absolute urls."	"<p>Convert between relative and absolute urls. </p>"	"<pre>url_absolute(x, base)<br />url_relative(x, base) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector of urls relative to that base</p> </td> </tr> <tr valign='top'> <td><code>base</code></td> <td> <p>A string giving a base url.</p> </td> </tr> </table> "	FALSE
"url_escape"	"xml2"	"Escape and unescape urls."	"<p>Escape and unescape urls. </p>"	"<pre>url_escape(x, reserved = '')<br />url_unescape(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector of urls.</p> </td> </tr> <tr valign='top'> <td><code>reserved</code></td> <td> <p>A string containing additional characters to avoid escaping.</p> </td> </tr> </table> "	FALSE
"url_parse"	"xml2"	"Parse a url into its component pieces."	"<p>Parse a url into its component pieces. </p>"	"<pre>url_parse(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A character vector of urls.</p> </td> </tr></table> "	FALSE
"url_absolute"	"xml2"	"Convert between relative and absolute urls."	"<p>Convert between relative and absolute urls. </p>"	"<pre>url_absolute(x, base)<br />url_relative(x, base) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector of urls relative to that base</p> </td> </tr> <tr valign='top'> <td><code>base</code></td> <td> <p>A string giving a base url.</p> </td> </tr> </table> "	FALSE
"url_escape"	"xml2"	"Escape and unescape urls."	"<p>Escape and unescape urls. </p>"	"<pre>url_escape(x, reserved = '')<br />url_unescape(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A character vector of urls.</p> </td> </tr> <tr valign='top'> <td><code>reserved</code></td> <td> <p>A string containing additional characters to avoid escaping.</p> </td> </tr> </table> "	FALSE
"write_xml"	"xml2"	"Write XML or HTML to disk."	"<p>This writes out both XML and normalised HTML. The default behavior will output the same format which was read. If you want to force output pass <code>option = 'as_xml'</code> or <code>option = 'as_html'</code> respectively. </p>"	"<pre>write_xml(x, file, ...)<br />## S3 method for class 'xml_document' write_xml(x, file, ..., options = 'format',<br />   encoding = 'UTF-8')<br />write_html(x, file, ...)<br />## S3 method for class 'xml_document' write_html(x, file, ..., options = 'format',<br />   encoding = 'UTF-8') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document or node to write to disk. It's not possible to save nodesets containing more than one node.</p> </td> </tr> <tr valign='top'> <td><code>file</code></td> <td> <p>Path to file or connection to write to.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments passed to methods.</p> </td> </tr> <tr valign='top'> <td><code>options</code></td> <td> <p>default: ‘format’. Zero or more of </p><br /><dl> <dt>format</dt> <dd> <p>Format output</p> </dd> <dt>no_declaration</dt> <dd> <p>Drop the XML declaration</p> </dd> <dt>no_empty_tags</dt> <dd> <p>Remove empty tags</p> </dd> <dt>no_xhtml</dt> <dd> <p>Disable XHTML1 rules</p> </dd> <dt>require_xhtml</dt> <dd> <p>Force XHTML1 rules</p> </dd> <dt>as_xml</dt> <dd> <p>Force XML output</p> </dd> <dt>as_html</dt> <dd> <p>Force HTML output</p> </dd> <dt>format_whitespace</dt> <dd> <p>Format with non-significant whitespace</p> </dd> </dl> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>The character encoding to use in the document. The default encoding is ‘UTF-8’. Available encodings are specified at <a href='http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding'>http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding</a>.</p> </td> </tr> </table> "	FALSE
"write_xml"	"xml2"	"Write XML or HTML to disk."	"<p>This writes out both XML and normalised HTML. The default behavior will output the same format which was read. If you want to force output pass <code>option = 'as_xml'</code> or <code>option = 'as_html'</code> respectively. </p>"	"<pre>write_xml(x, file, ...)<br />## S3 method for class 'xml_document' write_xml(x, file, ..., options = 'format',<br />   encoding = 'UTF-8')<br />write_html(x, file, ...)<br />## S3 method for class 'xml_document' write_html(x, file, ..., options = 'format',<br />   encoding = 'UTF-8') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document or node to write to disk. It's not possible to save nodesets containing more than one node.</p> </td> </tr> <tr valign='top'> <td><code>file</code></td> <td> <p>Path to file or connection to write to.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments passed to methods.</p> </td> </tr> <tr valign='top'> <td><code>options</code></td> <td> <p>default: ‘format’. Zero or more of </p><br /><dl> <dt>format</dt> <dd> <p>Format output</p> </dd> <dt>no_declaration</dt> <dd> <p>Drop the XML declaration</p> </dd> <dt>no_empty_tags</dt> <dd> <p>Remove empty tags</p> </dd> <dt>no_xhtml</dt> <dd> <p>Disable XHTML1 rules</p> </dd> <dt>require_xhtml</dt> <dd> <p>Force XHTML1 rules</p> </dd> <dt>as_xml</dt> <dd> <p>Force XML output</p> </dd> <dt>as_html</dt> <dd> <p>Force HTML output</p> </dd> <dt>format_whitespace</dt> <dd> <p>Format with non-significant whitespace</p> </dd> </dl> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>The character encoding to use in the document. The default encoding is ‘UTF-8’. Available encodings are specified at <a href='http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding'>http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding</a>.</p> </td> </tr> </table> "	FALSE
"write_xml"	"xml2"	"Write XML or HTML to disk."	"<p>This writes out both XML and normalised HTML. The default behavior will output the same format which was read. If you want to force output pass <code>option = 'as_xml'</code> or <code>option = 'as_html'</code> respectively. </p>"	"<pre>write_xml(x, file, ...)<br />## S3 method for class 'xml_document' write_xml(x, file, ..., options = 'format',<br />   encoding = 'UTF-8')<br />write_html(x, file, ...)<br />## S3 method for class 'xml_document' write_html(x, file, ..., options = 'format',<br />   encoding = 'UTF-8') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document or node to write to disk. It's not possible to save nodesets containing more than one node.</p> </td> </tr> <tr valign='top'> <td><code>file</code></td> <td> <p>Path to file or connection to write to.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments passed to methods.</p> </td> </tr> <tr valign='top'> <td><code>options</code></td> <td> <p>default: ‘format’. Zero or more of </p><br /><dl> <dt>format</dt> <dd> <p>Format output</p> </dd> <dt>no_declaration</dt> <dd> <p>Drop the XML declaration</p> </dd> <dt>no_empty_tags</dt> <dd> <p>Remove empty tags</p> </dd> <dt>no_xhtml</dt> <dd> <p>Disable XHTML1 rules</p> </dd> <dt>require_xhtml</dt> <dd> <p>Force XHTML1 rules</p> </dd> <dt>as_xml</dt> <dd> <p>Force XML output</p> </dd> <dt>as_html</dt> <dd> <p>Force HTML output</p> </dd> <dt>format_whitespace</dt> <dd> <p>Format with non-significant whitespace</p> </dd> </dl> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>The character encoding to use in the document. The default encoding is ‘UTF-8’. Available encodings are specified at <a href='http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding'>http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding</a>.</p> </td> </tr> </table> "	FALSE
"write_xml"	"xml2"	"Write XML or HTML to disk."	"<p>This writes out both XML and normalised HTML. The default behavior will output the same format which was read. If you want to force output pass <code>option = 'as_xml'</code> or <code>option = 'as_html'</code> respectively. </p>"	"<pre>write_xml(x, file, ...)<br />## S3 method for class 'xml_document' write_xml(x, file, ..., options = 'format',<br />   encoding = 'UTF-8')<br />write_html(x, file, ...)<br />## S3 method for class 'xml_document' write_html(x, file, ..., options = 'format',<br />   encoding = 'UTF-8') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document or node to write to disk. It's not possible to save nodesets containing more than one node.</p> </td> </tr> <tr valign='top'> <td><code>file</code></td> <td> <p>Path to file or connection to write to.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>additional arguments passed to methods.</p> </td> </tr> <tr valign='top'> <td><code>options</code></td> <td> <p>default: ‘format’. Zero or more of </p><br /><dl> <dt>format</dt> <dd> <p>Format output</p> </dd> <dt>no_declaration</dt> <dd> <p>Drop the XML declaration</p> </dd> <dt>no_empty_tags</dt> <dd> <p>Remove empty tags</p> </dd> <dt>no_xhtml</dt> <dd> <p>Disable XHTML1 rules</p> </dd> <dt>require_xhtml</dt> <dd> <p>Force XHTML1 rules</p> </dd> <dt>as_xml</dt> <dd> <p>Force XML output</p> </dd> <dt>as_html</dt> <dd> <p>Force HTML output</p> </dd> <dt>format_whitespace</dt> <dd> <p>Format with non-significant whitespace</p> </dd> </dl> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>The character encoding to use in the document. The default encoding is ‘UTF-8’. Available encodings are specified at <a href='http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding'>http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding</a>.</p> </td> </tr> </table> "	FALSE
"xml_replace"	"xml2"	"Modify a tree by inserting, replacing or removing nodes"	"<p><code>xml_add_sibling()</code> and <code>xml_add_child()</code> are used to insert a node as a sibling or a child. <code>xml_add_parent()</code> adds a new parent in between the input node and the current parent. <code>xml_replace()</code> replaces an existing node with a new node. <code>xml_remove()</code> removes a node from the tree. </p>"	"<pre>xml_replace(.x, .value, ..., .copy = TRUE)<br />xml_add_sibling(.x, .value, ..., .where = c('after', 'before'),<br />   .copy = TRUE)<br />xml_add_child(.x, .value, ..., .where = length(xml_children(.x)),<br />   .copy = TRUE)<br />xml_add_parent(.x, .value, ...)<br />xml_remove(.x, free = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>a document, node or nodeset.</p> </td> </tr> <tr valign='top'> <td><code>.value</code></td> <td> <p>node or nodeset to insert.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If named attributes or namespaces to set on the node, if unnamed text to assign to the node.</p> </td> </tr> <tr valign='top'> <td><code>.copy</code></td> <td> <p>whether to copy the <code>.value</code> before replacing. If this is <code>FALSE</code> then the node will be moved from it's current location.</p> </td> </tr> <tr valign='top'> <td><code>.where</code></td> <td> <p>to add thenew node, for <code>xml_add_child</code> the position after which to add, use <code>0</code> for the first child. For <code>xml_add_sibling</code> either ‘'befeore'’ or ‘'after'’ indicating if the new node should be before or after <code>.x</code>.</p> </td> </tr> <tr valign='top'> <td><code>free</code></td> <td> <p>When removing the node also free the memory used for that node. Note if you use this option you cannot use any existing objects pointing to the node or its children, it is likely to crash R or return garbage.</p> </td> </tr> </table> "	FALSE
"xml_replace"	"xml2"	"Modify a tree by inserting, replacing or removing nodes"	"<p><code>xml_add_sibling()</code> and <code>xml_add_child()</code> are used to insert a node as a sibling or a child. <code>xml_add_parent()</code> adds a new parent in between the input node and the current parent. <code>xml_replace()</code> replaces an existing node with a new node. <code>xml_remove()</code> removes a node from the tree. </p>"	"<pre>xml_replace(.x, .value, ..., .copy = TRUE)<br />xml_add_sibling(.x, .value, ..., .where = c('after', 'before'),<br />   .copy = TRUE)<br />xml_add_child(.x, .value, ..., .where = length(xml_children(.x)),<br />   .copy = TRUE)<br />xml_add_parent(.x, .value, ...)<br />xml_remove(.x, free = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>a document, node or nodeset.</p> </td> </tr> <tr valign='top'> <td><code>.value</code></td> <td> <p>node or nodeset to insert.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If named attributes or namespaces to set on the node, if unnamed text to assign to the node.</p> </td> </tr> <tr valign='top'> <td><code>.copy</code></td> <td> <p>whether to copy the <code>.value</code> before replacing. If this is <code>FALSE</code> then the node will be moved from it's current location.</p> </td> </tr> <tr valign='top'> <td><code>.where</code></td> <td> <p>to add thenew node, for <code>xml_add_child</code> the position after which to add, use <code>0</code> for the first child. For <code>xml_add_sibling</code> either ‘'befeore'’ or ‘'after'’ indicating if the new node should be before or after <code>.x</code>.</p> </td> </tr> <tr valign='top'> <td><code>free</code></td> <td> <p>When removing the node also free the memory used for that node. Note if you use this option you cannot use any existing objects pointing to the node or its children, it is likely to crash R or return garbage.</p> </td> </tr> </table> "	FALSE
"xml_replace"	"xml2"	"Modify a tree by inserting, replacing or removing nodes"	"<p><code>xml_add_sibling()</code> and <code>xml_add_child()</code> are used to insert a node as a sibling or a child. <code>xml_add_parent()</code> adds a new parent in between the input node and the current parent. <code>xml_replace()</code> replaces an existing node with a new node. <code>xml_remove()</code> removes a node from the tree. </p>"	"<pre>xml_replace(.x, .value, ..., .copy = TRUE)<br />xml_add_sibling(.x, .value, ..., .where = c('after', 'before'),<br />   .copy = TRUE)<br />xml_add_child(.x, .value, ..., .where = length(xml_children(.x)),<br />   .copy = TRUE)<br />xml_add_parent(.x, .value, ...)<br />xml_remove(.x, free = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>a document, node or nodeset.</p> </td> </tr> <tr valign='top'> <td><code>.value</code></td> <td> <p>node or nodeset to insert.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If named attributes or namespaces to set on the node, if unnamed text to assign to the node.</p> </td> </tr> <tr valign='top'> <td><code>.copy</code></td> <td> <p>whether to copy the <code>.value</code> before replacing. If this is <code>FALSE</code> then the node will be moved from it's current location.</p> </td> </tr> <tr valign='top'> <td><code>.where</code></td> <td> <p>to add thenew node, for <code>xml_add_child</code> the position after which to add, use <code>0</code> for the first child. For <code>xml_add_sibling</code> either ‘'befeore'’ or ‘'after'’ indicating if the new node should be before or after <code>.x</code>.</p> </td> </tr> <tr valign='top'> <td><code>free</code></td> <td> <p>When removing the node also free the memory used for that node. Note if you use this option you cannot use any existing objects pointing to the node or its children, it is likely to crash R or return garbage.</p> </td> </tr> </table> "	FALSE
"xml_attr"	"xml2"	"Retrieve an attribute."	"<p><code>xml_attrs()</code> retrieves all attributes values as a named character vector, <code>xml_attrs() &lt;-</code> or <code>xml_set_attrs()</code> sets all attribute values. <code>xml_attr()</code> retrieves the value of single attribute and <code>xml_attr() &lt;-</code> or <code>xml_set_attr()</code> modifies its value. If the attribute doesn't exist, it will return <code>default</code>, which defaults to <code>NA</code>. <code>xml_has_attr()</code> tests if an attribute is present. </p>"	"<pre>xml_attr(x, attr, ns = character(), default = NA_character_)<br />xml_has_attr(x, attr, ns = character())<br />xml_attrs(x, ns = character())<br />xml_attr(x, attr, ns = character()) &lt;- value<br />xml_set_attr(x, attr, value, ns = character())<br />xml_attrs(x, ns = character()) &lt;- value<br />xml_set_attrs(x, value, ns = character()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>attr</code></td> <td> <p>Name of attribute to extract.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>Default value to use when attribute is not present.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector of new value.</p> </td> </tr> </table> "	FALSE
"xml_attr"	"xml2"	"Retrieve an attribute."	"<p><code>xml_attrs()</code> retrieves all attributes values as a named character vector, <code>xml_attrs() &lt;-</code> or <code>xml_set_attrs()</code> sets all attribute values. <code>xml_attr()</code> retrieves the value of single attribute and <code>xml_attr() &lt;-</code> or <code>xml_set_attr()</code> modifies its value. If the attribute doesn't exist, it will return <code>default</code>, which defaults to <code>NA</code>. <code>xml_has_attr()</code> tests if an attribute is present. </p>"	"<pre>xml_attr(x, attr, ns = character(), default = NA_character_)<br />xml_has_attr(x, attr, ns = character())<br />xml_attrs(x, ns = character())<br />xml_attr(x, attr, ns = character()) &lt;- value<br />xml_set_attr(x, attr, value, ns = character())<br />xml_attrs(x, ns = character()) &lt;- value<br />xml_set_attrs(x, value, ns = character()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>attr</code></td> <td> <p>Name of attribute to extract.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>Default value to use when attribute is not present.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector of new value.</p> </td> </tr> </table> "	FALSE
"xml_attr"	"xml2"	"Retrieve an attribute."	"<p><code>xml_attrs()</code> retrieves all attributes values as a named character vector, <code>xml_attrs() &lt;-</code> or <code>xml_set_attrs()</code> sets all attribute values. <code>xml_attr()</code> retrieves the value of single attribute and <code>xml_attr() &lt;-</code> or <code>xml_set_attr()</code> modifies its value. If the attribute doesn't exist, it will return <code>default</code>, which defaults to <code>NA</code>. <code>xml_has_attr()</code> tests if an attribute is present. </p>"	"<pre>xml_attr(x, attr, ns = character(), default = NA_character_)<br />xml_has_attr(x, attr, ns = character())<br />xml_attrs(x, ns = character())<br />xml_attr(x, attr, ns = character()) &lt;- value<br />xml_set_attr(x, attr, value, ns = character())<br />xml_attrs(x, ns = character()) &lt;- value<br />xml_set_attrs(x, value, ns = character()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>attr</code></td> <td> <p>Name of attribute to extract.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>Default value to use when attribute is not present.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector of new value.</p> </td> </tr> </table> "	FALSE
"xml_attr"	"xml2"	"Retrieve an attribute."	"<p><code>xml_attrs()</code> retrieves all attributes values as a named character vector, <code>xml_attrs() &lt;-</code> or <code>xml_set_attrs()</code> sets all attribute values. <code>xml_attr()</code> retrieves the value of single attribute and <code>xml_attr() &lt;-</code> or <code>xml_set_attr()</code> modifies its value. If the attribute doesn't exist, it will return <code>default</code>, which defaults to <code>NA</code>. <code>xml_has_attr()</code> tests if an attribute is present. </p>"	"<pre>xml_attr(x, attr, ns = character(), default = NA_character_)<br />xml_has_attr(x, attr, ns = character())<br />xml_attrs(x, ns = character())<br />xml_attr(x, attr, ns = character()) &lt;- value<br />xml_set_attr(x, attr, value, ns = character())<br />xml_attrs(x, ns = character()) &lt;- value<br />xml_set_attrs(x, value, ns = character()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>attr</code></td> <td> <p>Name of attribute to extract.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>Default value to use when attribute is not present.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector of new value.</p> </td> </tr> </table> "	FALSE
"xml_cdata"	"xml2"	"Construct a cdata node"	"<p>Construct a cdata node </p>"	"<pre>xml_cdata(content) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>content</code></td> <td> <p>The CDATA content, does not include <code>&lt;![CDATA[</code></p> </td> </tr></table> "	FALSE
"xml_children"	"xml2"	"Navigate around the family tree."	"<p><code>xml_children</code> returns only elements, <code>xml_contents</code> returns all nodes. <code>xml_length</code> returns the number of children. <code>xml_parent</code> returns the parent node, <code>xml_parents</code> returns all parents up to the root. <code>xml_siblings</code> returns all nodes at the same level. <code>xml_child</code> makes it easy to specify a specific child to return. </p>"	"<pre>xml_children(x)<br />xml_child(x, search = 1, ns = xml_ns(x))<br />xml_contents(x)<br />xml_parents(x)<br />xml_siblings(x)<br />xml_parent(x)<br />xml_length(x, only_elements = TRUE)<br />xml_root(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>search</code></td> <td> <p>For <code>xml_child</code>, either the child number to return (by position), or the name of the child node to return. If there are multiple child nodes with the same name, the first will be returned</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>only_elements</code></td> <td> <p>For <code>xml_length</code>, should it count all children, or just children that are elements (the default)?</p> </td> </tr> </table> "	FALSE
"xml_children"	"xml2"	"Navigate around the family tree."	"<p><code>xml_children</code> returns only elements, <code>xml_contents</code> returns all nodes. <code>xml_length</code> returns the number of children. <code>xml_parent</code> returns the parent node, <code>xml_parents</code> returns all parents up to the root. <code>xml_siblings</code> returns all nodes at the same level. <code>xml_child</code> makes it easy to specify a specific child to return. </p>"	"<pre>xml_children(x)<br />xml_child(x, search = 1, ns = xml_ns(x))<br />xml_contents(x)<br />xml_parents(x)<br />xml_siblings(x)<br />xml_parent(x)<br />xml_length(x, only_elements = TRUE)<br />xml_root(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>search</code></td> <td> <p>For <code>xml_child</code>, either the child number to return (by position), or the name of the child node to return. If there are multiple child nodes with the same name, the first will be returned</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>only_elements</code></td> <td> <p>For <code>xml_length</code>, should it count all children, or just children that are elements (the default)?</p> </td> </tr> </table> "	FALSE
"xml_comment"	"xml2"	"Construct a comment node"	"<p>Construct a comment node </p>"	"<pre>xml_comment(content) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>content</code></td> <td> <p>The comment content</p> </td> </tr></table> "	FALSE
"xml_children"	"xml2"	"Navigate around the family tree."	"<p><code>xml_children</code> returns only elements, <code>xml_contents</code> returns all nodes. <code>xml_length</code> returns the number of children. <code>xml_parent</code> returns the parent node, <code>xml_parents</code> returns all parents up to the root. <code>xml_siblings</code> returns all nodes at the same level. <code>xml_child</code> makes it easy to specify a specific child to return. </p>"	"<pre>xml_children(x)<br />xml_child(x, search = 1, ns = xml_ns(x))<br />xml_contents(x)<br />xml_parents(x)<br />xml_siblings(x)<br />xml_parent(x)<br />xml_length(x, only_elements = TRUE)<br />xml_root(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>search</code></td> <td> <p>For <code>xml_child</code>, either the child number to return (by position), or the name of the child node to return. If there are multiple child nodes with the same name, the first will be returned</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>only_elements</code></td> <td> <p>For <code>xml_length</code>, should it count all children, or just children that are elements (the default)?</p> </td> </tr> </table> "	FALSE
"xml_text"	"xml2"	"Extract or modify the text"	"<p><code>xml_text</code> returns a character vector, <code>xml_double</code> returns a numeric vector, <code>xml_integer</code> returns an integer vector. </p>"	"<pre>xml_text(x, trim = FALSE)<br />xml_text(x) &lt;- value<br />xml_set_text(x, value)<br />xml_double(x)<br />xml_integer(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> will trim leading and trailing spaces.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector with replacement text.</p> </td> </tr> </table> "	FALSE
"xml_dtd"	"xml2"	"Construct a document type definition"	"<p>This is used to create simple document type definitions. If you need to create a more complicated definition with internal subsets it is recommended to parse a string directly with <code>read_xml()</code>. </p>"	"<pre>xml_dtd(name = '', external_id = '', system_id = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>name</code></td> <td> <p>The name of the declaration</p> </td> </tr> <tr valign='top'> <td><code>external_id</code></td> <td> <p>The external ID of the declaration</p> </td> </tr> <tr valign='top'> <td><code>system_id</code></td> <td> <p>The system ID of the declaration</p> </td> </tr> </table> "	FALSE
"xml_find_all"	"xml2"	"Find nodes that match an xpath expression."	"<p>Xpath is like regular expressions for trees - it's worth learning if you're trying to extract nodes from arbitrary locations in a document. Use <code>xml_find_all</code> to find all matches - if there's no match you'll get an empty result. Use <code>xml_find_first</code> to find a specific match - if there's no match you'll get an <code>xml_missing</code> node. </p>"	"<pre>xml_find_all(x, xpath, ns = xml_ns(x))<br />xml_find_first(x, xpath, ns = xml_ns(x))<br />xml_find_num(x, xpath, ns = xml_ns(x))<br />xml_find_chr(x, xpath, ns = xml_ns(x))<br />xml_find_lgl(x, xpath, ns = xml_ns(x)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>xpath</code></td> <td> <p>A string containing a xpath (1.0) expression.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> </table> "	FALSE
"xml_find_all"	"xml2"	"Find nodes that match an xpath expression."	"<p>Xpath is like regular expressions for trees - it's worth learning if you're trying to extract nodes from arbitrary locations in a document. Use <code>xml_find_all</code> to find all matches - if there's no match you'll get an empty result. Use <code>xml_find_first</code> to find a specific match - if there's no match you'll get an <code>xml_missing</code> node. </p>"	"<pre>xml_find_all(x, xpath, ns = xml_ns(x))<br />xml_find_first(x, xpath, ns = xml_ns(x))<br />xml_find_num(x, xpath, ns = xml_ns(x))<br />xml_find_chr(x, xpath, ns = xml_ns(x))<br />xml_find_lgl(x, xpath, ns = xml_ns(x)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>xpath</code></td> <td> <p>A string containing a xpath (1.0) expression.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> </table> "	FALSE
"xml_find_all"	"xml2"	"Find nodes that match an xpath expression."	"<p>Xpath is like regular expressions for trees - it's worth learning if you're trying to extract nodes from arbitrary locations in a document. Use <code>xml_find_all</code> to find all matches - if there's no match you'll get an empty result. Use <code>xml_find_first</code> to find a specific match - if there's no match you'll get an <code>xml_missing</code> node. </p>"	"<pre>xml_find_all(x, xpath, ns = xml_ns(x))<br />xml_find_first(x, xpath, ns = xml_ns(x))<br />xml_find_num(x, xpath, ns = xml_ns(x))<br />xml_find_chr(x, xpath, ns = xml_ns(x))<br />xml_find_lgl(x, xpath, ns = xml_ns(x)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>xpath</code></td> <td> <p>A string containing a xpath (1.0) expression.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> </table> "	FALSE
"xml_find_all"	"xml2"	"Find nodes that match an xpath expression."	"<p>Xpath is like regular expressions for trees - it's worth learning if you're trying to extract nodes from arbitrary locations in a document. Use <code>xml_find_all</code> to find all matches - if there's no match you'll get an empty result. Use <code>xml_find_first</code> to find a specific match - if there's no match you'll get an <code>xml_missing</code> node. </p>"	"<pre>xml_find_all(x, xpath, ns = xml_ns(x))<br />xml_find_first(x, xpath, ns = xml_ns(x))<br />xml_find_num(x, xpath, ns = xml_ns(x))<br />xml_find_chr(x, xpath, ns = xml_ns(x))<br />xml_find_lgl(x, xpath, ns = xml_ns(x)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>xpath</code></td> <td> <p>A string containing a xpath (1.0) expression.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> </table> "	FALSE
"xml_find_all"	"xml2"	"Find nodes that match an xpath expression."	"<p>Xpath is like regular expressions for trees - it's worth learning if you're trying to extract nodes from arbitrary locations in a document. Use <code>xml_find_all</code> to find all matches - if there's no match you'll get an empty result. Use <code>xml_find_first</code> to find a specific match - if there's no match you'll get an <code>xml_missing</code> node. </p>"	"<pre>xml_find_all(x, xpath, ns = xml_ns(x))<br />xml_find_first(x, xpath, ns = xml_ns(x))<br />xml_find_num(x, xpath, ns = xml_ns(x))<br />xml_find_chr(x, xpath, ns = xml_ns(x))<br />xml_find_lgl(x, xpath, ns = xml_ns(x)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>xpath</code></td> <td> <p>A string containing a xpath (1.0) expression.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> </table> "	FALSE
"xml_find_all"	"xml2"	"Find nodes that match an xpath expression."	"<p>Xpath is like regular expressions for trees - it's worth learning if you're trying to extract nodes from arbitrary locations in a document. Use <code>xml_find_all</code> to find all matches - if there's no match you'll get an empty result. Use <code>xml_find_first</code> to find a specific match - if there's no match you'll get an <code>xml_missing</code> node. </p>"	"<pre>xml_find_all(x, xpath, ns = xml_ns(x))<br />xml_find_first(x, xpath, ns = xml_ns(x))<br />xml_find_num(x, xpath, ns = xml_ns(x))<br />xml_find_chr(x, xpath, ns = xml_ns(x))<br />xml_find_lgl(x, xpath, ns = xml_ns(x)) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>xpath</code></td> <td> <p>A string containing a xpath (1.0) expression.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> </table> "	FALSE
"xml_attr"	"xml2"	"Retrieve an attribute."	"<p><code>xml_attrs()</code> retrieves all attributes values as a named character vector, <code>xml_attrs() &lt;-</code> or <code>xml_set_attrs()</code> sets all attribute values. <code>xml_attr()</code> retrieves the value of single attribute and <code>xml_attr() &lt;-</code> or <code>xml_set_attr()</code> modifies its value. If the attribute doesn't exist, it will return <code>default</code>, which defaults to <code>NA</code>. <code>xml_has_attr()</code> tests if an attribute is present. </p>"	"<pre>xml_attr(x, attr, ns = character(), default = NA_character_)<br />xml_has_attr(x, attr, ns = character())<br />xml_attrs(x, ns = character())<br />xml_attr(x, attr, ns = character()) &lt;- value<br />xml_set_attr(x, attr, value, ns = character())<br />xml_attrs(x, ns = character()) &lt;- value<br />xml_set_attrs(x, value, ns = character()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>attr</code></td> <td> <p>Name of attribute to extract.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>Default value to use when attribute is not present.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector of new value.</p> </td> </tr> </table> "	FALSE
"xml_text"	"xml2"	"Extract or modify the text"	"<p><code>xml_text</code> returns a character vector, <code>xml_double</code> returns a numeric vector, <code>xml_integer</code> returns an integer vector. </p>"	"<pre>xml_text(x, trim = FALSE)<br />xml_text(x) &lt;- value<br />xml_set_text(x, value)<br />xml_double(x)<br />xml_integer(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> will trim leading and trailing spaces.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector with replacement text.</p> </td> </tr> </table> "	FALSE
"xml_children"	"xml2"	"Navigate around the family tree."	"<p><code>xml_children</code> returns only elements, <code>xml_contents</code> returns all nodes. <code>xml_length</code> returns the number of children. <code>xml_parent</code> returns the parent node, <code>xml_parents</code> returns all parents up to the root. <code>xml_siblings</code> returns all nodes at the same level. <code>xml_child</code> makes it easy to specify a specific child to return. </p>"	"<pre>xml_children(x)<br />xml_child(x, search = 1, ns = xml_ns(x))<br />xml_contents(x)<br />xml_parents(x)<br />xml_siblings(x)<br />xml_parent(x)<br />xml_length(x, only_elements = TRUE)<br />xml_root(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>search</code></td> <td> <p>For <code>xml_child</code>, either the child number to return (by position), or the name of the child node to return. If there are multiple child nodes with the same name, the first will be returned</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>only_elements</code></td> <td> <p>For <code>xml_length</code>, should it count all children, or just children that are elements (the default)?</p> </td> </tr> </table> "	FALSE
"xml_name"	"xml2"	"The (tag) name of an xml element."	"<p>The (tag) name of an xml element. </p> <p>Modify the (tag) name of an element </p>"	"<pre>xml_name(x, ns = character())<br />xml_name(x, ns = character()) &lt;- value<br />xml_set_name(x, value, ns = character()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a character vector with replacement name.</p> </td> </tr> </table> "	FALSE
"xml_name"	"xml2"	"The (tag) name of an xml element."	"<p>The (tag) name of an xml element. </p> <p>Modify the (tag) name of an element </p>"	"<pre>xml_name(x, ns = character())<br />xml_name(x, ns = character()) &lt;- value<br />xml_set_name(x, value, ns = character()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a character vector with replacement name.</p> </td> </tr> </table> "	FALSE
"xml_new_document"	"xml2"	"Create a new document, possibly with a root node"	"<p><code>xml_new_document</code> creates only a new document without a root node. In most cases you should instead use <code>xml_new_root</code>, which creates a new document and assigns the root node in one step. </p>"	"<pre>xml_new_document(version = '1.0', encoding = 'UTF-8')<br />xml_new_root(.value, ..., .copy = inherits(.value, 'xml_node'),<br />   .version = '1.0', .encoding = 'UTF-8') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>version</code></td> <td> <p>The version number of the document.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>The character encoding to use in the document. The default encoding is ‘UTF-8’. Available encodings are specified at <a href='http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding'>http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding</a>.</p> </td> </tr> <tr valign='top'> <td><code>.value</code></td> <td> <p>node or nodeset to insert.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If named attributes or namespaces to set on the node, if unnamed text to assign to the node.</p> </td> </tr> <tr valign='top'> <td><code>.copy</code></td> <td> <p>whether to copy the <code>.value</code> before replacing. If this is <code>FALSE</code> then the node will be moved from it's current location.</p> </td> </tr> <tr valign='top'> <td><code>.version</code></td> <td> <p>The version number of the document, passed to <code>xml_new_document(version)</code>.</p> </td> </tr> <tr valign='top'> <td><code>.encoding</code></td> <td> <p>The encoding of the document, passed to <code>xml_new_document(encoding)</code>.</p> </td> </tr> </table> "	FALSE
"xml_new_document"	"xml2"	"Create a new document, possibly with a root node"	"<p><code>xml_new_document</code> creates only a new document without a root node. In most cases you should instead use <code>xml_new_root</code>, which creates a new document and assigns the root node in one step. </p>"	"<pre>xml_new_document(version = '1.0', encoding = 'UTF-8')<br />xml_new_root(.value, ..., .copy = inherits(.value, 'xml_node'),<br />   .version = '1.0', .encoding = 'UTF-8') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>version</code></td> <td> <p>The version number of the document.</p> </td> </tr> <tr valign='top'> <td><code>encoding</code></td> <td> <p>The character encoding to use in the document. The default encoding is ‘UTF-8’. Available encodings are specified at <a href='http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding'>http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding</a>.</p> </td> </tr> <tr valign='top'> <td><code>.value</code></td> <td> <p>node or nodeset to insert.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If named attributes or namespaces to set on the node, if unnamed text to assign to the node.</p> </td> </tr> <tr valign='top'> <td><code>.copy</code></td> <td> <p>whether to copy the <code>.value</code> before replacing. If this is <code>FALSE</code> then the node will be moved from it's current location.</p> </td> </tr> <tr valign='top'> <td><code>.version</code></td> <td> <p>The version number of the document, passed to <code>xml_new_document(version)</code>.</p> </td> </tr> <tr valign='top'> <td><code>.encoding</code></td> <td> <p>The encoding of the document, passed to <code>xml_new_document(encoding)</code>.</p> </td> </tr> </table> "	FALSE
"xml_ns"	"xml2"	"XML namespaces."	"<p><code>xml_ns</code> extracts all namespaces from a document, matching each unique namespace url with the prefix it was first associated with. Default namespaces are named <code>d1</code>, <code>d2</code> etc. Use <code>xml_ns_rename</code> to change the prefixes. Once you have a namespace object, you can pass it to other functions to work with fully qualified names instead of local names. </p>"	"<pre>xml_ns(x)<br />xml_ns_rename(old, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>old, ...</code></td> <td> <p>An existing xml_namespace object followed by name-value (old prefix-new prefix) pairs to replace.</p> </td> </tr> </table> "	FALSE
"xml_ns"	"xml2"	"XML namespaces."	"<p><code>xml_ns</code> extracts all namespaces from a document, matching each unique namespace url with the prefix it was first associated with. Default namespaces are named <code>d1</code>, <code>d2</code> etc. Use <code>xml_ns_rename</code> to change the prefixes. Once you have a namespace object, you can pass it to other functions to work with fully qualified names instead of local names. </p>"	"<pre>xml_ns(x)<br />xml_ns_rename(old, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>old, ...</code></td> <td> <p>An existing xml_namespace object followed by name-value (old prefix-new prefix) pairs to replace.</p> </td> </tr> </table> "	FALSE
"xml_ns_strip"	"xml2"	"Strip the default namespaces from a document"	"<p>Strip the default namespaces from a document </p>"	"<pre>xml_ns_strip(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr></table> "	FALSE
"xml_children"	"xml2"	"Navigate around the family tree."	"<p><code>xml_children</code> returns only elements, <code>xml_contents</code> returns all nodes. <code>xml_length</code> returns the number of children. <code>xml_parent</code> returns the parent node, <code>xml_parents</code> returns all parents up to the root. <code>xml_siblings</code> returns all nodes at the same level. <code>xml_child</code> makes it easy to specify a specific child to return. </p>"	"<pre>xml_children(x)<br />xml_child(x, search = 1, ns = xml_ns(x))<br />xml_contents(x)<br />xml_parents(x)<br />xml_siblings(x)<br />xml_parent(x)<br />xml_length(x, only_elements = TRUE)<br />xml_root(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>search</code></td> <td> <p>For <code>xml_child</code>, either the child number to return (by position), or the name of the child node to return. If there are multiple child nodes with the same name, the first will be returned</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>only_elements</code></td> <td> <p>For <code>xml_length</code>, should it count all children, or just children that are elements (the default)?</p> </td> </tr> </table> "	FALSE
"xml_children"	"xml2"	"Navigate around the family tree."	"<p><code>xml_children</code> returns only elements, <code>xml_contents</code> returns all nodes. <code>xml_length</code> returns the number of children. <code>xml_parent</code> returns the parent node, <code>xml_parents</code> returns all parents up to the root. <code>xml_siblings</code> returns all nodes at the same level. <code>xml_child</code> makes it easy to specify a specific child to return. </p>"	"<pre>xml_children(x)<br />xml_child(x, search = 1, ns = xml_ns(x))<br />xml_contents(x)<br />xml_parents(x)<br />xml_siblings(x)<br />xml_parent(x)<br />xml_length(x, only_elements = TRUE)<br />xml_root(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>search</code></td> <td> <p>For <code>xml_child</code>, either the child number to return (by position), or the name of the child node to return. If there are multiple child nodes with the same name, the first will be returned</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>only_elements</code></td> <td> <p>For <code>xml_length</code>, should it count all children, or just children that are elements (the default)?</p> </td> </tr> </table> "	FALSE
"xml_path"	"xml2"	"Retrieve the xpath to a node"	"<p>This is useful when you want to figure out where nodes matching an xpath expression live in a document. </p>"	"<pre>xml_path(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr></table> "	FALSE
"xml_replace"	"xml2"	"Modify a tree by inserting, replacing or removing nodes"	"<p><code>xml_add_sibling()</code> and <code>xml_add_child()</code> are used to insert a node as a sibling or a child. <code>xml_add_parent()</code> adds a new parent in between the input node and the current parent. <code>xml_replace()</code> replaces an existing node with a new node. <code>xml_remove()</code> removes a node from the tree. </p>"	"<pre>xml_replace(.x, .value, ..., .copy = TRUE)<br />xml_add_sibling(.x, .value, ..., .where = c('after', 'before'),<br />   .copy = TRUE)<br />xml_add_child(.x, .value, ..., .where = length(xml_children(.x)),<br />   .copy = TRUE)<br />xml_add_parent(.x, .value, ...)<br />xml_remove(.x, free = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>a document, node or nodeset.</p> </td> </tr> <tr valign='top'> <td><code>.value</code></td> <td> <p>node or nodeset to insert.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If named attributes or namespaces to set on the node, if unnamed text to assign to the node.</p> </td> </tr> <tr valign='top'> <td><code>.copy</code></td> <td> <p>whether to copy the <code>.value</code> before replacing. If this is <code>FALSE</code> then the node will be moved from it's current location.</p> </td> </tr> <tr valign='top'> <td><code>.where</code></td> <td> <p>to add thenew node, for <code>xml_add_child</code> the position after which to add, use <code>0</code> for the first child. For <code>xml_add_sibling</code> either ‘'befeore'’ or ‘'after'’ indicating if the new node should be before or after <code>.x</code>.</p> </td> </tr> <tr valign='top'> <td><code>free</code></td> <td> <p>When removing the node also free the memory used for that node. Note if you use this option you cannot use any existing objects pointing to the node or its children, it is likely to crash R or return garbage.</p> </td> </tr> </table> "	FALSE
"xml_replace"	"xml2"	"Modify a tree by inserting, replacing or removing nodes"	"<p><code>xml_add_sibling()</code> and <code>xml_add_child()</code> are used to insert a node as a sibling or a child. <code>xml_add_parent()</code> adds a new parent in between the input node and the current parent. <code>xml_replace()</code> replaces an existing node with a new node. <code>xml_remove()</code> removes a node from the tree. </p>"	"<pre>xml_replace(.x, .value, ..., .copy = TRUE)<br />xml_add_sibling(.x, .value, ..., .where = c('after', 'before'),<br />   .copy = TRUE)<br />xml_add_child(.x, .value, ..., .where = length(xml_children(.x)),<br />   .copy = TRUE)<br />xml_add_parent(.x, .value, ...)<br />xml_remove(.x, free = FALSE) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>a document, node or nodeset.</p> </td> </tr> <tr valign='top'> <td><code>.value</code></td> <td> <p>node or nodeset to insert.</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>If named attributes or namespaces to set on the node, if unnamed text to assign to the node.</p> </td> </tr> <tr valign='top'> <td><code>.copy</code></td> <td> <p>whether to copy the <code>.value</code> before replacing. If this is <code>FALSE</code> then the node will be moved from it's current location.</p> </td> </tr> <tr valign='top'> <td><code>.where</code></td> <td> <p>to add thenew node, for <code>xml_add_child</code> the position after which to add, use <code>0</code> for the first child. For <code>xml_add_sibling</code> either ‘'befeore'’ or ‘'after'’ indicating if the new node should be before or after <code>.x</code>.</p> </td> </tr> <tr valign='top'> <td><code>free</code></td> <td> <p>When removing the node also free the memory used for that node. Note if you use this option you cannot use any existing objects pointing to the node or its children, it is likely to crash R or return garbage.</p> </td> </tr> </table> "	FALSE
"xml_children"	"xml2"	"Navigate around the family tree."	"<p><code>xml_children</code> returns only elements, <code>xml_contents</code> returns all nodes. <code>xml_length</code> returns the number of children. <code>xml_parent</code> returns the parent node, <code>xml_parents</code> returns all parents up to the root. <code>xml_siblings</code> returns all nodes at the same level. <code>xml_child</code> makes it easy to specify a specific child to return. </p>"	"<pre>xml_children(x)<br />xml_child(x, search = 1, ns = xml_ns(x))<br />xml_contents(x)<br />xml_parents(x)<br />xml_siblings(x)<br />xml_parent(x)<br />xml_length(x, only_elements = TRUE)<br />xml_root(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>search</code></td> <td> <p>For <code>xml_child</code>, either the child number to return (by position), or the name of the child node to return. If there are multiple child nodes with the same name, the first will be returned</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>only_elements</code></td> <td> <p>For <code>xml_length</code>, should it count all children, or just children that are elements (the default)?</p> </td> </tr> </table> "	FALSE
"xml_serialize"	"xml2"	"Serializing XML objects to connections."	"<p>Serializing XML objects to connections. </p>"	"<pre>xml_serialize(object, connection, ...)<br />xml_unserialize(connection, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>object</code></td> <td> <p><span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span> object to serialize.</p> </td> </tr> <tr valign='top'> <td><code>connection</code></td> <td> <p>an open connection or (for <code>serialize</code>) <code>NULL</code> or (for <code>unserialize</code>) a raw vector (see ‘Details’).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed to <code>read_xml</code>.</p> </td> </tr> </table> "	FALSE
"xml_attr"	"xml2"	"Retrieve an attribute."	"<p><code>xml_attrs()</code> retrieves all attributes values as a named character vector, <code>xml_attrs() &lt;-</code> or <code>xml_set_attrs()</code> sets all attribute values. <code>xml_attr()</code> retrieves the value of single attribute and <code>xml_attr() &lt;-</code> or <code>xml_set_attr()</code> modifies its value. If the attribute doesn't exist, it will return <code>default</code>, which defaults to <code>NA</code>. <code>xml_has_attr()</code> tests if an attribute is present. </p>"	"<pre>xml_attr(x, attr, ns = character(), default = NA_character_)<br />xml_has_attr(x, attr, ns = character())<br />xml_attrs(x, ns = character())<br />xml_attr(x, attr, ns = character()) &lt;- value<br />xml_set_attr(x, attr, value, ns = character())<br />xml_attrs(x, ns = character()) &lt;- value<br />xml_set_attrs(x, value, ns = character()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>attr</code></td> <td> <p>Name of attribute to extract.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>Default value to use when attribute is not present.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector of new value.</p> </td> </tr> </table> "	FALSE
"xml_attr"	"xml2"	"Retrieve an attribute."	"<p><code>xml_attrs()</code> retrieves all attributes values as a named character vector, <code>xml_attrs() &lt;-</code> or <code>xml_set_attrs()</code> sets all attribute values. <code>xml_attr()</code> retrieves the value of single attribute and <code>xml_attr() &lt;-</code> or <code>xml_set_attr()</code> modifies its value. If the attribute doesn't exist, it will return <code>default</code>, which defaults to <code>NA</code>. <code>xml_has_attr()</code> tests if an attribute is present. </p>"	"<pre>xml_attr(x, attr, ns = character(), default = NA_character_)<br />xml_has_attr(x, attr, ns = character())<br />xml_attrs(x, ns = character())<br />xml_attr(x, attr, ns = character()) &lt;- value<br />xml_set_attr(x, attr, value, ns = character())<br />xml_attrs(x, ns = character()) &lt;- value<br />xml_set_attrs(x, value, ns = character()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>attr</code></td> <td> <p>Name of attribute to extract.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>default</code></td> <td> <p>Default value to use when attribute is not present.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector of new value.</p> </td> </tr> </table> "	FALSE
"xml_name"	"xml2"	"The (tag) name of an xml element."	"<p>The (tag) name of an xml element. </p> <p>Modify the (tag) name of an element </p>"	"<pre>xml_name(x, ns = character())<br />xml_name(x, ns = character()) &lt;- value<br />xml_set_name(x, value, ns = character()) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>a character vector with replacement name.</p> </td> </tr> </table> "	FALSE
"xml_set_namespace"	"xml2"	"Set the node's namespace"	"<p>The namespace to be set must be already defined in one of the node's ancestors. </p>"	"<pre>xml_set_namespace(.x, prefix = '', uri = '') </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>.x</code></td> <td> <p>a node</p> </td> </tr> <tr valign='top'> <td><code>prefix</code></td> <td> <p>The namespace prefix to use</p> </td> </tr> <tr valign='top'> <td><code>uri</code></td> <td> <p>The namespace URI to use</p> </td> </tr> </table> "	FALSE
"xml_text"	"xml2"	"Extract or modify the text"	"<p><code>xml_text</code> returns a character vector, <code>xml_double</code> returns a numeric vector, <code>xml_integer</code> returns an integer vector. </p>"	"<pre>xml_text(x, trim = FALSE)<br />xml_text(x) &lt;- value<br />xml_set_text(x, value)<br />xml_double(x)<br />xml_integer(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> will trim leading and trailing spaces.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector with replacement text.</p> </td> </tr> </table> "	FALSE
"xml_children"	"xml2"	"Navigate around the family tree."	"<p><code>xml_children</code> returns only elements, <code>xml_contents</code> returns all nodes. <code>xml_length</code> returns the number of children. <code>xml_parent</code> returns the parent node, <code>xml_parents</code> returns all parents up to the root. <code>xml_siblings</code> returns all nodes at the same level. <code>xml_child</code> makes it easy to specify a specific child to return. </p>"	"<pre>xml_children(x)<br />xml_child(x, search = 1, ns = xml_ns(x))<br />xml_contents(x)<br />xml_parents(x)<br />xml_siblings(x)<br />xml_parent(x)<br />xml_length(x, only_elements = TRUE)<br />xml_root(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>search</code></td> <td> <p>For <code>xml_child</code>, either the child number to return (by position), or the name of the child node to return. If there are multiple child nodes with the same name, the first will be returned</p> </td> </tr> <tr valign='top'> <td><code>ns</code></td> <td> <p>Optionally, a named vector giving prefix-url pairs, as produced by <code>xml_ns</code>. If provided, all names will be explicitly qualified with the ns prefix, i.e. if the element <code>bar</code> is defined in namespace <code>foo</code>, it will be called <code>foo:bar</code>. (And similarly for atttributes). Default namespaces must be given an explicit name. The ns is ignored when using <code>xml_name&lt;-</code> and <code>xml_set_name</code>.</p> </td> </tr> <tr valign='top'> <td><code>only_elements</code></td> <td> <p>For <code>xml_length</code>, should it count all children, or just children that are elements (the default)?</p> </td> </tr> </table> "	FALSE
"xml_structure"	"xml2"	"Show the structure of an html/xml document."	"<p>Show the structure of an html/xml document without displaying any of the values. This is useful if you want to get a high level view of the way a document is organised. Compared to <code>xml_structure</code>, <code>html_structure</code> prints the id and class attributes. </p>"	"<pre>xml_structure(x, indent = 2)<br />html_structure(x, indent = 2) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>HTML/XML document (or part there of)</p> </td> </tr> <tr valign='top'> <td><code>indent</code></td> <td> <p>Number of spaces to ident</p> </td> </tr> </table> "	FALSE
"xml_text"	"xml2"	"Extract or modify the text"	"<p><code>xml_text</code> returns a character vector, <code>xml_double</code> returns a numeric vector, <code>xml_integer</code> returns an integer vector. </p>"	"<pre>xml_text(x, trim = FALSE)<br />xml_text(x) &lt;- value<br />xml_set_text(x, value)<br />xml_double(x)<br />xml_integer(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> will trim leading and trailing spaces.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector with replacement text.</p> </td> </tr> </table> "	FALSE
"xml_text"	"xml2"	"Extract or modify the text"	"<p><code>xml_text</code> returns a character vector, <code>xml_double</code> returns a numeric vector, <code>xml_integer</code> returns an integer vector. </p>"	"<pre>xml_text(x, trim = FALSE)<br />xml_text(x) &lt;- value<br />xml_set_text(x, value)<br />xml_double(x)<br />xml_integer(x) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>trim</code></td> <td> <p>If <code>TRUE</code> will trim leading and trailing spaces.</p> </td> </tr> <tr valign='top'> <td><code>value</code></td> <td> <p>character vector with replacement text.</p> </td> </tr> </table> "	FALSE
"xml_type"	"xml2"	"Determine the type of a node."	"<p>Determine the type of a node. </p>"	"<pre>xml_type(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr></table> "	FALSE
"xml_serialize"	"xml2"	"Serializing XML objects to connections."	"<p>Serializing XML objects to connections. </p>"	"<pre>xml_serialize(object, connection, ...)<br />xml_unserialize(connection, ...) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>object</code></td> <td> <p><span style='font-family: Courier New, Courier; color: #666666;'><b>R</b></span> object to serialize.</p> </td> </tr> <tr valign='top'> <td><code>connection</code></td> <td> <p>an open connection or (for <code>serialize</code>) <code>NULL</code> or (for <code>unserialize</code>) a raw vector (see ‘Details’).</p> </td> </tr> <tr valign='top'> <td><code>...</code></td> <td> <p>Additional arguments passed to <code>read_xml</code>.</p> </td> </tr> </table> "	FALSE
"xml_url"	"xml2"	"The URL of an XML document"	"<p>This is useful for interpreting relative urls with <code>url_relative</code>. </p>"	"<pre>xml_url(x) </pre>"	"<table summary='R argblock'><tr valign='top'> <td><code>x</code></td> <td> <p>A node or document.</p> </td> </tr></table> "	FALSE
"xml_validate"	"xml2"	"Validate XML schema"	"<p>Validate an XML document against an XML 1.0 schema. </p>"	"<pre>xml_validate(x, schema) </pre>"	"<table summary='R argblock'> <tr valign='top'> <td><code>x</code></td> <td> <p>A document, node, or node set.</p> </td> </tr> <tr valign='top'> <td><code>schema</code></td> <td> <p>an XML document containing the schema</p> </td> </tr> </table> "	FALSE
